<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> App与Extensions间通信共享数据 · xiao</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2015/04/06/2015-04-06-Communication-between-your-App-and-Extensions/" class="post-title-link">App与Extensions间通信共享数据</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/iOS/" class="post-tag-link">iOS</a></li><li class="post-tag-item"><a href="/tags/Swift/" class="post-tag-link">Swift</a></li><li class="post-tag-item"><a href="/tags/AppGroups/" class="post-tag-link">AppGroups</a></li><li class="post-tag-item"><a href="/tags/App-Extensions/" class="post-tag-link">App Extensions</a></li></ul><div class="post-time">Monday, April 6th 2015</div></div><div class="post-content"><p>最近玩了玩Watch开发，而目前Watch的主要逻辑处理都是放在WatchKit Extension。真正的Host App，也就是WatchKit App只是用来在界面上显示数据的。于是实践了下containing app与app extension之间的通信和数据共享。  </p>
<a id="more"></a>
<p>##App Groups &amp; Framework</p>
<p>这两样兵器大家都很熟悉。想要共享数据就需要开启App Groups，给group起一个风骚的名字，这样无论是<code>NSUserDefaults</code>还是<code>NSFileManager</code>都能通过App Groups共享持久层数据了。Core Data也需要<code>NSFileManager</code>提供存储的URL支持，而存取Core Data中的数据需要大量的模板代码，在持久层文件共享之后，代码也应该做到共享，所以将能够重用的代码打包成Framework就显得尤为重要。(除非是为了做毕设凑代码量)  </p>
<p>还是以<a href="https://github.com/yulingtianxia/HardChoice" target="_blank" rel="external">HardChoice</a>为例，我新建了一个类型为Cocoa Touch Framework的target，名字叫DataKit。新建一个DataAccess.swift文件并将以前AppDelegate.swift中自动生成的Core Data模版代码转移过来。得益于Swift1.2的改进，构造一个线程安全的单例模式变得无比简单：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private static let instance = DataAccess()</div><div class="line">public class var sharedInstance : DataAccess &#123;</div><div class="line">   return instance</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意Swift的权限控制问题，我们需要在暴漏给框架使用者的公开接口和属性前加上<code>public</code>关键字修饰。  </p>
<p>为了实现Core Data持久层共享，需要修改原先的<code>applicationDocumentsDirectory</code>属性：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">lazy var applicationDocumentsDirectory: NSURL = &#123;</div><div class="line">   // The directory the application uses to store the Core Data store file. This code uses a directory named &quot;com.yxy.iCloudCoreDataTest&quot; in the application&apos;s documents Application Support directory.</div><div class="line">   //        let urls = NSFileManager.defaultManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)</div><div class="line">   //        return urls[urls.count-1] as! NSURL</div><div class="line">   var sharedContainerURL:NSURL? = NSFileManager.defaultManager().containerURLForSecurityApplicationGroupIdentifier(appGroupIdentifier)</div><div class="line">   return sharedContainerURL ?? NSURL()</div><div class="line">   &#125;()</div></pre></td></tr></table></figure>
<p>在这里<code>containerURLForSecurityApplicationGroupIdentifier</code>方法起到了至关作用。  </p>
<p>同样能够共享的代码就是Model层，它们都是<code>NSManagedObject</code>的子类，用于存储Core Data中的数据实例。在把它们从原来的位置拖拽过来时别忘了更改下文件的target：”File inspector”-&gt;”Target Membership”，选中DataKit。  </p>
<p>在处理iCloud与Core Data同步数据时，我对<code>NSPersistentStoreCoordinatorStoresWillChangeNotification</code>、<code>NSPersistentStoreCoordinatorStoresDidChangeNotification</code>和<code>NSPersistentStoreDidImportUbiquitousContentChangesNotification</code>这三个数据更新的通知进行了观察和处理，但是写在了<code>persistentStoreCoordinator</code>计算属性的get方法中。现在使用<code>lazy</code>关键字进行惰性加载，导致对这三个数据更新通知的观察延后，这会引发严重的错误。所以需要将那三个<code>addObserverForName(name, object, queue, usingBlock)</code>方法挪到<code>init()</code>方法中，在第一时间观察通知。</p>
<p>最后在AppDelegate.swift中添加<code>import DataKit</code>，替换掉中的<code>application(application, didFinishLaunchingWithOptions) -&gt; Bool</code>方法中<code>controller.managedObjectContext = managedObjectContext</code>为<code>controller.managedObjectContext = DataAccess.sharedInstance.managedObjectContext</code>，也就是不再使用以前的模板代码中的上下文实例，而是用DataAccess单例中的<code>managedObjectContext</code>。  </p>
<p>同理，<code>applicationWillTerminate(application)</code>方法中的<code>saveContext()</code>也要替换成<code>DataAccess.sharedInstance.saveContext()</code>。  </p>
<p>于是我们也可以在App Extensions中import进来DataKit，进行地存取Core Data中的数据啦。而且用的是同一段代码，同一块数据。简直是同一个世界，同一个梦想啊。  </p>
<p>##Container app 与 Extension的通信  </p>
<p>要知道之前做的共享数据只能是主动获取数据，并不能在数据变化时实时获取通知。如果用户在iPhone上更改了数据，我们需要在Watch上实时更改界面上数据的显示。这点<code>NSNotificationCenter</code>是做不到的，因为它只在App内部工作而不会在两个App之间发通知。同样KVO也无能为力，自己手写委托什么的更是别想了(因为我试过了)。直到我在<a href="https://medium.com/@saberjack/ios-sending-notifications-between-your-apps-3fe7422d6a41" target="_blank" rel="external">这篇文章</a>找到了救世主，问题迎刃而解：  </p>
<p>###CFNotificationCenterGetDarwinNotifyCenter</p>
<p>这是CoreFoundation库中一个系统级的通知中心，苹果的系统自己也在用它，看清了”Darwin”了没有？哈哈！看了下<code>CFNotificationCenter</code>相关的API，跟<code>NSNotificationCenter</code>有点像。需要用到Toll-Bridge的知识与CoreFoundation相关的类进行桥接，这虽不常用但也不难。还需要注意下个别参数的使用。  </p>
<p>###MMWormhole</p>
<p>更有趣的是几乎同时我也发现了<a href="https://github.com/mutualmobile/MMWormhole" target="_blank" rel="external">MMWormhole</a>这个开源库，它专门用于在Container app 与 Extension间传递消息。我读了下它的代码，虽然只有一个类，但是依然学到了很多。虽然在我的<a href="https://github.com/yulingtianxia/HardChoice" target="_blank" rel="external">HardChoice</a>上完全可以只用<code>CFNotificationCenter</code>进行通知就可以了，完全不需要使用MMWormhole来持久化数据和传递数据。但我觉得以后还可能会用到MMWormhole，于是我用Swift1.2重新写了一个<a href="https://github.com/yulingtianxia/HardChoice/blob/master/HardChoice/DataKit/Wormhole.swift" target="_blank" rel="external">Wormhole.swift</a>，放在了DataKit里。  </p>
<p>###Swift与CoreFoundation</p>
<p>原来OC写的两百多行的MMWormhole被我用150行“清新优雅”的Swift代码取代。之所以打上引号是因为Swift与CoreFoundation之间的桥接有些不愉快。因为CoreFoundation中都是C的API，C中的指针和类型转换很出格，有安全隐患。Swift是一门安全的语言，但为了调用由历史原因造成的不安全的C的API，Swift中引入了很多类型来映射C中的类型，参考<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-XID_11" target="_blank" rel="external">Interacting with C APIs</a>  </p>
<p>Swift中不用像OC那样使用<code>__bridge</code>和类型转换、内存管理交接，因为这些全都交给Swift了：如果Swift中存在类型映射到C的API所需的参数类型，那么可以直接将其传入API。此外内存管理也归Swift中的ARC统一管理。于是Swift大大简化了与CoreFoundation打交道的过程。  </p>
<p>我们最关心的是指针，<code>UnsafePointer&lt;SwiftType&gt;</code>对应了<code>const CType *</code>，<code>UnsafeMutablePointer&lt;SwiftType&gt;</code>对应了<code>CType *</code>。当然SwiftType与CType也是对应的：  </p>
<table>
<thead>
<tr>
<th>C Type</th>
<th style="text-align:center">Swift Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td style="text-align:center">CBool</td>
</tr>
<tr>
<td>char, signed char</td>
<td style="text-align:center">CChar</td>
</tr>
<tr>
<td>unsigned char</td>
<td style="text-align:center">CUnsignedChar</td>
</tr>
<tr>
<td>short</td>
<td style="text-align:center">CShort</td>
</tr>
<tr>
<td>unsigned short</td>
<td style="text-align:center">CUnsignedShort</td>
</tr>
<tr>
<td>int</td>
<td style="text-align:center">CInt</td>
</tr>
<tr>
<td>unsigned int</td>
<td style="text-align:center">CUnsignedInt</td>
</tr>
<tr>
<td>long</td>
<td style="text-align:center">CLong</td>
</tr>
<tr>
<td>unsigned long</td>
<td style="text-align:center">CUnsignedLong</td>
</tr>
<tr>
<td>long long</td>
<td style="text-align:center">CLongLong</td>
</tr>
<tr>
<td>unsigned long long</td>
<td style="text-align:center">CUnsignedLongLong</td>
</tr>
<tr>
<td>wchar_t</td>
<td style="text-align:center">CWideChar</td>
</tr>
<tr>
<td>char16_t</td>
<td style="text-align:center">CChar16</td>
</tr>
<tr>
<td>char32_t</td>
<td style="text-align:center">CChar32</td>
</tr>
<tr>
<td>float</td>
<td style="text-align:center">CFloat</td>
</tr>
<tr>
<td>double</td>
<td style="text-align:center">CDouble</td>
</tr>
</tbody>
</table>
<p>更多的转换规则，在上面提到的官方文档有很详细的描述，这里只说三个tips：  </p>
<ol>
<li>在Swift中将<code>self</code>转成<code>UnsafePointer&lt;Void&gt;</code>(也就是<code>const void *</code>)只需用这个函数：<code>unsafeAddressOf(self)</code>  </li>
<li>CoreFoundation库中后缀为”Ref”的类在Swift中已经去掉后缀。  </li>
<li>Swift中函数指针被表示为<code>CFunctionPointer&lt;Type&gt;</code>，Type就是函数的类型，但还不允许你将Swift写的函数或闭包转化成<code>CFunctionPointer</code>，也就是干脆没提供建立<code>CFunctionPointer</code>实例的方法，只能通过外部引入C的函数。这就涉及到了Swift与OC混编，请戳<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_77" target="_blank" rel="external">Swift and Objective-C in the Same Project</a>  </li>
</ol>
<p>###在Framework中混编OC</p>
<p>我之所以需要做这种破坏工程纯洁性的事儿，是因为要用到下面这个方法来对通知进行观察：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func CFNotificationCenterAddObserver(center: CFNotificationCenter!, observer: UnsafePointer&lt;Void&gt;, callBack: CFNotificationCallback, name: CFString!, object: UnsafePointer&lt;Void&gt;, suspensionBehavior: CFNotificationSuspensionBehavior)</div></pre></td></tr></table></figure>
<p>除了类型为<code>CFNotificationCallback</code>的参数，其余的都好说：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typealias CFNotificationCallback = CFunctionPointer&lt;((CFNotificationCenter!, UnsafeMutablePointer&lt;Void&gt;, CFString!, UnsafePointer&lt;Void&gt;, CFDictionary!) -&gt; Void)&gt;</div></pre></td></tr></table></figure>
<p>于是就回到了<code>CFunctionPointer</code>这块蛋疼地上了，只好在OC里写C函数然后调用之：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static NSString * const WormholeNotificationName = @&quot;WormholeNotificationName&quot;;</div><div class="line">@implementation HelpMethod</div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _callback = wormholeNotificationCallback;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">void wormholeNotificationCallback(CFNotificationCenterRef center,</div><div class="line">                                  void * observer,</div><div class="line">                                  CFStringRef name,</div><div class="line">                                  void const * object,</div><div class="line">                                  CFDictionaryRef userInfo) &#123;</div><div class="line">    NSString *identifier = (__bridge NSString *)name;</div><div class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:WormholeNotificationName</div><div class="line">                                                        object:nil</div><div class="line">                                                      userInfo:@&#123;@&quot;identifier&quot; : identifier&#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后在Swift中这样写就可以了：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFNotificationCenterAddObserver(center, unsafeAddressOf(self), helpMethod.callback, identifier, nil, CFNotificationSuspensionBehavior.DeliverImmediately)</div></pre></td></tr></table></figure>
<p>在Swift中使用OC写的类本来是一件很easy的事儿，但是到了Framework中就变得不寻常。我在DataKit中新建了<code>HelpMethod</code>类，并建立”DataKit-Bridging-Header.h”文件，将HelpMethod.h头文件引入，然后在DataKit target下的”Build Settings” -&gt; “Swift Complier-Code Generation” -&gt; “Objective-C Bridging Header”下填入”DataKit-Bridging-Header.h”，编译出错：<strong>using bridging headers with framework targets is unsupported</strong>。  </p>
<p>在stackoverflow上找到了<a href="http://stackoverflow.com/questions/24875745/xcode-6-beta-4-using-bridging-headers-with-framework-targets-is-unsupported" target="_blank" rel="external">解决方案</a>，于是删除之前的”DataKit-Bridging-Header.h”文件并清除”Build Settings”关于Bridging Header的引用；在DataKit.h添加<code>#import &quot;HelpMethod.h&quot;</code>，并在HelpMethod.h文件的 “File inspector”-&gt;”Target Membership”中DataKit右侧将”project”修改为”public”(否则会出现<strong>include of non-modular header inside framework module ‘DataKit’</strong>的编译错误)。  </p>
<p>至此，我们可以在<code>HelpMethod</code>类中实现一个函数指针，并在Wormhole.swift文件中直接使用这个函数指针来为<code>CFunctionPointer</code>类型的参数传值。  </p>
<p>##总结</p>
<p>来个效果图：  </p>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/hardchoice.gif" alt="">  </p>
<p>这是我第一次写Watch的App(废话谁不是第一次)，经验并不是很多，也因为Swift1.2还未正式发布，遇到了一些坑。好歹最后克服了，但也丢了贞操(毕竟不是纯Swift的App了)。有不对的地方还请多多指教。随着Swift的不断完善，希望以后能够支持创建<code>CFunctionPointer</code>对象，这样它好我也好😄</p>
</div></article><div class="pagination"><a href="/2015/04/19/AutoreleasePool剖析/" class="pagination-prev">PREV</a><a href="/2015/03/08/2015-03-08-Insight-of-Null/" class="pagination-next">NEXT</a></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARC/">ARC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/App-Extensions/">App Extensions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AppGroups/">AppGroups</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/24/一首小诗/">1024,一首小诗</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/终有一天/">终有一天.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/樱花樱花想见你/">樱花樱花想见你</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/工具本/">小tips汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/CI搭建和脚本自动化/">CI搭建和脚本自动化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/01/又要春节了啊/">又要春节了啊</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/写给PM的iOS消息推送/">写给PM的iOS消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/19/gitlab和sourcetree的使用/">gitlab和sourcetree的使用</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2017 <a href="/">sopig</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?38155daa8b79fb3a5cad11d825228868";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>