<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> AutoreleasePool剖析 · xiao</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2015/04/19/AutoreleasePool剖析/" class="post-title-link">AutoreleasePool剖析</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/iOS-AutoreleasePool/" class="post-tag-link">iOS AutoreleasePool</a></li></ul><div class="post-time">Sunday, April 19th 2015</div></div><div class="post-content"><p>##概述<br>MRC时代，我们手动管理对象的创建与销毁，OC内部是通过引用计数的机制去管理对象内存。一般我们创建一个对象需要手动retain与release，有时候我们不使用release，而是使用autorelease，当时模糊的概念也就是说这个对象会在稍后某个时候自动释放，无须手动调用release，看上去很神奇，可是一想疑惑很多。到底什么时候释放，它是如何释放的？</p>
<p>ARC时代之后，我们逐渐抛弃了retain和release等内存管理的操作，把编程的重心放在了代码逻辑上，语言的进化让每个人更专注于自己要实现的功能而更少地关注语言底层的实现细节，我们不用去处理对象的释放问题，那这时候MRC时代的autorelease功能是不是就可以放弃了？</p>
<p>看似ARC为我们做了一切，实际上苹果只是在编译层面帮我们转换成类似MRC的代码，底层内存管理机制依旧是原来的引用计数那一套。</p>
<p>##AutoreleasePool原理<br>为了显示调用autoreleasepool，苹果引入了一个block<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"yzj"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//创建的对象都会被丢入pool中</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该block内创建的对象（非alloc、new、copy、mutableCopy）都会自动调用autorelease方法加入autoreleasepool，在block结束时autoreleasepool自动对丢入pool中的对象执行release方法，使引用计数减1。</p>
<p>这里有些人会有疑惑了，我要这干嘛呢，普通的{}作用域不也可以干这件事么？{}作用域内创建的变量ARC都会帮我们在{}结尾处插入变量调用的release方法不是么？<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> a = [<span class="built_in">NSObject</span> new];</div><div class="line">    <span class="comment">//[a release];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看上去类似，但是事实上内部机制完全不同。<br>ARC时代苹果优化了对象创建时的返回值策略，大体上会把下面这段代码改写成另一段代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Jacob *jb = [Jacob new];</div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> imp = objc_retainAutoreleasedReturnValue([Jacob new]);</div><div class="line">Jacob *jb = imp;</div></pre></td></tr></table></figure>
<p>查看objc4对这个方法的定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> </div><div class="line">objc_retainAutoreleaseReturnValue(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(objc_retain(obj));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">id</span> </div><div class="line">objc_autoreleaseReturnValue(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (fastAutoreleaseForReturn(obj)) <span class="keyword">return</span> obj;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> objc_autorelease(obj);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">id</span> objc_autorelease(<span class="keyword">id</span> obj) &#123; <span class="keyword">return</span> [obj autorelease]; &#125;</div></pre></td></tr></table></figure></p>
<p>我们先来剖析autorelease这个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)autorelease &#123;</div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootAutorelease();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </div><div class="line">objc_object::rootAutorelease()</div><div class="line">&#123;</div><div class="line">    assert(!UseGC);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (fastAutoreleaseForReturn((<span class="keyword">id</span>)<span class="keyword">this</span>)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> rootAutorelease2();</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((noinline,used))</div><div class="line"><span class="keyword">id</span> </div><div class="line">objc_object::rootAutorelease2()</div><div class="line">&#123;</div><div class="line">    assert(!isTaggedPointer());</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((<span class="keyword">id</span>)<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    assert(obj);</div><div class="line">    assert(!obj-&gt;isTaggedPointer());</div><div class="line">    <span class="keyword">id</span> *dest __unused = autoreleaseFast(obj);</div><div class="line">    assert(!dest  ||  *dest == obj);</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>忽略之前的一堆判断条件，最终我们跳转到这里，这里涉及到AutoreleasePoolPage的概念，稍后会详细说明<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> *autoreleaseFast(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *page = hotPage();</div><div class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">        <span class="keyword">return</span> page-&gt;add(obj);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</div><div class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这几个if-else调用的语句最终都会走一个add方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    assert(!full());</div><div class="line">    unprotect();</div><div class="line">    <span class="keyword">id</span> *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></div><div class="line">    *next++ = obj;</div><div class="line">    protect();</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>add方法就是把该对象的指针加入poolpage中，也就是我们理解的把对象加入到autoreleasepool中，那autoreleasepoolpage又是什么鬼？<br>我们来看它的数据结构：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> AutoreleasePoolPage </div><div class="line">&#123;</div><div class="line"><span class="meta">#define POOL_SENTINEL nil//哨兵对象</span></div><div class="line">    <span class="keyword">static</span> pthread_key_t <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;<span class="comment">//TLS用的数组KEY</span></div><div class="line">    <span class="keyword">static</span> uint8_t <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></div><div class="line">    <span class="keyword">static</span> size_t <span class="keyword">const</span> SIZE = </div><div class="line"><span class="meta">#if PROTECT_AUTORELEASEPOOL</span></div><div class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></div><div class="line"><span class="meta">#else</span></div><div class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></div><div class="line"><span class="meta">#endif//page的大小</span></div><div class="line">    <span class="keyword">static</span> size_t <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(<span class="keyword">id</span>);</div><div class="line"></div><div class="line">    magic_t <span class="keyword">const</span> magic;<span class="comment">//校验用的黑魔法</span></div><div class="line">    <span class="keyword">id</span> *next;<span class="comment">//当前page中最新对象的下一个位置</span></div><div class="line">    pthread_t <span class="keyword">const</span> thread;<span class="comment">//当前线程</span></div><div class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;<span class="comment">//前一个page</span></div><div class="line">    AutoreleasePoolPage *child;<span class="comment">//后一个page</span></div><div class="line">    uint32_t <span class="keyword">const</span> depth;<span class="comment">//page的index</span></div><div class="line">    uint32_t hiwat;<span class="comment">//我也不知道这是什么鬼</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>page是一个双链表结构，runtime自己维护这个链表，当往page中插入对象时，会直接插入next的位置，next往后移一位，如果当前page插入对象已满，则新建一个page，index+1，做校验等操作后继续插入新的对象。</p>
<p>我们把这段代码用编译器重写后看到如下代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</div><div class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</div><div class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</div><div class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* @autoreleasepool */</span> &#123; </div><div class="line">    __AtAutoreleasePool __autoreleasepool; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相当于在每个autoreleasepool开始和结尾处分别执行了push和pop操作，我们看源代码可以知道，push操作在page中插入一个哨兵对象（nil），当pop的时候，从高地址往低地址对每一个page中的对象执行release操作，直到遇到nil，也就是哨兵对象。这种机制可以实现autoreleasepool的嵌套结构，内层的pool可以不断创建，释放，而不影响外层的pool。从这我们也大致理解了autoreleasepool释放对象的原理。</p>
<p>最后提两点：<br>1.每一个RunLoop循环开始时会push一个autoreleasepool，结束时会pop一下<br>根据实验可以得出：viewdidload,viewwillappear在一个RunLoop中，viewdidappear在下一个RunLoop中，所以可以解释为什么viewdidload中丢入pool中的对象可以在viewwillappear中拿到，但在viewdidappear中却拿不到。<br>2.数组的这个遍历方法内部会有一个autoreleasepool，每次遍历都会释放当前循环的所有临时变量，内存占用小，所以推荐使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSArray</span> enumerate...^&#123;</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>相当于：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSArray</span> enumerate...^&#123;</div><div class="line"><span class="keyword">@autoreleasepool</span>&#123;</div><div class="line"><span class="comment">//inset code</span></div><div class="line">&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
</div></article><div class="pagination"><a href="/2015/04/26/记一次神奇的bug/" class="pagination-prev">PREV</a><a href="/2015/04/06/2015-04-06-Communication-between-your-App-and-Extensions/" class="pagination-next">NEXT</a></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARC/">ARC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/App-Extensions/">App Extensions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AppGroups/">AppGroups</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/24/一首小诗/">1024,一首小诗</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/终有一天/">终有一天.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/樱花樱花想见你/">樱花樱花想见你</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/工具本/">小tips汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/CI搭建和脚本自动化/">CI搭建和脚本自动化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/01/又要春节了啊/">又要春节了啊</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/写给PM的iOS消息推送/">写给PM的iOS消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/19/gitlab和sourcetree的使用/">gitlab和sourcetree的使用</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2017 <a href="/">sopig</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>