<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> swift的几个tips · xiao</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="https://github.com/xxxxxx" target="_blank" class="nav-link">github</a></li><li class="nav-list-item"><a href="https://coding.net/u/xxxxxx" target="_blank" class="nav-link">coding</a></li><li class="nav-list-item"><a href="http://weibo.com/xxxxxx" target="_blank" class="nav-link">weibo</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2015/10/19/swift的几个tips/" class="post-title-link">swift的几个tips</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/swift/" class="post-tag-link">swift</a></li></ul><div class="post-time">Monday, October 19th 2015</div></div><div class="post-content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-   最近在完成SDWebImage的swift版本改写。</div></pre></td></tr></table></figure>
<p>##swift初识</p>
<p><em>配置相关</em></p>
<blockquote>
<p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">Markdown详细说明</a><br><a href="http://25.io/mou/" target="_blank" rel="external">Markdown编辑器Mou</a><br><a href="https://github.com/ddapps/Swift/blob/master/Markdown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93.md" target="_blank" rel="external">Markdown详细语法</a><br><a href="https://github.com/ddapps/Swift/blob/master/swift%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93.md" target="_blank" rel="external">Swift开源项目总结</a><br><a href="./swift_OC_programMix.md">swift与OC混合编程——swift-mix-oc</a><br><a href="./swift_language_tips.md">swift_language</a><br><a href="http://www.cnblogs.com/jacklandrin/p/3782831.html" target="_blank" rel="external">swift中的关键字</a><br><a href="http://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/index.html" target="_blank" rel="external">The Swift Programming Language 中文版</a><br><a href="http://www.isaced.com/post-265.html" target="_blank" rel="external">Carthage使用</a>  </p>
</blockquote>
<p><em>语言语法特性</em>  </p>
<blockquote>
<p><a href="http://www.cocoachina.com/swift/20150129/11057.html?utm_source=tuicool" target="_blank" rel="external">在Swift中应用Grand Central Dispatch(上)</a><br><a href="http://www.cocoachina.com/swift/20150130/11054.html" target="_blank" rel="external">在Swift中应用Grand Central Dispatch(下)</a><br><a href="http://www.jianshu.com/p/f875bcb7e86c?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_author_hots&amp;utm_source=recommendation" target="_blank" rel="external">Swift 十二讲 前言和第一章(draft)</a><br><a href="http://www.jianshu.com/p/b4a202d6c77b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_author_hots&amp;utm_source=recommendation" target="_blank" rel="external">Swift 十二讲 第二章 常量变量类型元组字符串和操作符</a><br><a href="http://www.jianshu.com/p/94212e7f4030?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_author_hots&amp;utm_source=recommendation" target="_blank" rel="external">Swift十二讲 第三章 数组字典函数和闭包</a><br><a href="http://www.jianshu.com/p/7d3fbecfab30" target="_blank" rel="external">Swift 十二讲 第四章 范围区间和跨步和常用全局函数 (draft)</a><br><a href="http://www.jianshu.com/p/0ba4760d55c8" target="_blank" rel="external">Swift 十二讲 第五章 Ifelse/for/while/Switch loop</a><br><a href="http://www.jianshu.com/p/31ae2fb8fc93" target="_blank" rel="external">Swift 十二讲 第六章 类 (Class) (draft)</a><br><a href="http://www.jianshu.com/p/187486247cb8" target="_blank" rel="external">Swift 十二讲 第七章 结构体和聚合体 ,访问控制</a><br><a href="http://www.jianshu.com/p/247be9669a24" target="_blank" rel="external">Swift 十二讲 第八章 类型扩展(Extensions)和协议 (draft)</a><br><a href="http://www.jianshu.com/p/e3dc516fd465" target="_blank" rel="external">Swift 十二讲 第九讲 操作符重载和泛型</a><br><a href="http://www.jianshu.com/p/2b066dd939ed" target="_blank" rel="external">Swift 十二讲 第十讲 选项(Optionals)和内存管理ARC (draft)</a>  </p>
</blockquote>
<p>##swift必备知识点</p>
<p>####知识点1<br>— <em><strong>函数柯里化</strong></em><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 柯里化函数定义格式  </span></div><div class="line"><span class="function"><span class="keyword">func</span> &lt;#function name#&gt;<span class="params">(&lt;#parameters#&gt;)</span></span>(&lt;#parameters#&gt;)-&gt; &lt;#<span class="keyword">return</span> type#&gt;&#123;</div><div class="line">    &lt;#statements#&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">_info1-<span class="number">1_</span>  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Curry</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">// uncurried</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a: Int, b: Int, <span class="built_in">c</span>: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"\(a) + \(b) + \(c)"</span>)</div><div class="line">        <span class="keyword">return</span> a + b + <span class="built_in">c</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 手动实现柯里化函数</span></div><div class="line">    <span class="comment">// 把上面的函数转换为柯里化函数，首先转成接收第一个参数a，并且返回接收余下第一个参数b的新函数（采用闭包）</span></div><div class="line">    <span class="comment">// 基础不牢固可能看不懂,需要拆解来看</span></div><div class="line">    <span class="comment">// (a: Int) : 参数</span></div><div class="line">    <span class="comment">// (b:Int) -&gt; (c: Int) -&gt; Int : 函数返回值（一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数)</span></div><div class="line">    </div><div class="line">    <span class="comment">// 定义一个接收参数a,并且返回一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a: Int)</span></span> -&gt; (b:<span class="type">Int</span>) -&gt; (<span class="built_in">c</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 返回一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">        <span class="keyword">return</span> &#123; (b:<span class="type">Int</span>) -&gt; (<span class="built_in">c</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></div><div class="line">            </div><div class="line">            <span class="comment">// 返回一个接收余下第一个参数c，并且有返回结果为Int类型的函数</span></div><div class="line">            <span class="keyword">return</span> &#123; (<span class="built_in">c</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></div><div class="line">                </div><div class="line">                <span class="comment">// 这里为什么能使用参数a,b,c。</span></div><div class="line">                <span class="comment">// 利用闭包的值捕获特性，即使这些值作用域不在了，也可以捕获到他们的值。</span></div><div class="line">                <span class="comment">// 闭包会自动判断捕获的值是值拷贝还是值引用，如果修改了，就是值引用，否则值拷贝。</span></div><div class="line">                </div><div class="line">                <span class="comment">// 注意只有在闭包中才可以，a,b,c都在闭包中。</span></div><div class="line">                <span class="keyword">return</span> a + b + <span class="built_in">c</span>;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// curried</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addCur</span><span class="params">(a: Int)</span></span>(b: <span class="type">Int</span>)(<span class="built_in">c</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"\(a) + \(b) + \(c)"</span>)</div><div class="line">        <span class="keyword">return</span> a + b + <span class="built_in">c</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><em>info1-2</em>  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建柯里化类的实例</span></div><div class="line">      <span class="keyword">var</span> curryInstance = <span class="type">Curry</span>()</div><div class="line">      </div><div class="line">      <span class="comment">/*** 调用手动实现的柯里化函数 **/</span></div><div class="line">      <span class="keyword">var</span> r: <span class="type">Int</span> = curryInstance.add(<span class="number">10</span>)(b: <span class="number">20</span>)(<span class="built_in">c</span>: <span class="number">30</span>)</div><div class="line">      <span class="comment">// 可能很多人都是第一次看这样的调用，感觉有点不可思议。</span></div><div class="line">      <span class="comment">// 让我们回顾下OC创建对象 [[Person alloc] init]，这种写法应该都见过吧，就是一下发送了两个消息，alloc返回一个实例，再用实例调用init初始化,上面也是一样，一下调用多个函数，每次调用都会返回一个函数，然后再次调用这个返回的函数。</span></div><div class="line">      </div><div class="line">      <span class="comment">/***** 柯里化函数分解调用 *****/</span></div><div class="line">      <span class="comment">// 让我来帮你们拆解下，更容易看懂</span></div><div class="line">      <span class="comment">// curryInstance.add(10): 调用一个接收参数a,并且返回一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      <span class="comment">// functionB: 一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      <span class="keyword">var</span> functionB = curryInstance.add(<span class="number">10</span>)</div><div class="line">      </div><div class="line">      <span class="comment">// functionB(b: 20):调用一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      <span class="comment">// functionC: 一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      <span class="keyword">var</span> functionC = functionB(b: <span class="number">20</span>)</div><div class="line">      </div><div class="line">      <span class="comment">// functionC(c: 30): 调用一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      <span class="comment">// result: 函数的返回值</span></div><div class="line">      <span class="keyword">var</span> res: <span class="type">Int</span> = functionC(<span class="built_in">c</span>: <span class="number">30</span>);</div><div class="line">      </div><div class="line">      <span class="comment">// 这里会有疑问?，为什么不是调用curryInstance.add(a: 10)，而是curryInstance.add(10),functionB(b: 20),functionC(c: 30),怎么就有b,c,这是因为func add(a: Int) -&gt; (b:Int) -&gt; (c: Int) -&gt; Int这个方法中a是第一个参数，默认是没有外部参数名，只有余下的参数才有外部参数名,b,c都属于余下的参数。</span></div><div class="line">      </div><div class="line">      <span class="comment">/***** 系统的柯里化函数调用 *****/</span></div><div class="line">      <span class="keyword">var</span> result: <span class="type">Int</span> = curryInstance.addCur(<span class="number">10</span>)(b: <span class="number">20</span>)(<span class="built_in">c</span>: <span class="number">30</span>)</div><div class="line">      </div><div class="line">      <span class="comment">/***** 系统的柯里化函数拆解调用 *****/</span></div><div class="line">      <span class="comment">// curryInstance.addCur(10) : 调用一个接收参数a,并且返回一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      <span class="comment">// 注意：Swift是强类型语言，这里没有报错，说明调用系统柯里化函数返回的类型和手动的functionB类型一致</span></div><div class="line">      <span class="comment">// functionB: 一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      functionB = curryInstance.addCur(<span class="number">10</span>)</div><div class="line">      </div><div class="line">      <span class="comment">// functionC: 一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      functionC = functionB(b: <span class="number">20</span>)</div><div class="line">      </div><div class="line">      <span class="comment">// result: 函数的返回值</span></div><div class="line">      res = functionC(<span class="built_in">c</span>: <span class="number">30</span>)</div><div class="line">      </div><div class="line">      <span class="comment">// 打印 60，60，60说明手动实现的柯里化函数，和系统的一样。</span></div><div class="line">      <span class="built_in">println</span>(<span class="string">"\(r),\(res),\(result)"</span>)</div><div class="line">      </div><div class="line">      <span class="comment">/************************************ 华丽的分割线 *********************************************/</span></div><div class="line">      <span class="comment">/*************************** 实例方法的另一种调用方式（柯里化）************************************/</span></div><div class="line">      <span class="comment">// 创建柯里化类的实例</span></div><div class="line">      <span class="keyword">var</span> curryingInstance = <span class="type">Currying</span>()</div><div class="line">      </div><div class="line">      <span class="comment">// 调用function方法</span></div><div class="line">      <span class="type">Currying</span>.function(curryingInstance)()</div><div class="line">      </div><div class="line">      <span class="comment">// 拆解调用function方法</span></div><div class="line">      <span class="comment">// 1.获取function方法</span></div><div class="line">      <span class="keyword">let</span> function = <span class="type">Currying</span>.function(curryingInstance)</div><div class="line">      <span class="comment">// 2.调用function方法</span></div><div class="line">      function()</div><div class="line">      </div><div class="line">      <span class="comment">// 步骤都是一样，首先获取实例方法，在调用实例方法，实例方法怎么调用，就不需要在教了。</span></div></pre></td></tr></table></figure>
<p><em>info1-3</em>  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Currying</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">// 方法类型: () -&gt; Void</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">println</span>(<span class="keyword">__FUNCTION__</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 方法类型: (Int) -&gt; Void</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">functionParam</span><span class="params">(a: Int)</span></span>&#123;</div><div class="line">        <span class="built_in">println</span>(<span class="keyword">__FUNCTION__</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 方法类型: (Int, b: Int) -&gt; Void</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">functionParam</span><span class="params">(a: Int, b: Int)</span></span>&#123;</div><div class="line">        <span class="built_in">println</span>(<span class="keyword">__FUNCTION__</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 方法类型: (Int) -&gt; () -&gt; Void</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">functionCur</span><span class="params">(a: Int)</span></span>()&#123;</div><div class="line">        <span class="built_in">println</span>(<span class="keyword">__FUNCTION__</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>info1-4</em>  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 组合接口  </span></div><div class="line"><span class="comment">// 为什么要定义接口，为了程序的扩展性，以后只需要在接口中添加对应的组合方法就好了。  </span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CombineUI</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(top: <span class="params">()</span></span></span> -&gt; ())(bottom: () -&gt; ())()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UI</span>: <span class="title">NSObject</span>,<span class="title">CombineUI</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(top: <span class="params">()</span></span></span> -&gt; ())(bottom: () -&gt; ())() &#123;</div><div class="line">        <span class="comment">// 搭建顶部</span></div><div class="line">        top()</div><div class="line">        </div><div class="line">        <span class="comment">// 搭建底部</span></div><div class="line">        bottom()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>info1-5 文字总结</em><br>  柯里化(Currying),是函数式编程概念。也就是说把接受多个参数的方法变换成接受第一个参数的方法，<br>并且返回接受余下的参数并且返回结果的新方法。 swift中我们可以这样写出多个括号的方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(a:Int)</span></span>(b:<span class="type">Int</span>) -&gt;<span class="type">Int</span> &#123;</div><div class="line">	<span class="keyword">return</span> a+ b</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">  然后通过只传入第一个括号内的参数进行调用，这样将返回另一个方法：  </div><div class="line">```swift</div><div class="line"><span class="keyword">let</span> addToEndValue = addTwoNumbers(<span class="number">4</span>)   <span class="comment">//addToEndValue是一个Int-&gt;Int  </span></div><div class="line"><span class="keyword">let</span> result = addToEndValue(b:<span class="number">6</span>)  <span class="comment">//result = 10</span></div></pre></td></tr></table></figure></p>
<p>  柯里化是一种量产相似方法的好办法，可以通过柯里化一个方法模板来避免写出很多重复代码，也方便了今后的维护。<br>  举一个实际应用的例子，在swift中的selector只能使用字符串生成。这面临一个很严重的问题就是难以重构，并且无法在编译期间进行检查，这是十分危险的行为。但是target-action是Cocoa中非常重要得设计模式，无论如何我们都要安全使用的话，一种可能的解决方式就是利用方法的柯里化。  请看以下的解决思路<br>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">  <span class="class"><span class="keyword">protocol</span> <span class="title">TargetAction</span> </span>&#123;</div><div class="line">  	<span class="function"><span class="keyword">func</span> <span class="title">performAction</span><span class="params">()</span></span></div><div class="line">  &#125; </div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TargetActionWrapper</span>&lt;<span class="title">T</span>:<span class="title">AnyObject</span>&gt;:<span class="title">TargetAction</span> </span>&#123;</div><div class="line">  	<span class="keyword">weak</span> <span class="keyword">var</span> target:<span class="type">T</span>?</div><div class="line">  	<span class="keyword">let</span> action:(<span class="type">T</span>) -&gt; () -&gt; ()</div><div class="line">  	</div><div class="line">  	<span class="function"><span class="keyword">func</span> <span class="title">performAction</span><span class="params">()</span></span> -&gt; () &#123;</div><div class="line">  		<span class="keyword">if</span> <span class="keyword">let</span> t = target &#123;</div><div class="line">  			action(t)()</div><div class="line">  		&#125;</div><div class="line">  	&#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">ControlEvent</span> </span>&#123;</div><div class="line">  	<span class="keyword">case</span> <span class="type">TouchUpInside</span></div><div class="line">  	<span class="keyword">case</span> <span class="type">ValueChanged</span></div><div class="line">  	<span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</div><div class="line">  	<span class="keyword">var</span> actions = [<span class="type">ControlEvent</span>:<span class="type">TargetAction</span>]()</div><div class="line">  	</div><div class="line">  	<span class="function"><span class="keyword">func</span> <span class="title">setTarget</span>&lt;T:AnyObject&gt;<span class="params">(target:T,action:<span class="params">(T)</span></span></span>-&gt;()-&gt;(),controlEvent:<span class="type">ControlEvent</span>) &#123;</div><div class="line">  		actions[controlEvent] = <span class="type">TargetActionWrapper</span>(target:target,action:action)</div><div class="line">  	&#125;</div><div class="line">  	</div><div class="line">  	<span class="function"><span class="keyword">func</span> <span class="title">removeTargetForControlEvent</span><span class="params">(controlEvent:ControlEvent)</span></span> &#123;</div><div class="line">  		actions[controlEvent] = <span class="literal">nil</span></div><div class="line">  	&#125;</div><div class="line">  	</div><div class="line">  	<span class="function"><span class="keyword">func</span> <span class="title">performActionForControlEvent</span><span class="params">(controlEvent:ControlEvent)</span></span> &#123;</div><div class="line">  			actions[controlEvent]?.performAction()</div><div class="line">  	&#125;</div><div class="line">  	</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  ```  </div><div class="line">  </div><div class="line">####知识点<span class="number">2</span>  </div><div class="line">--- <span class="number">_</span>**将<span class="class"><span class="keyword">protocol</span>的方法声明为_mutating_**_  </span></div><div class="line"><span class="class">  <span class="title">swift</span>的`<span class="title">protocol</span>`不仅可以被`<span class="title">class</span>`类型实现，也适用于`<span class="title">struct</span>`和`<span class="title">enum</span>`.因为这个原因，我们在写给别人用的接口时需要多考虑是否使用`<span class="title">mutating</span>`来修饰方法，比如定义为`<span class="title">mutating</span> <span class="title">func</span> <span class="title">myMethod</span>()`。<span class="title">Swift</span>的<span class="title">mutating</span>关键字修饰方法是为了能够在该方法中修改`<span class="title">struct</span>`或者是`<span class="title">enum</span>`的变量，所以如果没有在接口方法里来实现这个接口的话，别人如果用`<span class="title">struct</span>`或者`<span class="title">enum</span>`来实现这个`<span class="title">protocol</span>`的画，就不能在方法里改变自己的变量了。  比如下面的代码。</span></div><div class="line"><span class="class">  ```<span class="title">swift</span></span></div><div class="line"><span class="class">  <span class="title">protocol</span> <span class="title">Vehicle</span> </span>&#123;</div><div class="line">  	<span class="keyword">var</span> numberOfWheels:<span class="type">Int</span> &#123;<span class="keyword">get</span>&#125;</div><div class="line">  	<span class="keyword">var</span> color:<span class="type">UIColor</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</div><div class="line">  	</div><div class="line">  	<span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Mycar</span>:<span class="title">Vehicle</span> </span>&#123;</div><div class="line">  	<span class="keyword">let</span> numbersOfWheels = <span class="number">4</span></div><div class="line">  	<span class="keyword">var</span> color = <span class="type">UIColor</span>.blueColor()</div><div class="line">  	</div><div class="line">  	<span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span> &#123;</div><div class="line">  		color = <span class="type">UIColor</span>.redColor()</div><div class="line">  	&#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p> 如果把<code>protocol</code> 定义中<code>mutating</code>关键字去掉的话，Mycar就没法编译，保持现有代码不变的话，会报错说没有实现接口。<br> 另外在使用<code>class</code>来实现带有<code>mutating</code>的方法接口时，具体的实现方法的前面是不需要加<code>mutating</code>修饰的，因为<code>class</code>可以随意更改自己的成员变量。所以说在接口里用<code>mutating</code>修饰方法，对于<code>class</code>的实现完全透明，可以当做不存在的。</p>
<p>####知识点3<br>–  <em><strong>多元组Turple</strong></em><br>多元组基本上都是动态语言支持的特性。<br>比如交换输入，普通程序员亘古以来可能都是这么写的<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapMe</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> a:T,<span class="keyword">inout</span> b:T)</span></span> &#123;</div><div class="line">	<span class="keyword">let</span> temp = a</div><div class="line">	a = b </div><div class="line">	b = temp </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是要使用多元组的话，我们可以是不是用额外的交换空间就完成交换<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapMe</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> a:T,<span class="keyword">inout</span> b:T)</span></span> &#123;</div><div class="line">	(a,b) = (b,a)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外一个特别常用的地方是错误处理。OC时代我们已经习惯了在需要错误处理的时候先做一个NSError的指针，然后将地址传到方法里面等待填充：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="type">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"><span class="type">BOOL</span> success = [<span class="type">NSFileManager</span> defaultManager] moveItemAtPath@<span class="string">"/path/to/target"</span> toPath:@<span class="string">"/path/to/detination"</span> error:&amp;error];</div><div class="line"><span class="keyword">if</span> (!success) &#123;</div><div class="line">	<span class="type">NSLog</span>(@<span class="string">"%@"</span>,error);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们新写库的时候可以直接考虑返回一个带有NSError的多元组，而不是去填充地址了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomethingMightCauseError</span><span class="params">()</span></span> -&gt; (<span class="type">Bool</span>,<span class="type">NSError</span> ?) &#123;</div><div class="line">	<span class="keyword">if</span> success &#123;</div><div class="line">		<span class="keyword">return</span> (<span class="literal">true</span>,<span class="literal">nil</span>)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> (<span class="literal">false</span>,<span class="type">NSError</span>(domain:<span class="string">"someErrorDomain"</span>,code:<span class="number">1</span>,userInfo:<span class="literal">nil</span>))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####知识点4<br>– <em><strong>@autoclosure 和 ??</strong></em><br><code>@autoclosure</code> 可以说是Apple的一个非常神奇的创造，因为这更多地像是在 ‘hack’这门语言。简单得说，@autoclosure做的事情就是把一句表达式自动地封装成一个闭包closure。这样有时候在语法上看起来就会非常漂亮。<br>比如我们有一个方法接受一个闭包，当闭包执行的结果为true的时候打印：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">logIfTrue</span><span class="params">(predicate:<span class="params">()</span></span></span> -&gt;<span class="type">Bool</span>) &#123;</div><div class="line"><span class="keyword">if</span> predicate() &#123;</div><div class="line">	<span class="built_in">println</span>(<span class="string">"True"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在调用的时候我们需要写这样的代码<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logIfTrue(&#123;<span class="keyword">return</span> <span class="number">2</span>&gt;<span class="number">1</span>&#125;)</div></pre></td></tr></table></figure></p>
<p>还可以更近一步，因为这个闭包是最后一个参数，所以可以使用尾随闭包(trailing closure)的方式把大括号拿出来，然后省略括号，变成<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logIfTrue(<span class="number">2</span>&gt;<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>但是不管使用哪种方式，要么是书写起来十分麻烦，要么是表达上不太清晰，看起来都让人生气。于是@autoclosure登场了。我们可以改换方法参数，在参数名前面加上@autoclosure关键字：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">logIfTrue</span><span class="params">(@autoclosure predicate:<span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>) &#123;</div><div class="line">	<span class="keyword">if</span> predicate() &#123;</div><div class="line">		<span class="built_in">println</span>(<span class="string">"true"</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时候我们可以直接写<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logIfTrue(<span class="number">2</span>&gt;<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>来进行调用了，swift将会把 2&gt;1这个表达式自动转换为 ()-&gt; Bool. 这样我们就得到了一个写法简单，表意清楚的式子。  </p>
<p>在swift中，有一个非常有用的操作符，可以用来快速地对nil进行条件判断，那就是 <em><strong>??</strong></em>。这个操作符可以判断输入并在当左侧的值是非nil的optional值时返回其value，当左侧是nil时返回右侧的值，比如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> level:<span class="type">Int</span>?</div><div class="line"><span class="keyword">var</span> startLevel = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> currentLevel = level ?? startLevel</div></pre></td></tr></table></figure></p>
<p>在这个例子中我们没有设置过level，因此最后startLevel被赋值给了currentLevel。如果我们充满好奇心地点进 ??的定义，可以看到 ?? 有两种版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> ??&lt;T&gt;<span class="params">(<span class="keyword">optional</span>:T?,@autoclosure defaultValue:<span class="params">()</span></span></span>-&gt;<span class="type">T</span>?) -&gt;<span class="type">T</span>?</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> ??&lt;T&gt;<span class="params">(<span class="keyword">optional</span>:T?,@autoclosure defaultValue:<span class="params">()</span></span></span>-&gt;<span class="type">T</span>) -&gt;<span class="type">T</span></div></pre></td></tr></table></figure>
<p>在这里我们的输入满足的是后者，虽然表面上看startLevel只是一个Int,但是其实在使用时他被自动封装成一个()-&gt;Int,有了这个提示，我们不妨来猜测一下??的实现吧:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> ??&lt;T&gt;<span class="params">(<span class="keyword">optional</span>:T?,@autoclosure defaultValue:<span class="params">()</span></span></span>-&gt;<span class="type">T</span>?)-&gt;<span class="type">T</span> &#123;</div><div class="line">	<span class="keyword">switch</span> <span class="keyword">optional</span> &#123;</div><div class="line">		<span class="keyword">case</span> .<span class="type">Some</span>(<span class="keyword">let</span> value):</div><div class="line">			<span class="keyword">return</span> value</div><div class="line">		<span class="keyword">case</span> .<span class="type">None</span>:</div><div class="line">			<span class="keyword">return</span> defaultValue() </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可能你会有疑问，为什么这里要使用autoclosure，直接接受T作为参数并返回不行么？这正是autoclosure的一个最值得称赞的地方。如果我们直接使用T，那么就意味着在??操作符真正取值之前，我们就必须准备好一个默认值，这个默认值的准备和计算是会消耗性能的。但是如果optional不是nil的话，我们是完全不需要这个默认值，而会直接返回optional解包后的值。这样一来，默认值就是白白准备了，这样的开销是完全可以避免的，方法是将默认值的计算推迟到optional判定为nil之后。  </p>
<p>就这样，我们可以巧妙地绕过条件判断和强制转换，以很优雅的写法处理对optional及默认的取值了。<strong>还有</strong> @autoclosure并不支持带有输入参数的写法，也就是只有形如()-&gt;T的参数才能使用这个特性进行简化。另外因为调用者往往很容易忽视@autoclosure这个特性,所以在写接受@autoclosure的方法时还请特别小心，如果在容易产生歧义或者误解的时候，还是使用完整地闭包写法会比较好   </p>
<p>####知识点5<br>– <em><strong>Optional Chaining</strong></em><br>使用Optional Chaining 可以让我们摆脱很多不必要的判断和取值，但是在使用的时候需要小心陷阱。  </p>
<p>因为Optional Chaining是随时都可能提前返回nil的，所以使用Optional Chaining所得到的东西其实都是optional的。比如下面一段代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toy</span> </span>&#123;</div><div class="line">	<span class="keyword">let</span> name :<span class="type">String</span></div><div class="line">	<span class="keyword">init</span>(name:<span class="type">String</span>) &#123;</div><div class="line">		<span class="keyword">self</span>.name = name</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</div><div class="line">	<span class="keyword">var</span> toy:<span class="type">Toy</span>?</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</div><div class="line">	<span class="keyword">var</span> pet:<span class="type">Pet</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实际使用中，我们想要知道小明的宠物得玩具得名字得时候，可以通过下面得Optional Chaining拿到：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> toyName = xiaoming.pet?.toy?.name</div></pre></td></tr></table></figure></p>
<p>注意虽然我们最后访问的是name，并且在Toy的定义中name是被定义为一个确定的<code>String</code>而非<code>String？</code>的，但我们拿到的toyName其实还是一个String?的类型。这是由于子啊Optional Chaining中我们任意一个 ?. 的时候都可能遇到nil而提前返回，这个时候当然就只能拿到nil了。<br>在实际使用中，我们大多数情况下可能更希望使用Optional Binding来直接取值这样的代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> toyName = xiaoming.pet?.toy?.name &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可能单独拿出来看会很清楚，但是只要稍微和其他特性结合一下，事情会变得复杂起来。来看看下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Toy</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span>&#123;</div><div class="line">	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们为Toy定义了一个扩展，以及一个玩玩具的方法play()。还是拿小明举例，要是有玩具的话就玩之：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xiaoming.pet?.toy?.play()</div></pre></td></tr></table></figure>
<p>除了小明也许我们还有小红小李小张等等。。这种时候我们就需要抽象出一个闭包来使用。传入一个Child对象，如果小朋友有宠物并且宠物有玩具的话就去玩。于是你很有可能写出这样的代码：<br><em><strong>错误代码</strong></em><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> playClosure = &#123;(child:<span class="type">Child</span>) -&gt; () <span class="keyword">in</span> child.pet?.toy?.play()&#125;</div></pre></td></tr></table></figure></p>
<p>你会发现这么表意清晰的代码居然无法编译！！  </p>
<p>问题在于对于play()的调用上。定义的时候我们没有写play()的返回，这表示这个方法返回void(或者写作一对小括号，他们是等价的)。但是正如上面所说，经过Optional Chainging以后我们得到的是一个Optional的结果。也就是说，我们最后得到的应该是这样一个closure：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> playClosure = &#123;(child:<span class="type">Child</span>) -&gt;()? <span class="keyword">in</span> </div><div class="line">child.pet?.toy?.play()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样调用的返回将是一个()?  (或者写成void？更清楚一点)，虽然看起来有一点奇怪，但这就是事实。使用的时候我们可以通过Optional Binding来判定方法是否调用成功：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> result:() = playClosure(xiaoming) &#123;</div><div class="line">	</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>####知识点6<br>– <em><strong>操作符</strong></em>  </p>
<p>与Objective-C不同，swift支持重载操作符这样的特性，最常见的使用方式可能就是定义一些简便的计算了。比如我们需要一个表示二维向量的数据结构：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2D</span> </span>&#123;</div><div class="line">	<span class="keyword">var</span> x = <span class="number">0.0</span> </div><div class="line">	<span class="keyword">var</span> y = <span class="number">0.0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个很简单的需求就是两个Vector2相加：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> v1 = <span class="type">Vector2D</span>(x:<span class="number">2.0</span>,y:<span class="number">3.0</span>)</div><div class="line"><span class="keyword">let</span> v2 = <span class="type">Vector2D</span>(x:<span class="number">1.0</span>,y:<span class="number">4.0</span>)</div><div class="line"><span class="keyword">let</span> v3 = <span class="type">Vector2D</span>(x:v1.x +v2.x,y:v1.y+v2.x)</div></pre></td></tr></table></figure>
<p>如果只做一次的话似乎还好，但是一般情况我们会进行很多这种操作。这样的话，我们可能更愿意定义一个Vector2D相加的操作，来让代码简化清晰。</p>
<p>对于两个向量相加，我们可以重载加号操作符：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> +<span class="params">(<span class="keyword">left</span>:Vector2D,<span class="keyword">right</span>:Vector2D)</span></span> -&gt;<span class="type">Vector2D</span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="type">Vector2D</span>(x:<span class="keyword">left</span>.x+<span class="keyword">right</span>.x,y:<span class="keyword">left</span>.y+<span class="keyword">right</span>.y)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，上面得V3以及之后的所有表示两个向量相加的操作就全部可以用加号来表达了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> v4 = v1+ v2</div></pre></td></tr></table></figure>
<p>类似的我们还可以为Vector2D定义其他运算符。  </p>
<p>上面定义的加号减号都是已经存在于swift运算符中了，我们所做的知识变换他的参数进行重载。如果我们想要定义一个全新的运算符的话，要做的事情会多一件。比如点积运算就是一个在适量运算中很常用的运算符，它表示两个向量对应坐标的成绩的和。根据定义，以及参考重载运算符的方法，我们选取+*来表示这个运算得话，我们不难写出：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> +*<span class="params">(<span class="keyword">left</span>:Vector2D,<span class="keyword">right</span>:Vector2D)</span></span> -&gt;<span class="type">Double</span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">left</span>.x*<span class="keyword">right</span>.x +<span class="keyword">left</span>.y * <span class="keyword">right</span>.y</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是编译器会给我们一个错误：<br><strong>Operator implementation without matching operator declaration</strong><br>这是因为我们没有对这个操作符进行声明。如果我们要新加操作符的话，需要先对其进行声明，告诉编译器这个符号其实是一个操作符。添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> +* &#123;</div><div class="line">	<span class="keyword">associativity</span> <span class="keyword">none</span></div><div class="line">	<span class="keyword">precedence</span> <span class="number">160</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>infix<br>  表示要定义得是一个中位操作符，即前后都是输入；其他得修饰符还包括 <code>prefix</code>和<code>postfix</code>，不再赘述  </p>
<p>associativity<br>  定义了结合律，即如果多个同类操作符顺序出现的计算顺序。比如常见的加法减法都是left，就是说多个加法同时出现时按照从左往右的顺序计算（因为加法满足交换律，所以这个顺序无所谓，但是减法的话计算顺序就很重要了）。点乘的结果是一个Double,不再会和其他点乘结合使用，所以这里写成none  </p>
<p>precedence<br>运算的优先级，越高的话越优先进行进行运算。Swift中乘法和除法的优先级是150，加法和减法是140，这里我们定义点积优先级160，就是说应该早于普通的乘除进行运算。有了这些之后，我们就可以很简单的进行向量得点积运算了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result = v1 +* v2</div></pre></td></tr></table></figure>
<p>最后需要多提一点的是，Swift操作符是不能定义在局部域中的，因为至少会希望在能在全局范围使用你的操作符，否则操作符也失去了意义了。另外，来自不同module的操作符室友可能冲突的。这对于库开发者来说是需要特别注意的地方。如果库中的操作符冲突的话，使用者是无法像解决类型名冲突那样通过指定库名字来进行调用的。因此在重载或者在自定义操作符时，应当尽量将其作为其他某个方法的简便写法，而避免在其中实现大量逻辑或者提供独一无二的功能。这样即使出现了冲突，使用者也还可以用方法调用的方式调用你的库。运算符的命名也应当尽量明了，避免歧义和可能的误解。因为一个不被公认的操作符是存在冲突风险和理解难度的，所以我们不应该滥用这个特性。在使用重载或者自定义操作符时，请一定要再三思考权衡。</p>
<p>####知识点7<br>– <em><strong>func的参数修饰</strong></em><br>在声明一个Swift的方法的时候，我们一般不去指定参数前面的修饰符，而是直接声明参数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(variable:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">	<span class="keyword">return</span> variable + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法接受一个Int的输入，然后通过将这个输入加1，返回一个新的笔输入大1的Int，就是一个简单的+1器。  </p>
<p>很多同学在大学的C程序设计里可能学过像 ++ 这样的自增运算符，再加上做了不少关于 判断一个数被各种前置++ 和后置++折磨后的输出是什么的考试题，所以之后写代码是也会不自觉地喜欢带上这种风格，于是同样的功能可能会写出类似这样的方法。  </p>
<p><strong>这是错误代码</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(variable:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">	<span class="keyword">return</span> ++variable</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>残念。。编译错误。为什么在swift里这样都不行呢？答案是因为Swift其实是一门讨厌变化的语言。所有有可能的地方，都被默认为是不可变的，也就是用let声明的，这样不仅可以确保安全，也能在编译器的性能优化上更有作为。在方法的参数上也是如此，我们不写修饰符的画，默认情况下所有参数都是let的，上面的代码等效为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(<span class="keyword">let</span> variable:Int)</span></span> -&gt;<span class="type">Int</span> &#123;</div><div class="line">	<span class="keyword">return</span> ++variable</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>let的参数，不能重新赋值这是理所当然的。要让这个方法正确编译，我们需要做的改动是将let改为var：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(<span class="keyword">var</span> variable:Int)</span></span> -&gt;<span class="type">Int</span> &#123;</div><div class="line">	<span class="keyword">return</span> ++variable </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如上面的例子，我们将参数写作var后，通过调用返回的值是正确的，而luckyNumber还是保持了原来的值。这说明var只是在方法内部作用，而不直接影响输入的值。有写时候我们会希望在方法内部直接修改输入的值，这时候我们可以使用<code>inout</code> 来对参数进行修饰</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(<span class="keyword">inout</span> variable:Int)</span></span>  &#123;</div><div class="line">	 ++variable</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，要注意的时参数得修饰是具有传递限制的，就是说对于跨越层级的调用，我们需要保证统一参数的修饰是统一的。举个例子，比如我们想扩展一下上面的方法，实现一个可以累加任意数字的 +N器 的话，可以写成这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementor</span><span class="params">(addNumber:Int)</span></span> -&gt;((<span class="keyword">inout</span> <span class="type">Int</span>) -&gt;()) &#123;</div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(<span class="keyword">inout</span> variable:Int)</span></span> -&gt; () &#123;</div><div class="line">		variable += addNumber</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> incrementor</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>外层的makeIncrementor的返回里也需要才参数的类型前面明确指出修饰词，已符合内部的定义，否则将无法编译通过。 </p>
<p>####知识点8<br>– <em><strong>方法参数名称省略</strong></em>  </p>
<ul>
<li style="list-style: none"><input type="checkbox"> <strong>TODO</strong> </li>
</ul>
</div></article><div class="pagination"><a href="/2015/12/27/online_ defect/" class="pagination-prev">PREV</a><a href="/2015/10/10/oc语法新特性总结/" class="pagination-next">NEXT</a></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARC/">ARC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/App-Extensions/">App Extensions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AppGroups/">AppGroups</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/24/一首小诗/">1024,一首小诗</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/终有一天/">终有一天.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/樱花樱花想见你/">樱花樱花想见你</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/工具本/">小tips汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/CI搭建和脚本自动化/">CI搭建和脚本自动化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/01/又要春节了啊/">又要春节了啊</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/写给PM的iOS消息推送/">写给PM的iOS消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/19/gitlab和sourcetree的使用/">gitlab和sourcetree的使用</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2017 <a href="/">sopig</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-80781234-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?ee75cf111111aa99f8540efa2570970";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>