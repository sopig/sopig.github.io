<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiao</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-10-24T14:28:32.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sopig</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1024,一首小诗</title>
    <link href="http://yoursite.com/2016/10/24/%E4%B8%80%E9%A6%96%E5%B0%8F%E8%AF%97/"/>
    <id>http://yoursite.com/2016/10/24/一首小诗/</id>
    <published>2016-10-24T14:21:27.000Z</published>
    <updated>2016-10-24T14:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>当我打下  1024  他们都  想我  要邀请码  只有你  记得  我们青梅煮码的  年少时光  ---猪八戒，像少年啦飞驰。[2016-10-24]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;当我打下  
1024  
他们都  
想我  
要邀请码  

只有你  
记得  
我们青梅煮码的  
年少时光  

---猪八戒，像少年啦飞驰。[2016-10-24]
&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>终有一天.md</title>
    <link href="http://yoursite.com/2016/06/29/%E7%BB%88%E6%9C%89%E4%B8%80%E5%A4%A9/"/>
    <id>http://yoursite.com/2016/06/29/终有一天/</id>
    <published>2016-06-29T06:21:36.000Z</published>
    <updated>2016-06-29T06:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>终有一天我手中的编译器将成为我灵魂的一部分，这世界在我眼中将被代码重构，我将看到山川无尽银河无垠都汇成二进制的数字河流，过往英雄都在我脑海前一一浮现，而我听到无数程序员跪倒在我面前呼喊。  </p><p>他们叫我 - 代码之神。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;终有一天我手中的编译器将成为我灵魂的一部分，这世界在我眼中将被代码重构，我将看到山川无尽银河无垠都汇成二进制的数字河流，过往英雄都在我脑海前一一浮现，而我听到无数程序员跪倒在我面前呼喊。  &lt;/p&gt;
&lt;p&gt;他们叫我 - 代码之神。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>樱花樱花想见你</title>
    <link href="http://yoursite.com/2016/05/14/%E6%A8%B1%E8%8A%B1%E6%A8%B1%E8%8A%B1%E6%83%B3%E8%A7%81%E4%BD%A0/"/>
    <id>http://yoursite.com/2016/05/14/樱花樱花想见你/</id>
    <published>2016-05-14T12:56:29.000Z</published>
    <updated>2016-05-16T13:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>看不懂五线谱的人，现在想学电子钢琴，不知道会不会太晚。<br>先开始学五线谱了，就弹这么一首曲子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看不懂五线谱的人，现在想学电子钢琴，不知道会不会太晚。&lt;br&gt;先开始学五线谱了，就弹这么一首曲子。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="电子钢琴" scheme="http://yoursite.com/tags/%E7%94%B5%E5%AD%90%E9%92%A2%E7%90%B4/"/>
    
  </entry>
  
  <entry>
    <title>小tips汇总</title>
    <link href="http://yoursite.com/2016/03/06/%E5%B7%A5%E5%85%B7%E6%9C%AC/"/>
    <id>http://yoursite.com/2016/03/06/工具本/</id>
    <published>2016-03-05T16:00:20.000Z</published>
    <updated>2016-05-16T13:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="subl环境变量路径"><a href="#subl环境变量路径" class="headerlink" title="subl环境变量路径 :"></a><strong><code>subl</code></strong>环境变量路径 :</h2><p><code>/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/</code></p><h2 id="Xcode插件UDID问题修复脚本"><a href="#Xcode插件UDID问题修复脚本" class="headerlink" title="Xcode插件UDID问题修复脚本:"></a>Xcode插件UDID问题修复脚本:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/Xcode.app/Contents/Info.plist DVTPlugInCompatibilityUUID`</div><div class="line">```  </div><div class="line">## 免费高效NS服务</div><div class="line">    建议使用 dnspod</div><div class="line"></div><div class="line">## Objc Block使用技巧</div></pre></td></tr></table></figure><p>@interface SomeClass()<br>@property (nonatomic, strong, readonly) SomeClass * (^Line)(void);<br>@end</p><p>@implementation SomeClass</p><p>@dynamic Line;</p><p>#pragma mark - </p><p>#pragma mark getter/setter</p><ul><li>(SomeClass <em>(^)(void))Line {<br>  SomeClass </em>(^block)(void) = ^ SomeClass *(void){<pre><code>[self someMethod];return self;</code></pre>  };<br>}<br>@end</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">## 删除远端branch  </div><div class="line"></div><div class="line">```shell</div><div class="line">git branch -r -d origin/branch-name</div><div class="line">git push origin :branch-name</div></pre></td></tr></table></figure><h2 id="gitlab-jenkins-pgyer-ftp-CI搭建"><a href="#gitlab-jenkins-pgyer-ftp-CI搭建" class="headerlink" title="gitlab+jenkins+pgyer+ftp CI搭建"></a>gitlab+jenkins+pgyer+ftp CI搭建</h2><p><a href="http://www.jianshu.com/p/c69deb29720d" target="_blank" rel="external">http://www.jianshu.com/p/c69deb29720d</a>;</p><h2 id="制作U盘"><a href="#制作U盘" class="headerlink" title="制作U盘"></a>制作U盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /Applications/Install\ OS\ X\ El\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/install/ --applicationpath /Applications/Install\ OS\ X\ El\ Capitan.app/ --nointeraction</div></pre></td></tr></table></figure><h2 id="显示和隐藏"><a href="#显示和隐藏" class="headerlink" title="显示和隐藏"></a>显示和隐藏</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">显示：defaults write com.apple.finder AppleShowAllFiles -bool true</div><div class="line">隐藏：defaults write com.apple.finder AppleShowAllFiles -bool false</div></pre></td></tr></table></figure><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chown -R $(whoami):admin /usr/local</div></pre></td></tr></table></figure><h2 id="jenkins-runner"><a href="#jenkins-runner" class="headerlink" title="jenkins-runner"></a>jenkins-runner</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jenkins-runner</div><div class="line"></div><div class="line">/usr/local/bin/jenkins-runner</div></pre></td></tr></table></figure><h2 id="wc-l"><a href="#wc-l" class="headerlink" title="wc -l"></a>wc -l</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">find . -name *.c |xargs wc -l </div><div class="line">find . -name *.cpp | xargs wc -l </div><div class="line">find . -name *.h |xargs wc -l</div></pre></td></tr></table></figure><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh -p 9830 jx_java_web@192.168.5.112</div><div class="line">scp -P 9830 ./Downloads/atlassian-jira-6.3.6.tar.gz  jx_java_web@192.168.5.112:/data/web/</div></pre></td></tr></table></figure><h2 id="gitlab升级"><a href="#gitlab升级" class="headerlink" title="gitlab升级"></a>gitlab升级</h2><p><a href="http://segmentfault.com/a/1190000002439923" target="_blank" rel="external">http://segmentfault.com/a/1190000002439923</a><br><a href="http://jingyan.baidu.com/article/72ee561ab1b333e16038df63.html" target="_blank" rel="external">http://jingyan.baidu.com/article/72ee561ab1b333e16038df63.html</a><br><a href="http://segmentfault.com/a/1190000002722631" target="_blank" rel="external">http://segmentfault.com/a/1190000002722631</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;subl环境变量路径&quot;&gt;&lt;a href=&quot;#subl环境变量路径&quot; class=&quot;headerlink&quot; title=&quot;subl环境变量路径 :&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;code&gt;subl&lt;/code&gt;&lt;/strong&gt;环境变量路径 :&lt;/h2&gt;&lt;p&gt;&lt;cod
      
    
    </summary>
    
    
      <category term="小tips  上海" scheme="http://yoursite.com/tags/%E5%B0%8Ftips-%E4%B8%8A%E6%B5%B7/"/>
    
  </entry>
  
  <entry>
    <title>CI搭建和脚本自动化</title>
    <link href="http://yoursite.com/2016/03/02/CI%E6%90%AD%E5%BB%BA%E5%92%8C%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>http://yoursite.com/2016/03/02/CI搭建和脚本自动化/</id>
    <published>2016-03-02T09:39:11.000Z</published>
    <updated>2016-05-16T13:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install jenkins</div></pre></td></tr></table></figure><h2 id="lanuch"><a href="#lanuch" class="headerlink" title="lanuch"></a>lanuch</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jenkins</div></pre></td></tr></table></figure><h2 id="widget"><a href="#widget" class="headerlink" title="widget"></a>widget</h2><p>系统管理-&gt;管理插件，在<code>可选插件</code>中搜索安装以下插件</p><ul><li><p>git</p></li><li><p>GitLab Plugin 、Gitlab Hook Plugin</p></li><li><p>Credentials Plugin 、Keychains and Provisioning Profiles Management  这个可以不装，只用写好配置文件即可</p></li><li><p>Post-Build Script Plug-in  </p></li></ul><h2 id="shell-scrpit"><a href="#shell-scrpit" class="headerlink" title="shell scrpit"></a>shell scrpit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fir build_ipa -B &apos;develop&apos; -C Release &apos;./&apos; -w -S &apos;jiuxian&apos; -n jiuxian_appstore</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xcodebuild  clean -configuration inHouse</div><div class="line">xcodebuild -workspace &quot;jiuxian.xcworkspace&quot; -scheme jiuxian -configuration inHouse -archivePath build/jiuxian.xcarchive archive</div><div class="line">xcodebuild  -exportArchive -exportFormat IPA -archivePath build/jiuxian.xcarchive -exportPath build/jiuxian.</div></pre></td></tr></table></figure><h2 id="automation"><a href="#automation" class="headerlink" title="automation"></a>automation</h2><ul><li>fastlane</li><li>shell</li><li>nodejs</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;install&quot;&gt;&lt;a href=&quot;#install&quot; class=&quot;headerlink&quot; title=&quot;install&quot;&gt;&lt;/a&gt;install&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>又要春节了啊</title>
    <link href="http://yoursite.com/2016/02/01/%E5%8F%88%E8%A6%81%E6%98%A5%E8%8A%82%E4%BA%86%E5%95%8A/"/>
    <id>http://yoursite.com/2016/02/01/又要春节了啊/</id>
    <published>2016-02-01T05:56:29.000Z</published>
    <updated>2016-05-16T06:27:56.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>写给PM的iOS消息推送</title>
    <link href="http://yoursite.com/2016/01/26/%E5%86%99%E7%BB%99PM%E7%9A%84iOS%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
    <id>http://yoursite.com/2016/01/26/写给PM的iOS消息推送/</id>
    <published>2016-01-26T01:50:19.000Z</published>
    <updated>2016-01-26T02:39:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文摘自iOS开发者博客，请PM阅读</p><p><strong>基本功</strong></p><p>iOS在诞生之初为了最大程度的保证用户体验，做了一些高瞻远瞩且影响深远的设计。APNs（Apple Push Notification service）就是其中一项。</p><p>早期iOS设备的内存和CPU资源都很有限，为了让前台活跃的app拥有尽可能多的系统资源，以及节约设备电量，iOS一开始就“不允许”普通app的进程常驻后台。这个决定很大程度上保障了用户体验和延长了手机的待机时间，但app的开发商需要和他们的用户保持联系。开发商需要有一个稳定的网络通道能每隔一段时间推送新的内容到用户设备。Apple决定自己来搭建维护这个通道，也就是我们今天所说的APNs。记得刚开始接触iOS开发的时候，看到有不少开发者吐槽push机制，觉得不可控且增加了开发成本。其实稍微思考下Apple今天的平台规模和消息量，以及所带来的成本消耗，就能明白Apple设计这个机制所需要的智慧和魄力。一切都是为了用户。 </p><p>APNs虽然允许开发商推送消息到用户设备，但考虑到消息的量级和成本，这个由Apple维护的长链接通道就不可能是无限制使用的。APNs有着诸多的限制： </p><p><strong>可靠性</strong>。一般情况下，Apple会保证这个通道的Qaulity of Service，也就是推送的消息能及时稳定到达设备。不过一旦用户的设备处于offline状态，Apple只会存储发送给用户的最新一条push，之前发送的push会被直接丢掉。而且这最后一条离线push也是有过期时间的。一些用户应该有过这种经历，在使用微信的时候，明明对方发送了多条消息，却只收到了一条push。 </p><p><strong>Payload Size</strong>。每一条push消息的包体大小是有最大限制的。Apple在文档里清楚的说明，push只应该用来通知用户有新的内容，而不应该用来承载内容本身。理论上payload size越小，push到达设备的概率就越高。在iOS8之前max payload size是256字节，到iOS8发布这个最大值被调整到了2048字节，再到最近的iOS9发布，引入了HTTP2.0，payload size又被设为4KB了。老版本的256字节实在有点捉襟见肘，连塞一个链接进去都要考虑再三。到2KB的时候就宽裕多了，已经有不少开发商开始尝试往里面放少量的业务数据了，如果能减少打开app之后的一次网络请求何乐而不为呢。当然4KB的想象空间会更大。Apple一直在调整这个数值，为的是给开发商更多的空间去提升用户体验。push慢慢变的不仅仅是一条“alert”那么简单了。 </p><p><strong>成功率并不高</strong>。Apple虽然保证了push通道一定程度的可靠性，但push由于各种各样的原因并不能保证较高水平的到达率。push需要向用户申请权限，即使当时赋予了权限，后面也可能由于push过于频繁被用户又关掉。在夜间模式下push虽然能到达通知栏，可用户没有任何感知，更不用说点击push启动app了。还有server端token失效，这点可以通过feedback service来清理失效的token。Apple的APNs server据说每天会发送超过百亿条push，在某个时间段出现峰值的时候，开发商server和Apple server连接的成功率也会降低。还有客户端设备所处网络环境并不稳定等等因素，使得通过push成功启动app的成功率并不怎么高。 </p><p>理解了上面这些限制，就能按照Apple的规范向用户推送内容了。但push里面的门道远不止这么简单，Apple也从没有停止过对APNs体验的优化，类似payload size调整，interactive notification等等，每一个新的feature增加，哪怕是细微的改动，都能被聪明的开发者加以利用，以四两拨千斤提升产品的体验。下面就介绍一些笔者所了解到的“隐蔽门道”。</p><p><strong>不仅仅是Local Push</strong><br>很多个人开发者不具备搭建server的条件，一般会设置一个定时的local push来提醒用户唤醒自己的app。Local push看起来似乎是个廉价的折中方案，事实上它可以更强大。APNs（一般也叫做remote push）因为有上面的各种限制，并不能很好的契合业务需要。而Local Push则不同，拥有完整的app业务上下文，还可以对push进行定制化。如果可以用Local Push替代Remote Push对体验的提升是不言而喻的。Loca push的限制在于app必须处于运行状态才能发起，很多聪明的开发商会开启background task，在用户按了home键之后再争取到几分钟的运行时间，在这期间所有的remote push都被替换成了local push。不要小看了这几分钟的时间，对于很多活跃度高的app来说，按home键之后马上又产生新的用户内容的概率并不小。微信，WhatsApp都采用了这种机制来提升体验。</p><p><strong>叫醒你的App</strong><br>开启background task之后虽然能够再多运行一会，但时间一到，app还是会被挂起或者kill。大部分多时候你的app是处于非活跃状态。很多app都需要预先获取内容，或者后台下载文件等来减少用户的等待时间。iOS7引入的Silent Notification和Background Fetch机制可以一定程度上满足这种需要。silent push实现比较简单，开启相关后台权限之后发送如下特定格式的json就能启用。</p><p>唤醒app之后能处理的业务就多了，这对不少app来说是个非常实用的拓展，预加载内容也好，生成local push也好，都能提升体验。但这种唤醒机制并不总是可靠，有时候会“叫不醒”。app如果被手动kill叫不醒，如果background fetch被用户关闭也叫不醒，但这两种情况在手机充电的时候又可以被叫醒。Apple有一套自己的“智能”策略。</p><p><strong>前台消息通道</strong><br>大部分时候APNs都被用来通知用户某个处于background的app有新内容。但其实说白了APNs不过就是一条基于长链接的数据通道，在app处于foreground的时候也是能收到push消息的，不过不会有任何UI展示提醒而已。处理回调的位置也是在 也就是说APNs其实还是个免费的前台消息通道。而且有时候走APNs通道会比自己的server通道更快，如果客户端做好数据去重，多一个辅助的数据通道当然能提升体验。</p><p><strong>新神通PushKit</strong><br>APNs设计的初衷是避免app常驻后台，只在用户点收到push的时候主动去启动app。前面提到的silent push可以在有限的场景下，无需用户感知启动app。但到iOS8引入PushKit framework之后，app就可以通过push随时唤醒了，不过这个新的神通暂时还只限于voip类应用。</p><p>之前在社区看到有人提问，说微信电话本可以在用户挂掉电话的时候，把呼叫中的push改成未接电话，好奇是怎么办到的。因为大家都知道remote push是无法通过server动态修改push内容的，所以答案只有一个可能，app被后台唤醒了。用户看到的push其实是local push，而local push是可以在客户端随意调整的。唤醒到方式就是利用PushKit。</p><p>当然好处不仅仅是修改push内容这么简单。WhatsApp的用户在iOS8之后应该会有明显的感觉，好像很少看到启动页面了。看起来似乎是WhatsApp开启了voip后台常驻运行模式，但这种模式会比较费电，一些用户会有顾虑。真相也并非如此，WhatsApp并没有常驻后台，只不过是开启了PushKit的push唤醒机制。每次用户有新的离线消息，普通文本或者是voip call，app都会先被后台唤醒，再从server拉取离线消息，最后生成local push。等用户点击local push启动app的时候，没有启动页面，没有connecting和loading，所有的数据已经准备就绪，就好像WhatsApp一直在后台运行一样。也就是说，WhatsApp其实已经把所有的push都换成了local push。验证方法也很简单：</p><p>手动kill WhatsApp。<br>手机进入飞行模式。<br>收一条离线消息。<br>使用tcpdump开始监听iphone网络包，关闭飞行模式。<br>这时候，app被push唤醒，能看到如下图一条WhatsApp相关的域名解析，说明app被启动了。而且能看到很多后续的服务器交互（拉取离线消息之类）。 2 微信不知道是出于什么考虑，既没有开启voip后台常驻模式，也没有利用PushKit唤醒机制。每次收到消息之后打开app，都是先看到地球，连接中，收取中，到真正看到最新消息经常需要3s以上。PushKit已经没有电量方面的额外损耗了，对voip类应用的体验提升非常之大。<br>具体怎么实现PushKit可以参照文章末尾的链接地址。</p><p><strong>总结</strong><br>关于push这条长链接通道，Apple几乎在每次的iOS新版本里都会增加一些feature。为了控制新feature带来的影响，每次改动都不多，但怎么利用这些feature就看开发者各自都功力了。对用户体验带来的改变远不止官方文档上介绍的那么简单，只有多思考，时刻关注行业最新动态，才能发掘更多的隐藏“门道”。</p><p>####参考链接<br>Apple APNs官方文档：<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html</a><br>Silent Push实现：<a href="http://hayageek.com/ios-silent-push-notifications" target="_blank" rel="external">http://hayageek.com/ios-silent-push-notifications</a><br>PushKit实现：<a href="https://zeropush.com/guide/guide-to-pushkit-and-voip" target="_blank" rel="external">https://zeropush.com/guide/guide-to-pushkit-and-voip</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文摘自iOS开发者博客，请PM阅读&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本功&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;iOS在诞生之初为了最大程度的保证用户体验，做了一些高瞻远瞩且影响深远的设计。APNs（Apple Push Notification service）就是其中一项。
      
    
    </summary>
    
    
      <category term="push" scheme="http://yoursite.com/tags/push/"/>
    
  </entry>
  
  <entry>
    <title>gitlab和sourcetree的使用</title>
    <link href="http://yoursite.com/2016/01/19/gitlab%E5%92%8Csourcetree%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/01/19/gitlab和sourcetree的使用/</id>
    <published>2016-01-18T16:34:21.000Z</published>
    <updated>2016-05-16T14:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>网上关于git资料一堆一堆的，我们就不做git相关介绍，建议初学git的同学阅读下面两个文档</p><ul><li>git初学者教程<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">博客</a>  </li><li>git官方文档<a href="https://git-scm.com/" target="_blank" rel="external">git</a>  </li><li>最广泛使用的分支管理模型<a href="http://fann.im/blog/2012/03/12/git-flow-notes/" target="_blank" rel="external">git-flow介绍</a></li></ul><p>在学习git之前，请全部忘掉你的svn，建立完整的分支思维。</p><p>本文只做安装和部分操作介绍，不做具体内容展开，学习最高效的手段永远是自己<code>练习，练习，练习</code>。</p><hr><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>常用的代码仓库托管网站有<code>github</code>和<code>gitlab</code>,下面首先从gitlab开始</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>mac下的安装，打开终端，输入下面</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install git</div><div class="line">brew install git-flow</div></pre></td></tr></table></figure><p> 如果没有brew，先安装</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure><p> mac下需安装基本开发环境</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcode-select --install</div></pre></td></tr></table></figure></li><li><p>windows下的安装</p><p> 点击下面地址下载安装。</p><blockquote><p><a href="https://github.com/git-for-windows/git/releases/download/v2.7.0.windows.1/Git-2.7.0-32-bit.exe" target="_blank" rel="external">32-bit Git for Windows Setup</a><br><a href="https://github.com/git-for-windows/git/releases/download/v2.7.0.windows.1/Git-2.7.0-64-bit.exe" target="_blank" rel="external">64-bit Git for Windows Setup</a></p></blockquote></li><li><p>git的界面操作工具<br> 客户端操作工具也是一堆一堆的，本文也不做各种客户端优缺点分析，建议大家下载完美支持gitflow的客户端sourceTree。</p><p> 下面是sourceeTree的下载官网，先注册一个账号就可以永久免费使用</p><blockquote><p><a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">sourceTree</a></p></blockquote></li></ol><p>  以上操作完成之后，先进行初步配置，如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"Your Name"</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"email@example.com"</span></span></div></pre></td></tr></table></figure></p><hr><h2 id="添加gitlab账户的ssh访问权限"><a href="#添加gitlab账户的ssh访问权限" class="headerlink" title="添加gitlab账户的ssh访问权限"></a>添加gitlab账户的ssh访问权限</h2><ol><li><p>生成一对ssh公钥私钥，如果.ssh目录下已存在，则跳过此步骤<br><img src="/images/blog/gitlab/ssh_1.png" alt=""></p></li><li><p>查看生成的公钥私钥<br><img src="/images/blog/gitlab/ssh_2.png" alt=""></p></li><li><p>复制ssh公钥，如图<br><img src="/images/blog/gitlab/ssh_3.png" alt=""><br>使用windows的同学，用这个<code>clip &lt; ~/.ssh/id_rsa.pub</code>,将ssh公钥复制</p></li></ol><p>以上步骤完成之后，打开并登陆gitlab网站，公司配置的gitlab地址是<code>192.168.5.227</code>，ssh端口是<code>9830</code>,</p><p>gitlab上添加账号的具体操作步骤如下：<br><img src="/images/blog/gitlab/1.png" alt=""><br><img src="/images/blog/gitlab/2.png" alt=""><br><img src="/images/blog/gitlab/3.png" alt=""></p><p>以上所有完成之后，可以测试连通性<br>如果出现以下消息，则代表配置成功了<br><img src="/images/blog/git_connect.png" alt=""></p><hr><h2 id="将已有工程托管到gitlab"><a href="#将已有工程托管到gitlab" class="headerlink" title="将已有工程托管到gitlab"></a>将已有工程托管到gitlab</h2><ol><li><p>进入我的工程文件夹路径，比如存放工程的文件夹名称是jiuxian_iOS<br><img src="/images/blog/gitlab/git_1.png" alt=""></p></li><li><p>初始化该工程为git仓库<br><img src="/images/blog/gitlab/git_2.png" alt=""></p></li><li><p>在gitlab创建新的项目<br><img src="/images/blog/gitlab/git_3.png" alt=""><br><img src="/images/blog/gitlab/git_4.png" alt=""><br><img src="/images/blog/gitlab/git_5.png" alt=""><br><img src="/images/blog/gitlab/git_6.png" alt=""></p></li></ol><p>4.最后将创建好的项目地址设置为jiuxian_iOS的远端仓库地址<br><img src="/images/blog/gitlab/git_7.png" alt=""><br>做一些说明，gitlab上新建的仓库地址为 <code>git@xxx.com:ddapps/jiuxian_ios.git</code><br>如果gitlab服务器端口地址是默认的22，则可以简写为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@xxx.com:ddapps/jiuxian_ios.git</div></pre></td></tr></table></figure></p><p>因为公司gitlab服务器端口地址修改为9830，需要写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin ssh://git@192.168.5.227:9830/ddapps/jiuxian_ios.git</div></pre></td></tr></table></figure></p><p>接下来是将本地项目托管到gitlab服务器上，<br><img src="/images/blog/gitlab/git_8.png" alt=""></p><p>到此，gitlab仓库配置就全部完成了。</p><hr><h2 id="将远端仓库的代码克隆到本地"><a href="#将远端仓库的代码克隆到本地" class="headerlink" title="将远端仓库的代码克隆到本地"></a>将远端仓库的代码克隆到本地</h2><ol><li><p>克隆远端仓库代码到我的电脑<br><img src="/images/blog/gitlab/git_8.png" alt=""></p></li><li><p>然后将下载的工程文件夹直接拖入到sourceTree<br><img src="/images/blog/gitlab/git_10.png" alt=""><br><img src="/images/blog/gitlab/git_11.png" alt=""><br><img src="/images/blog/gitlab/git_12.png" alt=""></p></li></ol><p>将远端仓库的代码下载到本地电脑就完成了,下面接着说代码修改和提交的流程。</p><hr><h2 id="gitflow流程"><a href="#gitflow流程" class="headerlink" title="gitflow流程"></a>gitflow流程</h2><ol><li><p>gitflow初始化<br><img src="/images/blog/gitlab/git_13.png" alt=""><br><img src="/images/blog/gitlab/git_14.png" alt=""></p></li><li><p>下面的步骤是需要我完成用户登录的功能，我首先创建新的功能分支 feature/userLogin ,我所有的改动都需要提交，提交之后需要推送到远端push。当我完成这个功能，我就可以finish这个分支。<br><img src="/images/blog/gitlab/git_15.png" alt=""><br><img src="/images/blog/gitlab/git_16.png" alt=""><br><img src="/images/blog/gitlab/git_17.png" alt=""><br><img src="/images/blog/gitlab/git_18.png" alt=""><br><img src="/images/blog/gitlab/git_19.png" alt=""><br><img src="/images/blog/gitlab/git_20.png" alt=""></p></li></ol><hr><p>Merge Request<br><img src="/images/blog/gitlab/merge_1.png" alt=""><br><img src="/images/blog/gitlab/merge_2.png" alt=""><br><img src="/images/blog/gitlab/merge_3.png" alt=""><br><img src="/images/blog/gitlab/merge_4.png" alt=""><br><img src="/images/blog/gitlab/merge_5.png" alt=""></p><hr><p>以上是整个基本的操作流程，下面介绍基本的命令行操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git add </div><div class="line">git commit </div><div class="line">git fetch </div><div class="line">git pull </div><div class="line">git merge</div><div class="line">git branch</div><div class="line">git reset</div><div class="line">git rebase</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;网上关于git资料一堆一堆的，我们就不做git相关介绍，建议初学git的同学阅读下面两个文档&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git初学者教程&lt;a
      
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>2015年总结，2016计划</title>
    <link href="http://yoursite.com/2016/01/01/2015%E5%B9%B4%E6%80%BB%E7%BB%93%EF%BC%8C2016%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2016/01/01/2015年总结，2016计划/</id>
    <published>2015-12-31T17:14:05.000Z</published>
    <updated>2016-01-27T01:17:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2015总结</strong></p><p>几个关键的事情，值得自己反思，</p><p>算了，有点累了，想睡觉了，空一点了好好总结下    todo，</p><p>最想对自己说的一句话是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">认真对待自己的未来，多一些把握！</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;2015总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几个关键的事情，值得自己反思，&lt;/p&gt;
&lt;p&gt;算了，有点累了，想睡觉了，空一点了好好总结下    todo，&lt;/p&gt;
&lt;p&gt;最想对自己说的一句话是&lt;br&gt;&lt;figure class=&quot;highlight plai
      
    
    </summary>
    
    
      <category term="年终总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>线上缺陷原因总结</title>
    <link href="http://yoursite.com/2015/12/27/online_%20defect/"/>
    <id>http://yoursite.com/2015/12/27/online_ defect/</id>
    <published>2015-12-26T17:03:20.000Z</published>
    <updated>2016-05-16T14:07:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>关于特殊情况下会重复弹出分享框的问题。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li>url重定向会造成此问题</li><li>web页面js注入会造成此问题</li></ul><h2 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//这个方法是正在开始加载网页请求链接的时候的回调方法，在这个回调做的native代码逻辑如下</div><div class="line">//1.将js执行状态设置为begin</div><div class="line"></div><div class="line">- (void)webViewDidStartLoad:(UIWebView *)webView&#123;</div><div class="line">    jsstatus = JSStatusBegin;</div><div class="line">    if (webView.isLoading) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    self.navigationItem.rightBarButtonItem = nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//这个是完成网页加载请求，网页完全显示时的回调方法，代码逻辑是</div><div class="line">//尝试调用js方法 getShareData(x,x); </div><div class="line">//如果活动页存在这个方法，将js执行状态设置为end，并且将活动页分享按钮添加到导航栏上</div><div class="line">//如果活动页不存在 getShareData(x,x)这个方法，将js执行状态设置为end，活动页不会有分享按钮</div><div class="line">//弹出分享框的代码是因为  </div><div class="line">// 1. url重定向导致两次调用这两个回调方法</div><div class="line">// 2. js远程注入也会导致js注入的时候再次调用这两个回调方法</div><div class="line"></div><div class="line"></div><div class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView&#123;</div><div class="line"></div><div class="line">    if (webView.isLoading) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (IOS7_OR_LATER) &#123;</div><div class="line">       </div><div class="line">        self.context = [_webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];</div><div class="line">        self.context[@"cart"] = self;</div><div class="line">    </div><div class="line">        if (!self.webTitle || [self.webTitle isEqualToString:kJXWebDefaultTitle]) &#123;</div><div class="line">            JSValue *value = [self.context evaluateScript:@"document.title"];</div><div class="line">            self.title = value.toString;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [self addShareData];</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    [[NSUserDefaults standardUserDefaults] setInteger:0 forKey:@"WebKitCacheModelPreferenceKey"];</div><div class="line">    [[NSUserDefaults standardUserDefaults] setBool:NO forKey:@"WebKitDiskImageCacheEnabled"];</div><div class="line">    [[NSUserDefaults standardUserDefaults] setBool:NO forKey:@"WebKitOfflineWebApplicationCacheEnabled"];</div><div class="line">    [[NSUserDefaults standardUserDefaults] synchronize];</div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><ul><li>微信群里第一时间反馈这个问题的时候，第一时间就解决了。鉴于经验和测试环境所限，代码没有考虑以下两种情况<br>1.url重定向造成的问题<br>2.远程js注入造成的问题</li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>代码已修复，问题需总结，测试环境尽可能多样性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;关于特殊情况下会重复弹出分享框的问题。&lt;/p&gt;
&lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="架构谈" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>swift的几个tips</title>
    <link href="http://yoursite.com/2015/10/19/swift%E7%9A%84%E5%87%A0%E4%B8%AAtips/"/>
    <id>http://yoursite.com/2015/10/19/swift的几个tips/</id>
    <published>2015-10-19T14:35:45.000Z</published>
    <updated>2016-01-19T14:37:13.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-   最近在完成SDWebImage的swift版本改写。</div></pre></td></tr></table></figure><p>##swift初识</p><p><em>配置相关</em></p><blockquote><p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">Markdown详细说明</a><br><a href="http://25.io/mou/" target="_blank" rel="external">Markdown编辑器Mou</a><br><a href="https://github.com/ddapps/Swift/blob/master/Markdown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93.md" target="_blank" rel="external">Markdown详细语法</a><br><a href="https://github.com/ddapps/Swift/blob/master/swift%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93.md" target="_blank" rel="external">Swift开源项目总结</a><br><a href="./swift_OC_programMix.md">swift与OC混合编程——swift-mix-oc</a><br><a href="./swift_language_tips.md">swift_language</a><br><a href="http://www.cnblogs.com/jacklandrin/p/3782831.html" target="_blank" rel="external">swift中的关键字</a><br><a href="http://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/index.html" target="_blank" rel="external">The Swift Programming Language 中文版</a><br><a href="http://www.isaced.com/post-265.html" target="_blank" rel="external">Carthage使用</a>  </p></blockquote><p><em>语言语法特性</em>  </p><blockquote><p><a href="http://www.cocoachina.com/swift/20150129/11057.html?utm_source=tuicool" target="_blank" rel="external">在Swift中应用Grand Central Dispatch(上)</a><br><a href="http://www.cocoachina.com/swift/20150130/11054.html" target="_blank" rel="external">在Swift中应用Grand Central Dispatch(下)</a><br><a href="http://www.jianshu.com/p/f875bcb7e86c?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_author_hots&amp;utm_source=recommendation" target="_blank" rel="external">Swift 十二讲 前言和第一章(draft)</a><br><a href="http://www.jianshu.com/p/b4a202d6c77b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_author_hots&amp;utm_source=recommendation" target="_blank" rel="external">Swift 十二讲 第二章 常量变量类型元组字符串和操作符</a><br><a href="http://www.jianshu.com/p/94212e7f4030?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_author_hots&amp;utm_source=recommendation" target="_blank" rel="external">Swift十二讲 第三章 数组字典函数和闭包</a><br><a href="http://www.jianshu.com/p/7d3fbecfab30" target="_blank" rel="external">Swift 十二讲 第四章 范围区间和跨步和常用全局函数 (draft)</a><br><a href="http://www.jianshu.com/p/0ba4760d55c8" target="_blank" rel="external">Swift 十二讲 第五章 Ifelse/for/while/Switch loop</a><br><a href="http://www.jianshu.com/p/31ae2fb8fc93" target="_blank" rel="external">Swift 十二讲 第六章 类 (Class) (draft)</a><br><a href="http://www.jianshu.com/p/187486247cb8" target="_blank" rel="external">Swift 十二讲 第七章 结构体和聚合体 ,访问控制</a><br><a href="http://www.jianshu.com/p/247be9669a24" target="_blank" rel="external">Swift 十二讲 第八章 类型扩展(Extensions)和协议 (draft)</a><br><a href="http://www.jianshu.com/p/e3dc516fd465" target="_blank" rel="external">Swift 十二讲 第九讲 操作符重载和泛型</a><br><a href="http://www.jianshu.com/p/2b066dd939ed" target="_blank" rel="external">Swift 十二讲 第十讲 选项(Optionals)和内存管理ARC (draft)</a>  </p></blockquote><p>##swift必备知识点</p><p>####知识点1<br>— <em><strong>函数柯里化</strong></em><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 柯里化函数定义格式  </span></div><div class="line"><span class="function"><span class="keyword">func</span> &lt;#function name#&gt;<span class="params">(&lt;#parameters#&gt;)</span></span>(&lt;#parameters#&gt;)-&gt; &lt;#<span class="keyword">return</span> type#&gt;&#123;</div><div class="line">    &lt;#statements#&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">_info1-<span class="number">1_</span>  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Curry</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">// uncurried</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a: Int, b: Int, <span class="built_in">c</span>: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"\(a) + \(b) + \(c)"</span>)</div><div class="line">        <span class="keyword">return</span> a + b + <span class="built_in">c</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 手动实现柯里化函数</span></div><div class="line">    <span class="comment">// 把上面的函数转换为柯里化函数，首先转成接收第一个参数a，并且返回接收余下第一个参数b的新函数（采用闭包）</span></div><div class="line">    <span class="comment">// 基础不牢固可能看不懂,需要拆解来看</span></div><div class="line">    <span class="comment">// (a: Int) : 参数</span></div><div class="line">    <span class="comment">// (b:Int) -&gt; (c: Int) -&gt; Int : 函数返回值（一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数)</span></div><div class="line">    </div><div class="line">    <span class="comment">// 定义一个接收参数a,并且返回一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a: Int)</span></span> -&gt; (b:<span class="type">Int</span>) -&gt; (<span class="built_in">c</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 返回一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">        <span class="keyword">return</span> &#123; (b:<span class="type">Int</span>) -&gt; (<span class="built_in">c</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></div><div class="line">            </div><div class="line">            <span class="comment">// 返回一个接收余下第一个参数c，并且有返回结果为Int类型的函数</span></div><div class="line">            <span class="keyword">return</span> &#123; (<span class="built_in">c</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></div><div class="line">                </div><div class="line">                <span class="comment">// 这里为什么能使用参数a,b,c。</span></div><div class="line">                <span class="comment">// 利用闭包的值捕获特性，即使这些值作用域不在了，也可以捕获到他们的值。</span></div><div class="line">                <span class="comment">// 闭包会自动判断捕获的值是值拷贝还是值引用，如果修改了，就是值引用，否则值拷贝。</span></div><div class="line">                </div><div class="line">                <span class="comment">// 注意只有在闭包中才可以，a,b,c都在闭包中。</span></div><div class="line">                <span class="keyword">return</span> a + b + <span class="built_in">c</span>;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// curried</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addCur</span><span class="params">(a: Int)</span></span>(b: <span class="type">Int</span>)(<span class="built_in">c</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"\(a) + \(b) + \(c)"</span>)</div><div class="line">        <span class="keyword">return</span> a + b + <span class="built_in">c</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><em>info1-2</em>  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建柯里化类的实例</span></div><div class="line">      <span class="keyword">var</span> curryInstance = <span class="type">Curry</span>()</div><div class="line">      </div><div class="line">      <span class="comment">/*** 调用手动实现的柯里化函数 **/</span></div><div class="line">      <span class="keyword">var</span> r: <span class="type">Int</span> = curryInstance.add(<span class="number">10</span>)(b: <span class="number">20</span>)(<span class="built_in">c</span>: <span class="number">30</span>)</div><div class="line">      <span class="comment">// 可能很多人都是第一次看这样的调用，感觉有点不可思议。</span></div><div class="line">      <span class="comment">// 让我们回顾下OC创建对象 [[Person alloc] init]，这种写法应该都见过吧，就是一下发送了两个消息，alloc返回一个实例，再用实例调用init初始化,上面也是一样，一下调用多个函数，每次调用都会返回一个函数，然后再次调用这个返回的函数。</span></div><div class="line">      </div><div class="line">      <span class="comment">/***** 柯里化函数分解调用 *****/</span></div><div class="line">      <span class="comment">// 让我来帮你们拆解下，更容易看懂</span></div><div class="line">      <span class="comment">// curryInstance.add(10): 调用一个接收参数a,并且返回一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      <span class="comment">// functionB: 一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      <span class="keyword">var</span> functionB = curryInstance.add(<span class="number">10</span>)</div><div class="line">      </div><div class="line">      <span class="comment">// functionB(b: 20):调用一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      <span class="comment">// functionC: 一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      <span class="keyword">var</span> functionC = functionB(b: <span class="number">20</span>)</div><div class="line">      </div><div class="line">      <span class="comment">// functionC(c: 30): 调用一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      <span class="comment">// result: 函数的返回值</span></div><div class="line">      <span class="keyword">var</span> res: <span class="type">Int</span> = functionC(<span class="built_in">c</span>: <span class="number">30</span>);</div><div class="line">      </div><div class="line">      <span class="comment">// 这里会有疑问?，为什么不是调用curryInstance.add(a: 10)，而是curryInstance.add(10),functionB(b: 20),functionC(c: 30),怎么就有b,c,这是因为func add(a: Int) -&gt; (b:Int) -&gt; (c: Int) -&gt; Int这个方法中a是第一个参数，默认是没有外部参数名，只有余下的参数才有外部参数名,b,c都属于余下的参数。</span></div><div class="line">      </div><div class="line">      <span class="comment">/***** 系统的柯里化函数调用 *****/</span></div><div class="line">      <span class="keyword">var</span> result: <span class="type">Int</span> = curryInstance.addCur(<span class="number">10</span>)(b: <span class="number">20</span>)(<span class="built_in">c</span>: <span class="number">30</span>)</div><div class="line">      </div><div class="line">      <span class="comment">/***** 系统的柯里化函数拆解调用 *****/</span></div><div class="line">      <span class="comment">// curryInstance.addCur(10) : 调用一个接收参数a,并且返回一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      <span class="comment">// 注意：Swift是强类型语言，这里没有报错，说明调用系统柯里化函数返回的类型和手动的functionB类型一致</span></div><div class="line">      <span class="comment">// functionB: 一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      functionB = curryInstance.addCur(<span class="number">10</span>)</div><div class="line">      </div><div class="line">      <span class="comment">// functionC: 一个接收参数c,返回值为Int类型的函数</span></div><div class="line">      functionC = functionB(b: <span class="number">20</span>)</div><div class="line">      </div><div class="line">      <span class="comment">// result: 函数的返回值</span></div><div class="line">      res = functionC(<span class="built_in">c</span>: <span class="number">30</span>)</div><div class="line">      </div><div class="line">      <span class="comment">// 打印 60，60，60说明手动实现的柯里化函数，和系统的一样。</span></div><div class="line">      <span class="built_in">println</span>(<span class="string">"\(r),\(res),\(result)"</span>)</div><div class="line">      </div><div class="line">      <span class="comment">/************************************ 华丽的分割线 *********************************************/</span></div><div class="line">      <span class="comment">/*************************** 实例方法的另一种调用方式（柯里化）************************************/</span></div><div class="line">      <span class="comment">// 创建柯里化类的实例</span></div><div class="line">      <span class="keyword">var</span> curryingInstance = <span class="type">Currying</span>()</div><div class="line">      </div><div class="line">      <span class="comment">// 调用function方法</span></div><div class="line">      <span class="type">Currying</span>.function(curryingInstance)()</div><div class="line">      </div><div class="line">      <span class="comment">// 拆解调用function方法</span></div><div class="line">      <span class="comment">// 1.获取function方法</span></div><div class="line">      <span class="keyword">let</span> function = <span class="type">Currying</span>.function(curryingInstance)</div><div class="line">      <span class="comment">// 2.调用function方法</span></div><div class="line">      function()</div><div class="line">      </div><div class="line">      <span class="comment">// 步骤都是一样，首先获取实例方法，在调用实例方法，实例方法怎么调用，就不需要在教了。</span></div></pre></td></tr></table></figure><p><em>info1-3</em>  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Currying</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">// 方法类型: () -&gt; Void</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">println</span>(<span class="keyword">__FUNCTION__</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 方法类型: (Int) -&gt; Void</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">functionParam</span><span class="params">(a: Int)</span></span>&#123;</div><div class="line">        <span class="built_in">println</span>(<span class="keyword">__FUNCTION__</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 方法类型: (Int, b: Int) -&gt; Void</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">functionParam</span><span class="params">(a: Int, b: Int)</span></span>&#123;</div><div class="line">        <span class="built_in">println</span>(<span class="keyword">__FUNCTION__</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 方法类型: (Int) -&gt; () -&gt; Void</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">functionCur</span><span class="params">(a: Int)</span></span>()&#123;</div><div class="line">        <span class="built_in">println</span>(<span class="keyword">__FUNCTION__</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><em>info1-4</em>  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 组合接口  </span></div><div class="line"><span class="comment">// 为什么要定义接口，为了程序的扩展性，以后只需要在接口中添加对应的组合方法就好了。  </span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CombineUI</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(top: <span class="params">()</span></span></span> -&gt; ())(bottom: () -&gt; ())()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UI</span>: <span class="title">NSObject</span>,<span class="title">CombineUI</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(top: <span class="params">()</span></span></span> -&gt; ())(bottom: () -&gt; ())() &#123;</div><div class="line">        <span class="comment">// 搭建顶部</span></div><div class="line">        top()</div><div class="line">        </div><div class="line">        <span class="comment">// 搭建底部</span></div><div class="line">        bottom()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><em>info1-5 文字总结</em><br>  柯里化(Currying),是函数式编程概念。也就是说把接受多个参数的方法变换成接受第一个参数的方法，<br>并且返回接受余下的参数并且返回结果的新方法。 swift中我们可以这样写出多个括号的方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(a:Int)</span></span>(b:<span class="type">Int</span>) -&gt;<span class="type">Int</span> &#123;</div><div class="line"><span class="keyword">return</span> a+ b</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">  然后通过只传入第一个括号内的参数进行调用，这样将返回另一个方法：  </div><div class="line">```swift</div><div class="line"><span class="keyword">let</span> addToEndValue = addTwoNumbers(<span class="number">4</span>)   <span class="comment">//addToEndValue是一个Int-&gt;Int  </span></div><div class="line"><span class="keyword">let</span> result = addToEndValue(b:<span class="number">6</span>)  <span class="comment">//result = 10</span></div></pre></td></tr></table></figure></p><p>  柯里化是一种量产相似方法的好办法，可以通过柯里化一个方法模板来避免写出很多重复代码，也方便了今后的维护。<br>  举一个实际应用的例子，在swift中的selector只能使用字符串生成。这面临一个很严重的问题就是难以重构，并且无法在编译期间进行检查，这是十分危险的行为。但是target-action是Cocoa中非常重要得设计模式，无论如何我们都要安全使用的话，一种可能的解决方式就是利用方法的柯里化。  请看以下的解决思路<br>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">  <span class="class"><span class="keyword">protocol</span> <span class="title">TargetAction</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">performAction</span><span class="params">()</span></span></div><div class="line">  &#125; </div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TargetActionWrapper</span>&lt;<span class="title">T</span>:<span class="title">AnyObject</span>&gt;:<span class="title">TargetAction</span> </span>&#123;</div><div class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> target:<span class="type">T</span>?</div><div class="line">  <span class="keyword">let</span> action:(<span class="type">T</span>) -&gt; () -&gt; ()</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">performAction</span><span class="params">()</span></span> -&gt; () &#123;</div><div class="line">  <span class="keyword">if</span> <span class="keyword">let</span> t = target &#123;</div><div class="line">  action(t)()</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">ControlEvent</span> </span>&#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">TouchUpInside</span></div><div class="line">  <span class="keyword">case</span> <span class="type">ValueChanged</span></div><div class="line">  <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> actions = [<span class="type">ControlEvent</span>:<span class="type">TargetAction</span>]()</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">setTarget</span>&lt;T:AnyObject&gt;<span class="params">(target:T,action:<span class="params">(T)</span></span></span>-&gt;()-&gt;(),controlEvent:<span class="type">ControlEvent</span>) &#123;</div><div class="line">  actions[controlEvent] = <span class="type">TargetActionWrapper</span>(target:target,action:action)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">removeTargetForControlEvent</span><span class="params">(controlEvent:ControlEvent)</span></span> &#123;</div><div class="line">  actions[controlEvent] = <span class="literal">nil</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">performActionForControlEvent</span><span class="params">(controlEvent:ControlEvent)</span></span> &#123;</div><div class="line">  actions[controlEvent]?.performAction()</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  ```  </div><div class="line">  </div><div class="line">####知识点<span class="number">2</span>  </div><div class="line">--- <span class="number">_</span>**将<span class="class"><span class="keyword">protocol</span>的方法声明为_mutating_**_  </span></div><div class="line"><span class="class">  <span class="title">swift</span>的`<span class="title">protocol</span>`不仅可以被`<span class="title">class</span>`类型实现，也适用于`<span class="title">struct</span>`和`<span class="title">enum</span>`.因为这个原因，我们在写给别人用的接口时需要多考虑是否使用`<span class="title">mutating</span>`来修饰方法，比如定义为`<span class="title">mutating</span> <span class="title">func</span> <span class="title">myMethod</span>()`。<span class="title">Swift</span>的<span class="title">mutating</span>关键字修饰方法是为了能够在该方法中修改`<span class="title">struct</span>`或者是`<span class="title">enum</span>`的变量，所以如果没有在接口方法里来实现这个接口的话，别人如果用`<span class="title">struct</span>`或者`<span class="title">enum</span>`来实现这个`<span class="title">protocol</span>`的画，就不能在方法里改变自己的变量了。  比如下面的代码。</span></div><div class="line"><span class="class">  ```<span class="title">swift</span></span></div><div class="line"><span class="class">  <span class="title">protocol</span> <span class="title">Vehicle</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> numberOfWheels:<span class="type">Int</span> &#123;<span class="keyword">get</span>&#125;</div><div class="line">  <span class="keyword">var</span> color:<span class="type">UIColor</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</div><div class="line">  </div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Mycar</span>:<span class="title">Vehicle</span> </span>&#123;</div><div class="line">  <span class="keyword">let</span> numbersOfWheels = <span class="number">4</span></div><div class="line">  <span class="keyword">var</span> color = <span class="type">UIColor</span>.blueColor()</div><div class="line">  </div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span> &#123;</div><div class="line">  color = <span class="type">UIColor</span>.redColor()</div><div class="line">  &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p> 如果把<code>protocol</code> 定义中<code>mutating</code>关键字去掉的话，Mycar就没法编译，保持现有代码不变的话，会报错说没有实现接口。<br> 另外在使用<code>class</code>来实现带有<code>mutating</code>的方法接口时，具体的实现方法的前面是不需要加<code>mutating</code>修饰的，因为<code>class</code>可以随意更改自己的成员变量。所以说在接口里用<code>mutating</code>修饰方法，对于<code>class</code>的实现完全透明，可以当做不存在的。</p><p>####知识点3<br>–  <em><strong>多元组Turple</strong></em><br>多元组基本上都是动态语言支持的特性。<br>比如交换输入，普通程序员亘古以来可能都是这么写的<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapMe</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> a:T,<span class="keyword">inout</span> b:T)</span></span> &#123;</div><div class="line"><span class="keyword">let</span> temp = a</div><div class="line">a = b </div><div class="line">b = temp </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是要使用多元组的话，我们可以是不是用额外的交换空间就完成交换<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapMe</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> a:T,<span class="keyword">inout</span> b:T)</span></span> &#123;</div><div class="line">(a,b) = (b,a)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>另外一个特别常用的地方是错误处理。OC时代我们已经习惯了在需要错误处理的时候先做一个NSError的指针，然后将地址传到方法里面等待填充：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="type">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"><span class="type">BOOL</span> success = [<span class="type">NSFileManager</span> defaultManager] moveItemAtPath@<span class="string">"/path/to/target"</span> toPath:@<span class="string">"/path/to/detination"</span> error:&amp;error];</div><div class="line"><span class="keyword">if</span> (!success) &#123;</div><div class="line"><span class="type">NSLog</span>(@<span class="string">"%@"</span>,error);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在我们新写库的时候可以直接考虑返回一个带有NSError的多元组，而不是去填充地址了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomethingMightCauseError</span><span class="params">()</span></span> -&gt; (<span class="type">Bool</span>,<span class="type">NSError</span> ?) &#123;</div><div class="line"><span class="keyword">if</span> success &#123;</div><div class="line"><span class="keyword">return</span> (<span class="literal">true</span>,<span class="literal">nil</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> (<span class="literal">false</span>,<span class="type">NSError</span>(domain:<span class="string">"someErrorDomain"</span>,code:<span class="number">1</span>,userInfo:<span class="literal">nil</span>))</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>####知识点4<br>– <em><strong>@autoclosure 和 ??</strong></em><br><code>@autoclosure</code> 可以说是Apple的一个非常神奇的创造，因为这更多地像是在 ‘hack’这门语言。简单得说，@autoclosure做的事情就是把一句表达式自动地封装成一个闭包closure。这样有时候在语法上看起来就会非常漂亮。<br>比如我们有一个方法接受一个闭包，当闭包执行的结果为true的时候打印：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">logIfTrue</span><span class="params">(predicate:<span class="params">()</span></span></span> -&gt;<span class="type">Bool</span>) &#123;</div><div class="line"><span class="keyword">if</span> predicate() &#123;</div><div class="line"><span class="built_in">println</span>(<span class="string">"True"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在调用的时候我们需要写这样的代码<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logIfTrue(&#123;<span class="keyword">return</span> <span class="number">2</span>&gt;<span class="number">1</span>&#125;)</div></pre></td></tr></table></figure></p><p>还可以更近一步，因为这个闭包是最后一个参数，所以可以使用尾随闭包(trailing closure)的方式把大括号拿出来，然后省略括号，变成<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logIfTrue(<span class="number">2</span>&gt;<span class="number">1</span>)</div></pre></td></tr></table></figure></p><p>但是不管使用哪种方式，要么是书写起来十分麻烦，要么是表达上不太清晰，看起来都让人生气。于是@autoclosure登场了。我们可以改换方法参数，在参数名前面加上@autoclosure关键字：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">logIfTrue</span><span class="params">(@autoclosure predicate:<span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>) &#123;</div><div class="line"><span class="keyword">if</span> predicate() &#123;</div><div class="line"><span class="built_in">println</span>(<span class="string">"true"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这时候我们可以直接写<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logIfTrue(<span class="number">2</span>&gt;<span class="number">1</span>)</div></pre></td></tr></table></figure></p><p>来进行调用了，swift将会把 2&gt;1这个表达式自动转换为 ()-&gt; Bool. 这样我们就得到了一个写法简单，表意清楚的式子。  </p><p>在swift中，有一个非常有用的操作符，可以用来快速地对nil进行条件判断，那就是 <em><strong>??</strong></em>。这个操作符可以判断输入并在当左侧的值是非nil的optional值时返回其value，当左侧是nil时返回右侧的值，比如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> level:<span class="type">Int</span>?</div><div class="line"><span class="keyword">var</span> startLevel = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> currentLevel = level ?? startLevel</div></pre></td></tr></table></figure></p><p>在这个例子中我们没有设置过level，因此最后startLevel被赋值给了currentLevel。如果我们充满好奇心地点进 ??的定义，可以看到 ?? 有两种版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> ??&lt;T&gt;<span class="params">(<span class="keyword">optional</span>:T?,@autoclosure defaultValue:<span class="params">()</span></span></span>-&gt;<span class="type">T</span>?) -&gt;<span class="type">T</span>?</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> ??&lt;T&gt;<span class="params">(<span class="keyword">optional</span>:T?,@autoclosure defaultValue:<span class="params">()</span></span></span>-&gt;<span class="type">T</span>) -&gt;<span class="type">T</span></div></pre></td></tr></table></figure><p>在这里我们的输入满足的是后者，虽然表面上看startLevel只是一个Int,但是其实在使用时他被自动封装成一个()-&gt;Int,有了这个提示，我们不妨来猜测一下??的实现吧:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> ??&lt;T&gt;<span class="params">(<span class="keyword">optional</span>:T?,@autoclosure defaultValue:<span class="params">()</span></span></span>-&gt;<span class="type">T</span>?)-&gt;<span class="type">T</span> &#123;</div><div class="line"><span class="keyword">switch</span> <span class="keyword">optional</span> &#123;</div><div class="line"><span class="keyword">case</span> .<span class="type">Some</span>(<span class="keyword">let</span> value):</div><div class="line"><span class="keyword">return</span> value</div><div class="line"><span class="keyword">case</span> .<span class="type">None</span>:</div><div class="line"><span class="keyword">return</span> defaultValue() </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可能你会有疑问，为什么这里要使用autoclosure，直接接受T作为参数并返回不行么？这正是autoclosure的一个最值得称赞的地方。如果我们直接使用T，那么就意味着在??操作符真正取值之前，我们就必须准备好一个默认值，这个默认值的准备和计算是会消耗性能的。但是如果optional不是nil的话，我们是完全不需要这个默认值，而会直接返回optional解包后的值。这样一来，默认值就是白白准备了，这样的开销是完全可以避免的，方法是将默认值的计算推迟到optional判定为nil之后。  </p><p>就这样，我们可以巧妙地绕过条件判断和强制转换，以很优雅的写法处理对optional及默认的取值了。<strong>还有</strong> @autoclosure并不支持带有输入参数的写法，也就是只有形如()-&gt;T的参数才能使用这个特性进行简化。另外因为调用者往往很容易忽视@autoclosure这个特性,所以在写接受@autoclosure的方法时还请特别小心，如果在容易产生歧义或者误解的时候，还是使用完整地闭包写法会比较好   </p><p>####知识点5<br>– <em><strong>Optional Chaining</strong></em><br>使用Optional Chaining 可以让我们摆脱很多不必要的判断和取值，但是在使用的时候需要小心陷阱。  </p><p>因为Optional Chaining是随时都可能提前返回nil的，所以使用Optional Chaining所得到的东西其实都是optional的。比如下面一段代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toy</span> </span>&#123;</div><div class="line"><span class="keyword">let</span> name :<span class="type">String</span></div><div class="line"><span class="keyword">init</span>(name:<span class="type">String</span>) &#123;</div><div class="line"><span class="keyword">self</span>.name = name</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</div><div class="line"><span class="keyword">var</span> toy:<span class="type">Toy</span>?</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</div><div class="line"><span class="keyword">var</span> pet:<span class="type">Pet</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在实际使用中，我们想要知道小明的宠物得玩具得名字得时候，可以通过下面得Optional Chaining拿到：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> toyName = xiaoming.pet?.toy?.name</div></pre></td></tr></table></figure></p><p>注意虽然我们最后访问的是name，并且在Toy的定义中name是被定义为一个确定的<code>String</code>而非<code>String？</code>的，但我们拿到的toyName其实还是一个String?的类型。这是由于子啊Optional Chaining中我们任意一个 ?. 的时候都可能遇到nil而提前返回，这个时候当然就只能拿到nil了。<br>在实际使用中，我们大多数情况下可能更希望使用Optional Binding来直接取值这样的代码</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> toyName = xiaoming.pet?.toy?.name &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可能单独拿出来看会很清楚，但是只要稍微和其他特性结合一下，事情会变得复杂起来。来看看下面的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Toy</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们为Toy定义了一个扩展，以及一个玩玩具的方法play()。还是拿小明举例，要是有玩具的话就玩之：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xiaoming.pet?.toy?.play()</div></pre></td></tr></table></figure><p>除了小明也许我们还有小红小李小张等等。。这种时候我们就需要抽象出一个闭包来使用。传入一个Child对象，如果小朋友有宠物并且宠物有玩具的话就去玩。于是你很有可能写出这样的代码：<br><em><strong>错误代码</strong></em><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> playClosure = &#123;(child:<span class="type">Child</span>) -&gt; () <span class="keyword">in</span> child.pet?.toy?.play()&#125;</div></pre></td></tr></table></figure></p><p>你会发现这么表意清晰的代码居然无法编译！！  </p><p>问题在于对于play()的调用上。定义的时候我们没有写play()的返回，这表示这个方法返回void(或者写作一对小括号，他们是等价的)。但是正如上面所说，经过Optional Chainging以后我们得到的是一个Optional的结果。也就是说，我们最后得到的应该是这样一个closure：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> playClosure = &#123;(child:<span class="type">Child</span>) -&gt;()? <span class="keyword">in</span> </div><div class="line">child.pet?.toy?.play()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样调用的返回将是一个()?  (或者写成void？更清楚一点)，虽然看起来有一点奇怪，但这就是事实。使用的时候我们可以通过Optional Binding来判定方法是否调用成功：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> result:() = playClosure(xiaoming) &#123;</div><div class="line"></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>####知识点6<br>– <em><strong>操作符</strong></em>  </p><p>与Objective-C不同，swift支持重载操作符这样的特性，最常见的使用方式可能就是定义一些简便的计算了。比如我们需要一个表示二维向量的数据结构：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2D</span> </span>&#123;</div><div class="line"><span class="keyword">var</span> x = <span class="number">0.0</span> </div><div class="line"><span class="keyword">var</span> y = <span class="number">0.0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一个很简单的需求就是两个Vector2相加：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> v1 = <span class="type">Vector2D</span>(x:<span class="number">2.0</span>,y:<span class="number">3.0</span>)</div><div class="line"><span class="keyword">let</span> v2 = <span class="type">Vector2D</span>(x:<span class="number">1.0</span>,y:<span class="number">4.0</span>)</div><div class="line"><span class="keyword">let</span> v3 = <span class="type">Vector2D</span>(x:v1.x +v2.x,y:v1.y+v2.x)</div></pre></td></tr></table></figure><p>如果只做一次的话似乎还好，但是一般情况我们会进行很多这种操作。这样的话，我们可能更愿意定义一个Vector2D相加的操作，来让代码简化清晰。</p><p>对于两个向量相加，我们可以重载加号操作符：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> +<span class="params">(<span class="keyword">left</span>:Vector2D,<span class="keyword">right</span>:Vector2D)</span></span> -&gt;<span class="type">Vector2D</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="type">Vector2D</span>(x:<span class="keyword">left</span>.x+<span class="keyword">right</span>.x,y:<span class="keyword">left</span>.y+<span class="keyword">right</span>.y)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样，上面得V3以及之后的所有表示两个向量相加的操作就全部可以用加号来表达了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> v4 = v1+ v2</div></pre></td></tr></table></figure><p>类似的我们还可以为Vector2D定义其他运算符。  </p><p>上面定义的加号减号都是已经存在于swift运算符中了，我们所做的知识变换他的参数进行重载。如果我们想要定义一个全新的运算符的话，要做的事情会多一件。比如点积运算就是一个在适量运算中很常用的运算符，它表示两个向量对应坐标的成绩的和。根据定义，以及参考重载运算符的方法，我们选取+*来表示这个运算得话，我们不难写出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> +*<span class="params">(<span class="keyword">left</span>:Vector2D,<span class="keyword">right</span>:Vector2D)</span></span> -&gt;<span class="type">Double</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">left</span>.x*<span class="keyword">right</span>.x +<span class="keyword">left</span>.y * <span class="keyword">right</span>.y</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是编译器会给我们一个错误：<br><strong>Operator implementation without matching operator declaration</strong><br>这是因为我们没有对这个操作符进行声明。如果我们要新加操作符的话，需要先对其进行声明，告诉编译器这个符号其实是一个操作符。添加如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> +* &#123;</div><div class="line"><span class="keyword">associativity</span> <span class="keyword">none</span></div><div class="line"><span class="keyword">precedence</span> <span class="number">160</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>infix<br>  表示要定义得是一个中位操作符，即前后都是输入；其他得修饰符还包括 <code>prefix</code>和<code>postfix</code>，不再赘述  </p><p>associativity<br>  定义了结合律，即如果多个同类操作符顺序出现的计算顺序。比如常见的加法减法都是left，就是说多个加法同时出现时按照从左往右的顺序计算（因为加法满足交换律，所以这个顺序无所谓，但是减法的话计算顺序就很重要了）。点乘的结果是一个Double,不再会和其他点乘结合使用，所以这里写成none  </p><p>precedence<br>运算的优先级，越高的话越优先进行进行运算。Swift中乘法和除法的优先级是150，加法和减法是140，这里我们定义点积优先级160，就是说应该早于普通的乘除进行运算。有了这些之后，我们就可以很简单的进行向量得点积运算了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result = v1 +* v2</div></pre></td></tr></table></figure><p>最后需要多提一点的是，Swift操作符是不能定义在局部域中的，因为至少会希望在能在全局范围使用你的操作符，否则操作符也失去了意义了。另外，来自不同module的操作符室友可能冲突的。这对于库开发者来说是需要特别注意的地方。如果库中的操作符冲突的话，使用者是无法像解决类型名冲突那样通过指定库名字来进行调用的。因此在重载或者在自定义操作符时，应当尽量将其作为其他某个方法的简便写法，而避免在其中实现大量逻辑或者提供独一无二的功能。这样即使出现了冲突，使用者也还可以用方法调用的方式调用你的库。运算符的命名也应当尽量明了，避免歧义和可能的误解。因为一个不被公认的操作符是存在冲突风险和理解难度的，所以我们不应该滥用这个特性。在使用重载或者自定义操作符时，请一定要再三思考权衡。</p><p>####知识点7<br>– <em><strong>func的参数修饰</strong></em><br>在声明一个Swift的方法的时候，我们一般不去指定参数前面的修饰符，而是直接声明参数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(variable:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line"><span class="keyword">return</span> variable + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个方法接受一个Int的输入，然后通过将这个输入加1，返回一个新的笔输入大1的Int，就是一个简单的+1器。  </p><p>很多同学在大学的C程序设计里可能学过像 ++ 这样的自增运算符，再加上做了不少关于 判断一个数被各种前置++ 和后置++折磨后的输出是什么的考试题，所以之后写代码是也会不自觉地喜欢带上这种风格，于是同样的功能可能会写出类似这样的方法。  </p><p><strong>这是错误代码</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(variable:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line"><span class="keyword">return</span> ++variable</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>残念。。编译错误。为什么在swift里这样都不行呢？答案是因为Swift其实是一门讨厌变化的语言。所有有可能的地方，都被默认为是不可变的，也就是用let声明的，这样不仅可以确保安全，也能在编译器的性能优化上更有作为。在方法的参数上也是如此，我们不写修饰符的画，默认情况下所有参数都是let的，上面的代码等效为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(<span class="keyword">let</span> variable:Int)</span></span> -&gt;<span class="type">Int</span> &#123;</div><div class="line"><span class="keyword">return</span> ++variable</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>let的参数，不能重新赋值这是理所当然的。要让这个方法正确编译，我们需要做的改动是将let改为var：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(<span class="keyword">var</span> variable:Int)</span></span> -&gt;<span class="type">Int</span> &#123;</div><div class="line"><span class="keyword">return</span> ++variable </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>正如上面的例子，我们将参数写作var后，通过调用返回的值是正确的，而luckyNumber还是保持了原来的值。这说明var只是在方法内部作用，而不直接影响输入的值。有写时候我们会希望在方法内部直接修改输入的值，这时候我们可以使用<code>inout</code> 来对参数进行修饰</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(<span class="keyword">inout</span> variable:Int)</span></span>  &#123;</div><div class="line"> ++variable</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后，要注意的时参数得修饰是具有传递限制的，就是说对于跨越层级的调用，我们需要保证统一参数的修饰是统一的。举个例子，比如我们想扩展一下上面的方法，实现一个可以累加任意数字的 +N器 的话，可以写成这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementor</span><span class="params">(addNumber:Int)</span></span> -&gt;((<span class="keyword">inout</span> <span class="type">Int</span>) -&gt;()) &#123;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(<span class="keyword">inout</span> variable:Int)</span></span> -&gt; () &#123;</div><div class="line">variable += addNumber</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> incrementor</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>外层的makeIncrementor的返回里也需要才参数的类型前面明确指出修饰词，已符合内部的定义，否则将无法编译通过。 </p><p>####知识点8<br>– <em><strong>方法参数名称省略</strong></em>  </p><ul><li style="list-style: none"><input type="checkbox"> <strong>TODO</strong> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;lin
      
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>oc语法新特性总结</title>
    <link href="http://yoursite.com/2015/10/10/oc%E8%AF%AD%E6%B3%95%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2015/10/10/oc语法新特性总结/</id>
    <published>2015-10-10T12:49:35.000Z</published>
    <updated>2016-01-19T12:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>  自 WWDC 2015 推出和开源 Swift 2.0 后，大家对 Swift 的热情又一次高涨起来，在羡慕创业公司的朋友们大谈 Swift 新特性的同时，也有很多像我一样工作上依然需要坚守着 Objective-C 语言的开发者们。今年的 WWDC 中介绍了几个 Objective-C 语言的新特性，还是在“与 Swift 协同工作”这种 Topic 里讲的，越发凸显这门语言的边缘化了，不过有新特性还是极好的，接下来，本文将介绍下面三个主要的新特性：</p><ul><li>Nullability</li><li>Lightweight Generics *</li><li>__kindof</li></ul><h3 id="Nullability"><a href="#Nullability" class="headerlink" title="Nullability"></a>Nullability</h3><p>  然而 Nullability 并不算新特性了，从上一个版本的 llvm 6.1 (Xcode 6.3) 就已经支持。这个简版的 Optional ，没有 Swift 中 ? 和 ! 语法糖的支持，在 Objective-C 中就显得非常啰嗦了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong, nonnull) <span class="type">Sark</span> *sark;  </div><div class="line">@property (nonatomic, copy, readonly, nullable) <span class="type">NSArray</span> *friends;  </div><div class="line">+(nullable <span class="type">NSString</span> *)friendWithName:(nonnull <span class="type">NSString</span> *)name;</div></pre></td></tr></table></figure><p>假如用来修饰一个变量，前面还要加双下划线，放到 block 里面就更加诡异，比如一个 Request 的 start 方法可以写成：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)startWithCompletionBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSError</span> * __<span class="keyword">nullable</span> error))block;</div></pre></td></tr></table></figure><p>除了除了这俩外，还有个 null_resettable 来表示 setter nullable，但是 getter nonnull，绕死了，最直观例子就是 UIViewController 中的 view 属性: </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">null_resettable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *view;</div></pre></td></tr></table></figure><p>它可以被设成 nil，但是调用 getter 时会触发 <code>-loadView</code> 从而创建并返回一个非 nil 的 view。<br>从 iOS9 SDK 中可以发现，头文件中所有 API 都已经增加了 Nullability 相关修饰符，想了解这个特性的用法，翻几个系统头文件就差不离了。接口中 <code>nullable</code> 的是少数，所以为了防止写一大堆 <code>nonnull</code>，Foundation 还提供了一对儿宏，包在里面的对象默认加 nonnull 修饰符，只需要把 nullable 的指出来就行，黑话叫 Audited Regions：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *workingCompany;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *friends;</div><div class="line">-(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)gayFriend;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></div></pre></td></tr></table></figure><p>Nullability 在编译器层面提供了空值的类型检查，在类型不符时给出 warning，方便开发者第一时间发现潜在问题。不过我想更大的意义在于能够更加清楚的描述接口，是主调者和被调者间的一个协议，比多少句文档描述都来得清晰，打个比方：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+(<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)URLWithString:(<span class="built_in">NSString</span> *)URLString;</div></pre></td></tr></table></figure><p>NSURL 的这个 API 前面加了 nullable 后，更加显式的指出了这个接口可能因为 URLString 的格式错误而创建失败，使用时自然而然的就考虑到了判空处理。<br>不仅是属性和方法中的对象，对于局部的对象、甚至 c 指针都可以用带双下划线的修饰符，可以理解成能用 const 关键字的地方都能用 Nullability。</p><h3 id="Lightweight-Generics"><a href="#Lightweight-Generics" class="headerlink" title="Lightweight Generics"></a>Lightweight Generics</h3><p>Lightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（llvm 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）</p><h5 id="带泛型的容器"><a href="#带泛型的容器" class="headerlink" title="带泛型的容器"></a>带泛型的容器</h5><p>这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *strings = @[<span class="string">@"sun"</span>, <span class="string">@"yuan"</span>];</div><div class="line"><span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSNumber</span> *&gt; *mapping = @&#123;<span class="string">@"a"</span>: @<span class="number">1</span>, <span class="string">@"b"</span>: @<span class="number">2</span>&#125;;</div></pre></td></tr></table></figure><p>返回值的 id 被替换成具体的类型后，令人感动的代码提示也出来了：</p><p>假如向泛型容器中加入错误的对象，编译器会不开心的：</p><p>系统中常用的一系列容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了，这是非常 Nice 的改进。和 Nullability 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *imageURLs;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *imageURLs;</div></pre></td></tr></table></figure><p>不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。</p><h5 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h5><p>比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Stack</span>&lt;<span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)pushObject:(ObjectType)object;</div><div class="line">- (ObjectType)popObject;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;ObjectType&gt; *allObjects;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>这个 <code>ObjectType</code> 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 ok，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只接受 NSNumber * 的泛型</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Stack</span>&lt;<span class="title">ObjectType</span>: <span class="title">NSNumber</span> *&gt; : <span class="title">NSObject</span></span></div><div class="line"><span class="comment">// 只接受满足 NSCopying 协议的泛型</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Stack</span>&lt;<span class="title">ObjectType</span>: <span class="title">id</span>&lt;<span class="title">NSCopying</span>&gt;&gt; : <span class="title">NSObject</span></span></div></pre></td></tr></table></figure><p>若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。<br>实例化一个 Stack，一切工作正常：</p><p>对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。</p><h5 id="协变性和逆变性"><a href="#协变性和逆变性" class="headerlink" title="协变性和逆变性"></a>协变性和逆变性</h5><p>当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Stack *stack; <span class="comment">// Stack *</span></div><div class="line">Stack&lt;<span class="built_in">NSString</span> *&gt; *stringStack; <span class="comment">// Stack&lt;NSString *&gt;</span></div><div class="line">Stack&lt;<span class="built_in">NSMutableString</span> *&gt; *mutableStringStack; <span class="comment">// Stack&lt;NSMutableString *&gt;</span></div></pre></td></tr></table></figure><p>当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：</p><p>我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了：</p><p><code>__covariant</code> - 协变性，子类型可以强转到父类型（里氏替换原则）<br><code>__contravariant</code> - 逆变性，父类型可以强转到子类型（WTF?）</p><p>协变：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Stack</span>&lt;<span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span></span></div></pre></td></tr></table></figure><p>效果：</p><p>逆变：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Stack</span>&lt;<span class="title">__contravariant</span> <span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span></span></div></pre></td></tr></table></figure><p>效果：</p><p>协变是非常好理解的，像 NSArray 的泛型就用了协变的修饰符，而逆变我还没有想到有什么实际的使用场景。</p><h3 id="kindof"><a href="#kindof" class="headerlink" title="__kindof"></a>__kindof</h3><p>__kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)dequeueReusableCellWithIdentifier:(<span class="built_in">NSString</span> *)identifier;</div></pre></td></tr></table></figure><p>使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (__kindof <span class="built_in">UITableViewCell</span> *)dequeueReusableCellWithIdentifier:(<span class="built_in">NSString</span> *)identifier;</div></pre></td></tr></table></figure><p>既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">UIView</span> *&gt; *subviews;</div></pre></td></tr></table></figure><p>这样，写下面的代码时就没有任何警告了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span> *button = view.subviews.lastObject;</div></pre></td></tr></table></figure><h3 id="Where-to-go"><a href="#Where-to-go" class="headerlink" title="Where to go"></a>Where to go</h3><p>有了上面介绍的这些新特性以及如 instancetype 这样的历史更新，Objective-C 这门古老语言的类型检测和类型推断终于有所长进，现在不论是接口还是代码中的 id 类型都越来越少，更多潜在的类型错误可以被编译器的静态检查发现。<br>同时，个人感觉新版的 Xcode 对继承链构造器的检测也加强了，NS_DESIGNATED_INITIALIZER 这个宏并不是新面孔，可以使用它标志出像 Swift 一样的指定构造器和便捷构造器。</p><p>最后，附上一段用上了所有新特性的代码，Swift 是发展趋势，如果你暂时依然要写 Objective-C 代码，把所有新特性都用上，或许能让你到新语言的迁移更无痛一点。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://msdn.microsoft.com/zh-cn/library/dd799517.aspx" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/dd799517.aspx</a><br><a href="https://gist.github.com/jtbandes/881f07a955ff2eadd1a0" target="_blank" rel="external">https://gist.github.com/jtbandes/881f07a955ff2eadd1a0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OverView&quot;&gt;&lt;a href=&quot;#OverView&quot; class=&quot;headerlink&quot; title=&quot;OverView&quot;&gt;&lt;/a&gt;OverView&lt;/h3&gt;&lt;p&gt;  自 WWDC 2015 推出和开源 Swift 2.0 后，大家对 Swift 的热情又
      
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>董小姐日的碎碎念想</title>
    <link href="http://yoursite.com/2015/08/06/%E8%91%A3%E5%B0%8F%E5%A7%90%E6%97%A5%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5%E6%83%B3/"/>
    <id>http://yoursite.com/2015/08/06/董小姐日的碎碎念想/</id>
    <published>2015-08-05T16:00:20.000Z</published>
    <updated>2016-01-20T03:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在，就是这个时间<br><img src="http://ww1.sinaimg.cn/mw690/759d343bjw1eus63c0vyqj20l60cgq42.jpg" alt="icon"></p><p>一晃眼真的就是5年了，时间就是这么的快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在，就是这个时间&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/759d343bjw1eus63c0vyqj20l60cgq42.jpg&quot; alt=&quot;icon&quot;&gt;&lt;/p&gt;
&lt;p&gt;一晃眼真的就是5年了，时间就是这么的快。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="含小蓄的小世界" scheme="http://yoursite.com/tags/%E5%90%AB%E5%B0%8F%E8%93%84%E7%9A%84%E5%B0%8F%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa 和 MVVM 入门</title>
    <link href="http://yoursite.com/2015/05/21/2015-05-21-ReactiveCocoa-and-MVVM-an-Introduction/"/>
    <id>http://yoursite.com/2015/05/21/2015-05-21-ReactiveCocoa-and-MVVM-an-Introduction/</id>
    <published>2015-05-21T13:43:37.000Z</published>
    <updated>2016-01-19T12:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自<a href="http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction" target="_blank" rel="external">ReactiveCocoa and MVVM,  an Introduction</a>. <del>文中引用的 Gist 可能无法显示. 为了和谐社会, 请<a href="http://tizipro.com/?r=ee0508bc191f5651" target="_blank" rel="external">科学上网</a></del>   </p><a id="more"></a><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>任何一个正经开发过一阵子软件的人都熟悉<strong>MVC</strong>. 它意思是<strong>Model View Controller</strong>, 是一个在复杂应用设计中组织代码的公认模式. 它也被证实在 iOS 开发中有着第二种含义:  <strong>Massive View Controller(重量级视图控制器)</strong>. 它让许多程序员绞尽脑汁如何去使代码被解耦和组织地让人满意. 总的来说, iOS 开发者已经得出结论: 他们需要<a href="http://www.objc.io/issue-1/" target="_blank" rel="external">给视图控制器瘦身</a>, 并进一步分离事物;但该怎么做呢?  </p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>于是<strong>MVVM</strong>流行起来, 它代表<strong>Model View View-Model</strong>, 它在这帮助我们创建更易处理, 更佳设计的代码.   </p><p>有时候违背苹果建议的编码方式并不是个好做法. 我不是说不赞成这样子, 我指的是可能会弊大于利. 比如我不建议你去实现个自己的 view controller 基类并试着自己处理视图生命周期.   </p><p>带着这种情绪, 我想提个问题: <strong>使用除苹果推荐的 MVC 之外的应用设计模式是愚蠢的么?</strong>  </p><p><strong>不</strong>. 有两个原因.   </p><ol><li>苹果没有为解决重量级试图控制器问题提供真正的指导. 他们留给我们来解决如何向代码添加更多清晰的思路. 用 MVVM 来实现这个目的想必是极好哒. (在今年 WWDC 的一些视频中, 苹果工程师在屏幕上的示例代码的确少许出现了 view-model, 不知道是否因为有它才成为了示例代码)</li><li>MVVM,  至少是我将要在这里展示的 MVVM 的风格, 都跟 MVC 十分兼容. 仿佛我们将 MVC 进行到下一个逻辑步骤. </li></ol><p>我不会提及 MVC/MVVM 的历史, 因为其他地方已经有所介绍, 并且我也不精通. 我将会关注如何用它进行 iOS/Mac 开发.   </p><h3 id="定义-MVVM"><a href="#定义-MVVM" class="headerlink" title="定义 MVVM"></a>定义 MVVM</h3><ol><li><strong>Model</strong> - model 在 MVVM 中没有真正的变化. 取决于你的偏好, 你的 model 可能会或可能不会封装一些额外的业务逻辑工作. 我更倾向于把它当做一个容纳表现数据-模型对象信息的结构体, 并在一个单独的管理类中维护的创建/管理模型的统一逻辑. </li><li><strong>View</strong> - view 包含实际 UI 本身(不论是 <code>UIView</code> 代码, storyboard 和 xib), 任何视图特定的逻辑, 和对用户输入的反馈. 在 iOS 中这不仅需要 <code>UIView</code> 代码和那些文件, 还包括很多需由 <code>UIViewController</code> 处理的工作. </li><li><strong>View-Model</strong> - 这个术语本身会带来困惑, 因为它混搭了两个我们已知的术语, 但却是完全不同的东东. 它不是传统数据-模型结构中模型的意思(又来了, 只是我喜欢这个例子). 它的职责之一就是作为一个表现视图显示自身所需数据的静态模型;但它也有收集, 解释和转换那些数据的责任. 这留给了 view (controller) 一个更加清晰明确的任务: 呈现由 view-model 提供的数据. </li></ol><h3 id="关于-view-model-的更多内容"><a href="#关于-view-model-的更多内容" class="headerlink" title="关于 view-model 的更多内容"></a>关于 view-model 的更多内容</h3><p><strong>view-model</strong> 一词的确不能充分表达我们的意图. 一个更好的术语可能是 “View Coordinator”(感谢<a href="https://twitter.com/kastiglione" target="_blank" rel="external">Dave Lee</a>提的这个 “View Coordinator” 术语, 真是个好点子). 你可以认为它就像是电视新闻主播背后的研究人员和作家团队. 它从必要的资源(数据库, 网络服务调用, 等)中获取原始数据, 运用逻辑, 并处理成 view (controller) 的展示数据. 它(通常通过属性)暴露给视图控制器需要知道的仅关于显示视图工作的信息(理想地你不会暴漏你的 data-model 对象). 它还负责对上游数据的修改(比如更新模型/数据库, API POST 调用). </p><h2 id="MVC-世界中的-MVVM"><a href="#MVC-世界中的-MVVM" class="headerlink" title="MVC 世界中的 MVVM"></a>MVC 世界中的 MVVM</h2><p>我认为 MVVM 这个首字母缩写如同 view-model 术语一样, 对如何使用它们进行 iOS 开发体现得有点不太准确. 让我们再检查下这个首字母缩写, 了解下它是怎么与 MVC 融为一体的.   </p><p>为了图解表示, 我们颠倒了 <strong>MVC</strong> 中的 <strong>V</strong> 和 <strong>C</strong>, 于是首字母缩写更能准确地反映出组件间的关系方位, 给我们带来 <strong>MCV</strong>. 我也会对 <strong>MVVM</strong> 这么干, 将 <strong>V(iew)</strong> 移到 <strong>VM</strong> 的右边最终成为了 <strong>MVMV</strong>. (我相信这些首字母缩写起初不排成这样更合理的顺序是有原因的. )  </p><p>这是这两种模式如何在 iOS 中组装在一起的简单映射:   </p><p><img src="http://www.sprynthesis.com/assets/images/MCVMVMV.svg" alt="">  </p><ul><li>我试图遵循区块尺寸(非常)大致对应它们负责的工作量. </li><li><a href="http://i0.kym-cdn.com/photos/images/newsfeed/000/228/269/demotivational-posters-theres-your-problem.jpg" target="_blank" rel="external">注意到视图控制器有多大?</a></li><li>你可以看到我们巨大的视图控制器和 view-model 之间有大块工作上的重合. </li><li>你也可以看看视图控制器在 MVVM 中的足迹有多大一部分是跟视图重合的. </li></ul><p>你大可安心获知我们并没有真的去除视图控制器的概念或抛弃 “controller” 术语来匹配 MVVM. (唷. )我们正要将重合的那块工作剥离到 view-model 中, 并让视图控制器的生活更加简单.   </p><p>我们实际上最终以 <strong>MVMCV</strong> 告终. <strong>M</strong>odel <strong>V</strong>iew-<strong>M</strong>odel <strong>C</strong>ontroller <strong>V</strong>iew. 我确信我无拘无束的应用设计模式骇客行为会让人大吃一惊.   </p><p><img src="http://www.sprynthesis.com/assets/images/MCVMVMV.gif" alt="">  </p><p><strong>我们的结果: </strong>  </p><p><img src="http://www.sprynthesis.com/assets/images/MVMCV.svg" alt="">  </p><p>现在视图控制器仅关注于用 view-model 的数据配置和管理各种各样的视图, 并在先关用户输入时让 view-model 获知并需要向上游修改数据. 视图控制器不需要了解关于网络服务调用, Core Data, 模型对象等. (事实上有时通过 view-model 头文件而不是复制一大堆属性来暴漏 model 是很务实的, 后面还会有)  </p><p>view-model 会在视图控制器上以一个属性的方式存在. 视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知. 你早就该对这个设计感觉好多了因为我们的关注点在这儿进行更好地分离.   </p><p>帮助你理解我们如何把组件组装在一起还有组件对应职责的另一种方式, 就是着眼于我们新的应用构建模块层级图.   </p><p><img src="http://www.sprynthesis.com/assets/images/mvvm-layers.svg" alt="">  </p><p>(感谢<a href="https://twitter.com/kastiglione" target="_blank" rel="external">Dave Lee @kastiglione</a>)</p><h2 id="View-Model-和-View-Controller-在一起，但独立"><a href="#View-Model-和-View-Controller-在一起，但独立" class="headerlink" title="View-Model 和 View Controller,  在一起，但独立"></a>View-Model 和 View Controller,  在一起，但独立</h2><p>我们来看个简单的 view-model 头文件来对我们新构件的长相有个更好地概念. 为了情节简单, 我们构建按了一个伪造的推特客户端来查看任何推特用户的最新回复, 通过输入他们的姓名并点击 “Go”.  我们的样例界面将会是这样:   </p><ul><li>有一个让用户输入他们姓名的 <code>UITextField</code> , 和一个写着 “Go” 的 <code>UIButton</code></li><li>有显示被查看的当前用户头像和姓名的 <code>UIImageView</code> 和 <code>UILabel</code> 各一个</li><li>下面放着一个显示最新回复推文的 <code>UITableView</code></li><li>允许无限滚动</li></ul><p><img src="http://www.sprynthesis.com/assets/images/tweeboatplus.svg" alt="">  </p><h3 id="View-Model-实例"><a href="#View-Model-实例" class="headerlink" title="View-Model 实例"></a>View-Model 实例</h3><p>我们的 view-model 头文件应该长这样:   </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MYTwitterLookupViewModel.h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MYTwitterLookupViewModel</span>: <span class="title">NSObject</span></span></div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isUsernameValid) <span class="built_in">BOOL</span> usernameValid;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *userFullName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIImage</span> *userAvatarImage;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *tweets;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> allTweetsLoaded;</div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSString</span> *username;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>) getTweetsForCurrentUsername;</div><div class="line">- (<span class="keyword">void</span>) loadMoreTweets;</div></pre></td></tr></table></figure><p>相当直截了当的填充. 注意到这些<strong>壮丽的 <code>readonly</code> 属性</strong>了么?这个 view-model 暴漏了视图控制器所必需的最小量信息, 视图控制器实际上并不在乎 view-model 是如何获得这些信息的. 现在我们两者都不在乎. 仅仅假定你习惯于标准的网络服务请求, 校验, 数据操作和存储.   </p><h4 id="view-model-不做的事儿"><a href="#view-model-不做的事儿" class="headerlink" title="view-model 不做的事儿"></a>view-model 不做的事儿</h4><ul><li>对视图控制器以任何形式直接起作用或直接通告其变化</li></ul><h3 id="View-Controller-视图控制器"><a href="#View-Controller-视图控制器" class="headerlink" title="View Controller(视图控制器)"></a>View Controller(视图控制器)</h3><h4 id="视图控制器从-view-model-获取的数据将用来"><a href="#视图控制器从-view-model-获取的数据将用来" class="headerlink" title="视图控制器从 view-model 获取的数据将用来:"></a>视图控制器从 view-model 获取的数据将用来:</h4><ul><li>当 <code>usernameValid</code> 的值发生变化时触发 “Go” 按钮的 <code>enabled</code> 属性</li><li>当 <code>usernameValid</code> 等于 <code>NO</code> 时调整按钮的 <code>alpha</code> 值为0. 5(等于 <code>YES</code> 时设为1. 0)</li><li>更新 <code>UILable</code> 的 <code>text</code> 属性为字符串 <code>userFullName</code> 的值</li><li>更新 <code>UIImageView</code> 的 <code>image</code> 属性为 <code>userAvatarImage</code> 的值</li><li>用 <code>tweets</code> 数组中的对象设置表格视图中的 cell (后面会提到)</li><li>当滑到表格视图底部时如果 <code>allTweetsLoaded</code> 为 <code>NO</code>, 提供一个 显示 “loading” 的 cell</li></ul><h4 id="视图控制器将对-view-model-起如下作用"><a href="#视图控制器将对-view-model-起如下作用" class="headerlink" title="视图控制器将对 view-model 起如下作用:"></a>视图控制器将对 view-model 起如下作用:</h4><ul><li>每当 <code>UITextField</code> 中的文本发生变化, 更新 view-model 上仅有的 <code>readwrite</code> 属性 <code>username</code></li><li>当 “Go” 按钮被按下时调用 view-model 上的 <code>getTweetsForCurrentUsername</code> 方法</li><li>当到达表格中的 “loading” cell 时调用 view-model 上的 <code>loadMoreTweets</code> 方法</li></ul><h4 id="视图控制器不做的事儿"><a href="#视图控制器不做的事儿" class="headerlink" title="视图控制器不做的事儿:"></a>视图控制器不做的事儿:</h4><ul><li>发起网络服务调用</li><li>管理 <code>tweets</code> 数组</li><li>判定 <code>username</code> 内容是否有效</li><li>将用户的姓和名格式化为全名</li><li>下载用户头像并转成 <code>UIImage</code>(如果你习惯在 <code>UIImageView</code> 上使用类别从网络加载图片, 你可以暴漏 URL 而不是图片. 这样就给 view-model 与 UIKit 之间一个更清晰的划分, 但我视 <code>UIImage</code> 为数据而非数据的确切显示. 这些东西不是固定死的. )</li><li>流汗</li></ul><p>请再次注意视图控制器总的责任是处理 view-model 中的变化. </p><h2 id="子-View-Model"><a href="#子-View-Model" class="headerlink" title="子 View-Model"></a>子 View-Model</h2><p>我提到过使用 view-model 上的 <code>tweets</code> 数组中的对象配置表格视图的 cell.通常你会期待展现 <code>tweets</code> 的是数据-模型对象. 你可能已经对其感到奇怪, 因为我们试图通过 MVVM 模式不暴漏数据-模型对象. (前面提到过的)  </p><p><strong>view-model 不必在屏幕上显示所有东西. </strong>你可用子 view-model 来代表屏幕上更小, 更潜在被封装的部分. 如果一个视图上的一小块儿(比如表格的 cell)在 app 中可以被重用以及(或)表现多个数据-模型对象, 子 view-model 会格外有利.   </p><p>你不总是需要子 view-model.  比如, 我可能用表格 header 视图来渲染我们“tweetboat plus”应用的顶部. 它不是个可重用的组件, 所以我可能仅是将我们已经给视图控制器用过的相同的 view-model 传给那个自定义的 header 视图. 它会用到 view-model 中它需要的信息, 而无视余下的部分. 这对于保持子视图同步是极好的方式, 因为它们可以有效地与信息中相同确切的上下文作用, 并观察确切相同属性的更新.   </p><p>在我们的例子中,  <code>tweets</code> 数组将会被下面这样的子 view-model 充满: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//MyTweetCellViewModel.h</div><div class="line">@interface MYTweetCellViewModel: NSObject</div><div class="line"> </div><div class="line">@property (nonatomic, strong, readonly) NSString *tweetAuthorFullName;</div><div class="line">@property (nonatomic, strong, readonly) UIImage *tweetAuthorAvatarImage;</div><div class="line">@property (nonatomic, strong, readonly) NSString *tweetContent;</div></pre></td></tr></table></figure><p>你可能认为这也太像普通”推特”里的数据-模型对象了吧. 为啥要干将其转化成 view-model 的工作?即使类似,  view-model 让我们限制信息只暴露给我们需要的地方, 提供额外数据转换的属性, 或为特定的视图计算数据. (此外, 当可以不暴露可变数据-模型对象时也是极好的, 因为我们希望 view-model 自己承担起更新它们的任务, 而不是靠视图或视图控制器. )  </p><h3 id="View-Model-从哪来"><a href="#View-Model-从哪来" class="headerlink" title="View-Model 从哪来?"></a>View-Model 从哪来?</h3><p>那么 view-model 是何时何处被创建的呢?视图控制器创建它们自己的 view-model 么?  </p><h4 id="View-Model-产生-View-Model"><a href="#View-Model-产生-View-Model" class="headerlink" title="View-Model 产生 View-Model"></a>View-Model 产生 View-Model</h4><p>严格来说, 你应该为 app delegate 中的顶级视图控制器创建一个 view-model. 当展示一个新的视图控制器时, 或很小的视图被 view-model 表现时, 你应要求当前的 view-model 为你创建一个子 view-model.   </p><p><img src="http://www.sprynthesis.com/assets/images/child-view-models.svg" alt="">  </p><p>加入我们想要在用户轻拍应用顶部的头像时添加一个资料视图控制器. 我们可以为一级 view-model 添加类似如下方法:   </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (MYTwitterUserProfileViewModel *) viewModelForCurrentUser;</div></pre></td></tr></table></figure><p>然后在我们的一级视图控制器中这么用它:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//MYMainViewController.m </div><div class="line">- (IBAction) didTapPrimaryUserAvatar</div><div class="line">&#123;</div><div class="line">    MYTwitterUserProfileViewModel *userProfileViewModel = [self.viewModel viewModelForCurrentUser];</div><div class="line">    </div><div class="line">    MYTwitterUserProfileViewController *profileViewController = </div><div class="line">        [[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel];</div><div class="line">    [self.navigationController pushViewController: profileViewController animated:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这个例子中我将会展现当前用户的资料视图控制器, 但是我的资料视图控制器需要一个 view-model. 我这的主视图控制器不知道(也不该知道)用于创建关联相关用户 view-model 的全部必要数据, 所以它请求它自己的 view-model 来干这种创建新 view-model 的苦差事.   </p><h4 id="View-Model-列表"><a href="#View-Model-列表" class="headerlink" title="View-Model 列表"></a>View-Model 列表</h4><p>至于我们的推特 cell, 当数据驱动屏幕(在这个例子中或许是通过网络服务调用)聚到一起时, 我将会代表性地提前为对应的 cell 创建所有的 view-model.  所以在我们这个方案中,  <code>tweets</code> 将会是一个 <code>MYTweetCellViewModel</code> 对象数组. 在我的表格视图中的 <code>cellForRowAtIndexPath</code> 方法中, 我将会在正确的索引上简单地抓取 view-model,  并把它赋值给我的 cell 上的 view-model 属性.   </p><h2 id="Functional-Core-Imperative-Shell"><a href="#Functional-Core-Imperative-Shell" class="headerlink" title="Functional Core,  Imperative Shell"></a>Functional Core,  Imperative Shell</h2><p>view-model 这种通往应用设计的方法是一块应用设计之路上的垫脚石, 这种被称作<a href="https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell" target="_blank" rel="external">“Functional Core,  Imperative Shell”</a>的应用设计由<a href="https://twitter.com/garybernhardt" target="_blank" rel="external">Gary Bernhardt</a>创造. (我最近十分有幸去听<a href="http://andymatuschak.org" target="_blank" rel="external">Andy Matuschak</a>关于这方面的演讲, 他为”胖的数值层, 瘦的对象层”提出充分理由. 虽然观点相似, 但关注于我们怎样移除对象和它们状态的边界影响性质, 并用 Swift 中的新数据结构构建更加函数式, 可测试的数值层. )</p><h3 id="Functional-Core"><a href="#Functional-Core" class="headerlink" title="Functional Core"></a>Functional Core</h3><p>view-model 就是 <a href="http://www.smashingmagazine.com/2014/07/02/dont-be-scared-of-functional-programming/" target="_blank" rel="external">“functional core”</a>, 尽管实际上在 iOS/Objective-C 中达到纯函数水平是很棘手的(Swift 提供了一些附加的函数性, 这会让我们更接近). 大意是让我们的 view-model 尽可能少的对剩余的”应用世界”的依赖和影响. 那意味着什么?想起你第一次学编程时可能学到的简单函数吧. 它们可能接受一两个参数并输出一个结果. <strong>数据输入, 数据输出.</strong>这个函数可能是做一些数学运算或是将姓和名结合到一起. 无论应用的其他地方发生啥, 这个函数总是对相同的输入产生相同的输出. 这就是函数式方面.   </p><p>这就是我们为 view-model 谋求的东西. 他们富有逻辑和转换数据并将结果存到属性的功能. 理想上相同的输入(比如网络服务响应)将会导出相同的输出(属性的值). 这意味着尽可能多地消除由”应用世界”剩余部分带来的可能影响输出的因素, <a href="http://www.sprynthesis.com/2014/06/15/why-reactivecocoa/" target="_blank" rel="external">比如使用一堆状态. </a><strong>一个好的第一步就是不要再 view-model 头文件中引入 UIKit.h.</strong>(这是个重大原则, 但也有些灰色区域. 比如, 你可能认为 <code>UIImage</code> 是数据而不是展示信息. PS:  我爱这么干. 既然这样的话就得引入 UIKit. h 以便使用 <code>UIImage</code> 类)UIKit 其性质就是将要影响许多应用世界. 它包含很多”副作用”, 凭借改变一个值或调用一个函数将触发很多间接(甚至未知)的改变.   </p><p><strong>更新:</strong> 刚刚看了 Andy 在<a href="http://2014.funswiftconf.com" target="_blank" rel="external">函数式 Swift 会议</a>上给出的另一个超赞的演讲, 于是又想到了一些. 要清楚你的 view-model <em>仍然</em>只是一个对象, 而不用维护一些状态(否则它将不会是你视图中非常好用的模型了. )但你仍该努力将尽可能多的逻辑移到无状态的函数”值”中. 再重复一次, Swift在这方面比 Objective-C 更加可行. </p><h3 id="Imperative-Declarative-Shell"><a href="#Imperative-Declarative-Shell" class="headerlink" title="Imperative (Declarative?) Shell"></a>Imperative (Declarative?) Shell</h3><p>命令式外壳 (Imperative Shell) 是我们需要做所有的状态转换, 应用世界改变的苦差事的地方, 为的是将 view-model 数据转成给用户在屏幕上看到的东西. 这是我们的视图(控制器), 实际上我们在这分离 UIKit 的工作. 我仍将特别注意尽可能消除状态并用 ReactiveCocoa 这种陈述性质的东西做这方面工作, 而 iOS 和 UIKit 在设计上是命令式的.  (表格的 data source 就是个很好的例子, 因为它的委托模式强制将状态应用到委托中, 为了当请求发生时能够为表格视图提供信息. 实际上委托模式通常强制一大堆状态的使用)</p><h3 id="可测试的核心"><a href="#可测试的核心" class="headerlink" title="可测试的核心"></a>可测试的核心</h3><p>iOS 的单元测试是个脏, 苦, 乱的活儿. 至少我去做的时候得出的是这么个结论. 就这方面我还出读过一两本书, 但当开始做视图控制器的 mocking 和 swizzling 使其一些逻辑可测试时, 我目光呆滞. 我最终把单元测试归入模型和任何同类别模型管理类中. (译者注:  mock 是测试常用的手段, 而 method swizzling 是基于 Objective-C Runtime 交换方法实现的黑魔法)  </p><p>这个函数式核心一样的 view-model 的最大优点, 除了 bug 数量随着状态数递减之外, 就是<em>变得非常能够进行单元测试</em>. 如果你有那种每次输入相同而产生的输出也相同的方法, 那就非常适合单元测试的世界. 我们现在将我们的数据用获取/逻辑/转换提取出, 避免了视图控制器的复杂性. 那意味着构建棒棒哒测试时不需要用疯狂的 mock 对象,  method swizzling,  或其他疯癫的变通方法(希望能有).   </p><h2 id="连接一切"><a href="#连接一切" class="headerlink" title="连接一切"></a>连接一切</h2><p><strong>那么当 view-model 的共有属性发生变化时我们如何更新我们的视图呢?</strong>  </p><p>绝大部分时间我们用对应的 view-model 来初始化视图控制器, 有点类似我们刚刚在上文见到的:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MYTwitterUserProfileViewController *profileViewController =</div><div class="line">    [[MYTwitterUserProfileViewController alloc] initWithViewModel:  userProfileViewModel];</div></pre></td></tr></table></figure><p>有时你无法在初始化时将 view-model 传入, 比如在 storyboard segue 或 cell dequeuing 的情况下. 这时你应该在讨论中的视图(控制器)中暴露一个公有可写的 view-model 属性.   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MYTwitterUserCell *cell =</div><div class="line">    [self.tableView dequeueReusableCellWithIdentifier: @&quot;MYTwitterUserCell&quot; forIndexPath: indexPath];</div><div class="line">// grab the cell view-model from the vc view-model and assign it</div><div class="line">cell.viewModel = self.viewModel. tweets[indexPath. row];</div></pre></td></tr></table></figure><p>有时我们可以在钩子程序调用前传入 view-model,  比如 <code>init</code> 和 <code>viewDidLoad</code>,  我们可以从view-model 的属性初始化所有 UI 元素的状态.   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//dontDoThis1.m </div><div class="line">- (id) initWithViewModel:(MYTwitterLookupViewModel *) viewModel &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) return nil;</div><div class="line">    _viewModel = viewModel;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">- (void) viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    _goButton.enabled = viewModel.isUsernameValid;</div><div class="line">    _goButton.alpha = viewModel.isUsernameValid ? 1 : 0.5;</div><div class="line">    // etc</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好棒!我们已经配置好了初始值. 当 view-model 上的数据改变时怎么办? 当”go” 按钮在什么时候可用了怎么办?当用户标签和头像在什么时候从网络上下载并填充了怎么办?  </p><p>我们可以将视图控制器暴露给 view-model,  以便于当相关数据变化或类似事件发送时它可以调用一个 “updateUI” 方法. (别这么干. )在 view-model 上将视图控制器作为一个委托?当 view-model 内容有变化时发个通知?(不不不不. )</p><p>我们的视图控制器会感知一些变化的发生. 我们可以使用从 <code>UITextfield</code> 得来的委托方法在每当有字符变化时通过检查 view-model 来更新按钮的状态.   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//dontDoThisEither.m</div><div class="line">- (void)textFieldDidChange:(UITextField *)sender &#123;</div><div class="line">    // update the view-model</div><div class="line">    self.viewModel.username = sender.text;</div><div class="line">    // check if things are now valid</div><div class="line">    self.goButton.enabled = self.viewModel.isUsernameValid;</div><div class="line">    self.goButton.alpha = self.viewModel.isUsernameValid ? 1.0 : 0.5;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种方法解决的场景是在只有再文本框发生变化时才会影响 view-model 中的 <code>isUsernameValid</code> 值. 假使还有其他变量/动作改变 <code>isUsernameValid</code> 的状态将会怎么样?对于 view-model 中的网络调用会怎么样?或许我们该为 view-model 上的方法加一个完成后回调处理, 这样我们此时就可以更新 UI 的一切东西了?使用珍贵而笨重的 KVO 方法怎么样?</p><p>我们或许最终使用多种多样我们熟悉的机制将 view-model 和视图控制器所有的接触点都连起来, 但你已经知道了<a href="http://www.sprynthesis.com/2014/06/15/why-reactivecocoa/" target="_blank" rel="external">标题上不是这么写的</a>. 这样在代码中创建了大量的入口点, 仅仅为了简单的更新 UI 就要在代码中完全重新创建应用状态上下文. </p><h2 id="进入-ReactiveCocoa"><a href="#进入-ReactiveCocoa" class="headerlink" title="进入 ReactiveCocoa"></a>进入 ReactiveCocoa</h2><p>ReactiveCocoa(RAC) 是来拯救我们的, 并恰好返回给我们一点理智. 让我们看看如何做到.   </p><p>思考在一个新的用户页面上控制信息的流动, 当表单合法时更新提交按钮的状态. 你现在可能会照下面这么做:   </p><p><img src="http://www.sprynthesis.com/assets/images/new-user-form-imperative.svg" alt="">  </p><p>你最后通过使用状态, 小心翼翼地代码中许多不同且零碎无关的内容穿到简单的逻辑上. 看看你信息流中所有不同的入口点?(这还只是<em>一个</em> UI 元素中的<em>一条</em>逻辑线. )<a href="http://www.sprynthesis.com/2014/06/15/why-reactivecocoa/" target="_blank" rel="external">我们程序中现在用的抽象概念还不够厉害</a>, 不能为我们追踪所有事物的关系, 所以我们停止自己去干这蛋疼事儿.   </p><p>让我们看看陈述版本: </p><p><img src="http://www.sprynthesis.com/assets/images/new-user-form-declarative.svg" alt="">  </p><p>这看起来可能像是为我们应用流程文档中的一张老旧的计算机科学图解. 通过陈述式的编程, 我们使用了更高层次的抽象, 来让我们实际编程更靠近我们在脑海中设计流程的方式. 我们让电脑为我们做更多工作. 实际的代码更加像这幅图了.   </p><h3 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h3><p><code>RACSignal</code> (信号)就 RAC 来说是构造单元. 它代表我们最终将要收到的信息. 当你能将未来某时刻收到的消息具体表示出来时, <strong>你可以开始预先(陈述性)运用逻辑并构建你的信息流,</strong>而不是必须等到事件发生(命令式).   </p><p><strong>信号会为了控制通过应用的信息流而获得所有这些异步方法(委托, 回调 block,  通知,  KVO, target/action 事件观察, 等)并将它们统一到一个接口下.</strong>这只是直观理解. 不仅是这些, 因为信息会流过你的应用, 它还提供给你轻松转换/分解/合并/过滤信息的能力.   </p><p><img src="http://www.sprynthesis.com/assets/images/replace-async-tools.svg" alt="">  </p><h4 id="那么什么是信号呢-这是一个信号"><a href="#那么什么是信号呢-这是一个信号" class="headerlink" title="那么什么是信号呢?这是一个信号:"></a>那么什么是信号呢?这是一个信号:</h4><p><img src="http://www.sprynthesis.com/assets/images/signal-no-subscribers.svg" alt="">  </p><p>信号是一个发送一连串值的物体. 但是我们这儿的信号啥也不干, 因为它还没有订阅者. 如果有订阅者监听时(已订阅)信号才会发信息. 它将会向那个订阅者发送0或多个载有数值的”next”事件, 后面跟着一个”complete”事件或一个”error”事件. (信号类似于其他语言/工具包中的 “promise”, 但更强大, 因为它不仅限于向它的订阅者一次只传递一个返回值. )  </p><p><img src="http://www.sprynthesis.com/assets/images/signal-with-subscriber.svg" alt="">  </p><p>正如我之前提到的, 如果觉得需要的话你可以过滤, 转换, 分解和合并那些值. 不同的订阅者可能需要使用信号通过不同方式发送的值.   </p><p><img src="http://www.sprynthesis.com/assets/images/signal-map.svg" alt="">  </p><h4 id="信号发送的值是从哪获得的"><a href="#信号发送的值是从哪获得的" class="headerlink" title="信号发送的值是从哪获得的?"></a>信号发送的值是从哪获得的?</h4><p>信号是一些等待某事发生的异步代码, 然后把结果值发送给它们的订阅者. 你可以用 <code>RACSignal</code> 的类方法 <code>createSignal:</code> 手动创建信号:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//networkSignal.m</div><div class="line">RACSignal *networkSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        NetworkOperation *operation = [NetworkOperation getJSONOperationForURL:@&quot;http://someurl&quot;];</div><div class="line">        [operation setCompletionBlockWithSuccess:^(NetworkOperation *theOperation, id *result) &#123;</div><div class="line">            [subscriber sendNext:result];</div><div class="line">            [subscriber sendCompleted];</div><div class="line">        &#125; failure:^(NetworkOperation *theOperation, NSError *error) &#123;</div><div class="line">            [subscriber sendError:error];</div><div class="line">        &#125;];</div></pre></td></tr></table></figure><p>我在这用一个具有成功和失败 block (伪造)的网络操作创建了一个信号. (如果我想让信号在被订阅时才让网络请求发生, 还可以用 <code>RACSignal</code> 的类方法 <code>defer</code>. )我在成功的 block 里使用提供的 <code>subscriber</code> 对象调用 <code>sendNext:</code> 和 <code>sendCompleted:</code> 方法, 或在失败的 block 中调用 <code>sendError:</code>. 现在我可以订阅这个信号并将在响应返回时接收到 json 值或是 error.   </p><p>幸运的是,  RAC 的创造者实际上使用它们自己的库来创建真的事物(捉摸一下), 所以对于我们在日常需要什么, 他们有很强烈的想法. 他们为我们提供了很多机制, 来从我们通常使用的现存的异步模式中拉取信号. 别忘了如果你有一个没有被某个内建信号覆盖到的异步任务, 你可以<em>很容易地</em>用 <code>createSignal:</code> 或类似方法来创建信号.   </p><p>一个被提供的机制就是 <code>RACObserve()</code> 宏. (如果你不喜欢宏, 你可以简单地看看罩子下面并用稍微多些冗杂的描述. 这也非常好. 在我们得到 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/pull/1382" target="_blank" rel="external">Swift 版本的替代</a>之前, 这也有<a href="http://blog.scottlogic.com/2014/07/24/mvvm-reactivecocoa-swift.html" target="_blank" rel="external">在 Swift 中使用 RAC</a> 的解决方案. )这个宏是 RAC 中对 KVO 中那些悲惨的 API 的替代. 你只需要传入对象和你想观察的那个对象某属性的 keypath. 给出这些参数后,  <code>RACObserve</code> 会创建一个信号, 一旦它有了订阅者, 它就立刻发送那个属性的当前值, 并在发送那个属性在这之后的任何变化.   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RACSignal *usernameValidSignal = RACObserve(self.viewModel,  usernameIsValid);</div></pre></td></tr></table></figure><p><img src="http://www.sprynthesis.com/assets/images/signal-racobserve.svg" alt="">  </p><p>这仅是提供用于创建信号的一个工具. 这里有几个立即可用的方式, 来从内置控制流机制中拉取信号:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//signals.m</div><div class="line">RACSignal *controlUpdate = [myButton rac_signalForControlEvents:UIControlEventTouchUpInside];</div><div class="line">    // signals for UIControl events send the control event value (UITextField, UIButton, UISlider, etc)</div><div class="line">    // subscribeNext:^(UIButton *button) &#123; NSLog(@&quot;%@&quot;, button); // UIButton instance &#125;</div><div class="line"> </div><div class="line">RACSignal *textChange = [myTextField rac_textSignal];</div><div class="line">    // some special methods are provided for commonly needed control event values off certain controls</div><div class="line">    // subscribeNext:^(UITextField *textfield) &#123; NSLog(@&quot;%@&quot;, textfield.text); // &quot;Hello!&quot; &#125;</div><div class="line"> </div><div class="line">RACSignal *alertButtonClicked = [myAlertView rac_buttonClickedSignal];</div><div class="line">    // signals for some delegate methods send the delegate params as the value</div><div class="line">    // e.g. UIAlertView, UIActionSheet, UIImagePickerControl, etc</div><div class="line">    // (limited to methods that return void)</div><div class="line">    // subscribeNext:^(NSNumber *buttonIndex) &#123; NSLog(@&quot;%@&quot;, buttonIndex); // &quot;1&quot; &#125;</div><div class="line"> </div><div class="line">RACSignal *viewAppeared = [self rac_signalForSelector:@selector(viewDidAppear:)];</div><div class="line">    // signals for arbitrary selectors that return void, send the method params as the value</div><div class="line">    // works for built in or your own methods</div><div class="line">    // subscribeNext:^(NSNumber *animated) &#123; NSLog(@&quot;viewDidAppear %@&quot;, animated); // &quot;viewDidAppear 1&quot; &#125;</div></pre></td></tr></table></figure><p>记住你也能轻松创建自己的信号, 包括<a href="http://spin.atomicobject.com/2014/02/03/objective-c-delegate-pattern/" target="_blank" rel="external">替代那些没有内建支持的其他委托</a>. 我们现在能够从所有这些不连贯的异步/控制流工具中拉取出信号并将他们合并, 试想想这该多酷!这些会成为我们之前看到的陈述性图表中的节点. 真是兴奋. </p><h4 id="什么是订阅者"><a href="#什么是订阅者" class="headerlink" title="什么是订阅者?"></a>什么是订阅者?</h4><p>简言之, 订阅者就是一段代码, 它等待信号给它发送一些值, 然后订阅者就能处理这些值了. (它也可以作用于 “complete” 和 “error” 事件. )</p><p>这有一个简单的订阅者, 是通过向信号的实例方法 <code>subscribeNext</code> 传入一个 block 来创建的. 我们在这通过 <code>RACObserve()</code> 宏创建信号来观察一个对象上属性的当前值, 并把它赋值给一个内部属性.   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void) viewDidLoad &#123;</div><div class="line">  // . . . </div><div class="line">  // create and get a reference to the signal</div><div class="line">  RACSignal *usernameValidSignal = RACObserve(self.viewModel,  isUsernameValid);</div><div class="line">  // update the local property when this value changes</div><div class="line">  [usernameValidSignal subscribeNext: ^(NSNumber *isValidNumber) &#123;</div><div class="line">          self.usernameIsValid = isValidNumber. boolValue</div><div class="line">      &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意 RAC 只处理对象, 而不处理像 <code>BOOL</code> 这样的原始值. 不过不用担心,  RAC 通常会帮你这些转换.   </p><p>幸运的是 RAC 的创造者也意识到这种绑定行为的普遍必要性, 所以他们提供了另一个宏 <code>RAC()</code>.  与 <code>RACObserve()</code> 相同, 你提供想要与即将到来的值绑定的对象和参数, 在其内部它所做的是创建一个订阅者并更新其属性的值. 我们的例子现在看起来像这样:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void) viewDidLoad &#123;</div><div class="line">    //. . . </div><div class="line">    RAC(self,  usernameIsValid) = RACObserve(self.viewModel,  isUsernameValid);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>考虑下我们的目标, 这么干有点傻啊. 我们不需要将信号发送的值存到属性中(这会创建状态), 我们真正要做的是用从那个值获取到信息来更新 UI. </p><h4 id="转换数据流"><a href="#转换数据流" class="headerlink" title="转换数据流"></a>转换数据流</h4><p>现在我们进入 RAC 为我们提供的用于转换数值流的方法. 我们将会利用 <code>RACSignal</code> 的实例方法 <code>map</code>. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//transformingStreams.m</div><div class="line">- (void) viewDidLoad &#123;</div><div class="line">    //...</div><div class="line">    RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, isUsernameValid);</div><div class="line">    RAC(self.goButton, enabled) = usernameIsValidSignal;</div><div class="line">    RAC(self.goButton, alpha) = [usernameIsValidSignal</div><div class="line">        map:^id(NSNumber *usernameIsValid) &#123;</div><div class="line">            return usernameIsValid.boolValue ? @1.0 : @0.5;</div><div class="line">        &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样现在我们将 view-model 上的 <code>isUsernameValid</code> 发生的变化直接绑定到 <code>goButton</code> 的 <code>enabled</code> 属性上. 酷吧?对 <code>alpha</code> 的绑定更酷, 因为我们正在使用 <code>map</code> 方法将值转换成与 <code>alpha</code> 属性相关的值. (注意在这里我们返回的是一个 <code>NSNumber</code> 对象而不是原始float值. 这基本上是唯一的污点: 你需要负责为 RAC 将原始值转化为对象, 因为它不能帮你导出来.   </p><h3 id="多个订阅者-副作用-昂贵的操作"><a href="#多个订阅者-副作用-昂贵的操作" class="headerlink" title="多个订阅者, 副作用, 昂贵的操作"></a>多个订阅者, 副作用, 昂贵的操作</h3><p>订阅信号链时要明白重要的一件事是每当一个新值通过信号链被发送出去时, 实际上会给每个订阅者都发送一次. 直到意识到这就我们而言是有意义的, 信号发出的值不存储在任何地方(除了 RAC 在内部实现中). 当信号需要发送一个新的值时, 它会遍历所有的订阅者并给每个订阅者发送那个值. (这是对信号链实际工作的简化说明, 但基本想法是对的)  </p><p>这为什么重要?这意味着信号链某处存在的任何副作用, 任何影响应用世界的转变, 将会发生多次. 这对新接触 RAC 的用户来说是意想不到的. (这也违反了函数式构建的理念-数据输入, 数据输出).   </p><p>一个做作的例子可能是: 信号链某处的信号在每次按钮被按下时更新 <code>self</code> 中的一个计数器属性. 如果信号链有多个订阅者, 计数器的增长将会比你想的还要多. 你需要努力从信号链中尽可能剔除副作用. 当副作用不可避免时, 你可以使用一些恰当的预防机制. 我将会在另一篇文章中探索.   </p><p>除副作用之外, 你需要注意带有昂贵操作和可变数据的信号链. 网络请求就是一个三者兼得的例子:   </p><ol><li>网络请求影响了应用的网络层(副作用). </li><li>网络请求为信号链引入了可变数据. (两个完全一样请求可能返回了不同的数据. )</li><li>网络请求反应慢啊. </li></ol><p>例如, 你可能有个信号在每次按钮按下时发送一个值, 而你想将这个值转换成网络请求的结果. 如果有多个订阅者要这个处理信号链上返回的这个值, 你将发起多个网络请求.   </p><p><img src="http://www.sprynthesis.com/assets/images/signal-side-effect.svg" alt="">  </p><p>网络请求明显是经常需要的. 正如你所期望,  RAC 提供这些情况的解决方案, 也就是 <code>RACCommand</code> 和多点广播. 我将会在下一篇文章中更深入地分析.   </p><h2 id="Tweetboat-Plus"><a href="#Tweetboat-Plus" class="headerlink" title="Tweetboat Plus"></a>Tweetboat Plus</h2><p>既然简短的介绍(嗯哼)扯远了, 让我们着眼于如何用 ReactiveCocoa 将 view-model 与视图控制器连接起来. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// View Controller</div><div class="line">//</div><div class="line"> </div><div class="line">- (void) viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line"> </div><div class="line">    RAC(self.viewModel,  username) = [myTextfield rac_textSignal];</div><div class="line"> </div><div class="line">    RACSignal *usernameIsValidSignal = RACObserve(self.viewModel,  usernameValid);</div><div class="line"> </div><div class="line">    RAC(self.goButton,  alpha) = [usernameIsValidSignal</div><div class="line">        map:  ^(NSNumber *valid) &#123;</div><div class="line">            return valid. boolValue ? @1 :  @0. 5;</div><div class="line">        &#125;];</div><div class="line"> </div><div class="line">    RAC(self.goButton,  enabled) = usernameIsValidSignal;</div><div class="line"> </div><div class="line">    RAC(self.avatarImageView,  image) = RACObserve(self.viewModel,  userAvatarImage);</div><div class="line">    </div><div class="line">    RAC(self.userNameLabel,  text) = RACObserve(self.viewModel,  userFullName);</div><div class="line"> </div><div class="line">    @weakify(self);</div><div class="line">    [[[RACSignal merge: @[RACObserve(self.viewModel,  tweets), </div><div class="line">                        RACObserve(self.viewModel,  allTweetsLoaded)]]</div><div class="line">        bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]]</div><div class="line">        subscribeNext: ^(id value) &#123;</div><div class="line">            @strongify(self);</div><div class="line">            [self.tableView reloadData];</div><div class="line">        &#125;];</div><div class="line">    </div><div class="line">    [[self.goButton rac_signalForControlEvents: UIControlEventTouchUpInside]</div><div class="line">        subscribeNext:  ^(id value) &#123;</div><div class="line">            @strongify(self);</div><div class="line">            [self.viewModel getTweetsForCurrentUsername];</div><div class="line">        &#125;];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">-(UITableViewCell*)tableView: (UITableView *)tableView cellForRowAtIndexPath: (NSIndexPath *)indexPath &#123;</div><div class="line">    // if table section is the tweets section</div><div class="line">    if (indexPath. section == 0) &#123;</div><div class="line">        MYTwitterUserCell *cell =</div><div class="line">        [self.tableView dequeueReusableCellWithIdentifier: @&quot;MYTwitterUserCell&quot; forIndexPath: indexPath];</div><div class="line">        </div><div class="line">        // grab the cell view model from the vc view model and assign it</div><div class="line">        cell.viewModel = self.viewModel. tweets[indexPath. row];</div><div class="line">        return cell;</div><div class="line">    &#125; else &#123;</div><div class="line">        // else if the section is our loading cell</div><div class="line">        MYLoadingCell *cell =</div><div class="line">        [self.tableView dequeueReusableCellWithIdentifier: @&quot;MYLoadingCell&quot; forIndexPath: indexPath];</div><div class="line">        [self.viewModel loadMoreTweets];</div><div class="line">        return cell;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">//</div><div class="line">// MYTwitterUserCell</div><div class="line">//</div><div class="line"> </div><div class="line">// this could also be in cell init</div><div class="line">- (void) awakeFromNib &#123;</div><div class="line">    [super awakeFromNib];</div><div class="line">    </div><div class="line">    RAC(self.avatarImageView,  image) = RACObserve(self,  viewModel. tweetAuthorAvatarImage);</div><div class="line">    RAC(self.userNameLabel,  text) = RACObserve(self,  viewModel. tweetAuthorFullName);</div><div class="line">    RAC(self.tweetTextLabel,  text) = RACObserve(self,  viewModel. tweetContent);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>让我们过一遍这个例子.   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RAC(self.viewModel,  username) = [myTextfield rac_textSignal];</div></pre></td></tr></table></figure><p>在这我们用 RAC 库中的方法从 <code>UITextField</code> 拉取一个信号. 这行代码将 view-model 上的可读写属性 <code>username</code> 绑定到文本框上的用户输入的任何更新.   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">RACSignal *usernameIsValidSignal = RACObserve(self.viewModel,  usernameValid);</div><div class="line"></div><div class="line">RAC(self.goButton,  alpha) = [usernameIsValidSignal</div><div class="line">    map:  ^(NSNumber *valid) &#123;</div><div class="line">        return valid. boolValue ? @1 :  @0. 5;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">RAC(self.goButton,  enabled) = usernameIsValidSignal;</div></pre></td></tr></table></figure><p>在这我们用 <code>RACObserve</code> 方法在 view-model 的 <code>usernameValid</code> 属性上创建了一个信号 <code>usernameIsValidSignal</code>.  无论何时属性发生变化, 它将会沿着管道发送一个新的 <code>@YES</code> 或 <code>@NO</code>. 我们拿到那个值并将其绑定到 <code>goButton</code> 的两个属性上. 首先我们将 <code>alpha</code> 分别对应 YES 或 NO 更新到1或0. 5(记着在这必须返回 <code>NSNumber</code>). 然后我们直接将信号绑定到 <code>enabled</code> 属性, 因为 YES 和 NO 在这无需转换就能完美地运作.   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RAC(self.avatarImageView,  image) = RACObserve(self.viewModel,  userAvatarImage);</div><div class="line"></div><div class="line">RAC(self.userNameLabel,  text) = RACObserve(self.viewModel,  userFullName);</div></pre></td></tr></table></figure><p>下面我们为表头的图像视图和用户标签创建绑定, 再次在 view-model 上对应的属性上用 <code>RACObserve</code> 宏创建信号.   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@weakify(self);</div><div class="line">[[[RACSignal merge: @[RACObserve(self.viewModel,  tweets), </div><div class="line">                     RACObserve(self.viewModel,  allTweetsLoaded)]]</div><div class="line">    bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]]</div><div class="line">    subscribeNext: ^(id value) &#123;</div><div class="line">        @strongify(self);</div><div class="line">        [self.tableView reloadData];</div><div class="line">    &#125;];</div></pre></td></tr></table></figure><p>这货看上去有点诡异, 所以我们在这上多花点时间. 我们想在 view-model 上 <code>tweets</code> 数组或 <code>allTweetsLoaded</code> 属性发生变化时更新表格视图. (在这个例子中, 我们要用一个简单的方法来重新加载整张表. )所以我们将这两个属性被观察后创建的两个信号合并成一个更大的信号, 当两个属性中有一个发生变化, 这个信号就会发送值. (你一贯认为信号的值是同类型的, 不会像这个信号有一样混杂的值. 这很可能在 Swift 版本的 RAC 中强制要求, 但在这我们不关心发出的真实值, 我们只是用它来触发表格式图的重新加载. )  </p><p>那么这儿看起来最吓人的部分可能是信号链中的 <code>bufferWithTime: onScheduler:</code> 方法. 需要它来围绕 UIKit 中的一个问题进行变通.  <code>tweets</code> 和 <code>allTweetsLoaded</code> 这两个属性我们都需要追踪, 万一 <code>tweets</code> 变化和 <code>allTweetsLoaded</code> 为否(不管怎样我们都得重新加载表格). 有时两个属性都将在同一准确的时间发生变化, 意味着合并后的大信号中的两个信号都会发送一个值, 那么 <code>reloadData</code> 方法将会在同一个运行循环中被调用两次.  UIKit 不喜欢这样.  <code>bufferWithTime:</code> 在给明的时间内抓取所有下一个到来的值, 当给定的时间过后将所有值合在一起发给订阅者. 通过传入0作为时间,  <code>bufferWithTime:</code> 将会抓取那个合并信号在特定的运行循环中发出的全部值, 并将他们一起发送出去. (<code>NSTimer</code> 以同样的方式工作, 这不是巧合, 因为 <code>bufferWithTime:</code> 是用 <code>NSTimer</code> 构建的. )暂时不用担心 scheduler, 试把它想做指明这些值必须在主线程上被发送. 现在我们确保 <code>reloadData</code> 每次运行循环只被调用一次.   </p><p><em>注意我在这用 <code>@weakify/@strongify</code> 宏切换 strong 和 weak.  这在创建所有这些 block 时非常重要. 在 RAC 的 block 中使用 <code>self</code> 时<code>self</code> 将会被捕获为强引用并得到保留环, 除非你尤其意识到要破除保留环</em>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[self.goButton rac_signalForControlEvents: UIControlEventTouchUpInside]</div><div class="line">    subscribeNext:  ^(id value) &#123;</div><div class="line">        @strongify(self);</div><div class="line">        [self.viewModel getTweetsForCurrentUsername];</div><div class="line">    &#125;];</div></pre></td></tr></table></figure><p>我将会在下一篇文章中在这里引入 <code>RACCommand</code>,  但目前我们只是当按钮被触碰时手动调用 view-model 的 <code>getTweetsForCurrentUsername</code> 方法.   </p><p>我们已经搞定了 <code>cellForRowAtIndexPath</code> 的第一部分, 那么我在这将只说下 loading cell: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MYLoadingCell *cell =</div><div class="line">    [self.tableView dequeueReusableCellWithIdentifier: @&quot;MYLoadingCell&quot; forIndexPath: indexPath];</div><div class="line">[self.viewModel loadMoreTweets];</div><div class="line">return cell;</div></pre></td></tr></table></figure><p>这是另一块我们以后将利用到 <code>RACCommand</code> 的地方, 但目前我们只是调用 view-model 的 <code>loadMoreTweets</code> 方法. 我们将只是信任如果 cell 显示或隐藏多次的话 view-model 会避免多次内部调用.   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void) awakeFromNib &#123;</div><div class="line">    [super awakeFromNib];</div><div class="line"></div><div class="line">    RAC(self.avatarImageView,  image) = RACObserve(self,  viewModel. tweetAuthorAvatarImage);</div><div class="line">    RAC(self.userNameLabel,  text) = RACObserve(self,  viewModel. tweetAuthorFullName);</div><div class="line">    RAC(self.tweetTextLabel,  text) = RACObserve(self,  viewModel. tweetContent);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段现在应该非常直接了, 除此之外我想指出一点. 我们正在将图片和文字绑定到 UI 上对应的属性, 但注意 <code>viewModel</code> 出现在 <code>RACObserve</code> 宏中逗号右边. 这些 cell 终将被重用, 新的 view-models 将会被赋值. 如果我们不将 <code>viewModel</code> 放在逗号右边, 那就会监听 <code>viewModel</code> 属性的变化然后每次都要重新设置绑定;如果放在逗号右边,  <code>RACObserve</code> 将会为我们负责这些事儿. 因此我们只需要设定一次绑定并让 Reactive Cocoa 做剩余的部分. 这是在绑定表格 cell 时为了性能需要记住的好东西. 我在实践中即使是有很多表格 cell 依然没有出过问题.   </p><h4 id="福利-消除更多的状态"><a href="#福利-消除更多的状态" class="headerlink" title="福利-消除更多的状态"></a>福利-消除更多的状态</h4><p>有时候你可以在 view-model 中暴露 <code>RACSignal</code> 对象来替代像字符串和图像这样的属性, 这能在 view-model 上消除更多的状态. 然后视图控制器就不需要自己用 <code>RACObserve</code> 创建信号了, 并只是直接影响这些信号. 要意识到如果你的信号在被 UI 订阅/绑定到 UI 之前发出过一个值, 那么你将不会收到那个”初始”的值. </p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本文篇幅略长, 但别被吓着. 这还有好多没讲的, 而且是干货儿, 是舒展你大脑的好方法. 这毫无疑问是<em>不同的</em>编程风格. 花一会儿功夫停止机械地试图用命令式方案去解决问题. 即使你一开始不是经常用这种编程风格, 我认为这有助于理解和提醒我们有截然不同的途径来解决我们程序员的困惑.   </p><p>下一次我将稍微深入 view-model 内部中本文没提到的内容, 并介绍下 <code>RACCommand</code>(希望篇幅能短很多). 然后我们将投入到一个真实案例中, 那是我的一个叫做<a href="http://www.threecentsapp.com" target="_blank" rel="external">Three Cents</a>的 app 中的一个相当复杂的页面, 它混合了网络调用, CoreData, 多重 UI 状态, 等等!</p><p><img src="http://www.sprynthesis.com/assets/images/ThreeCentsExplore.gif" alt=""></p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><a href="http://www.objc.io/issue-13/mvvm.html" target="_blank" rel="external">Introduction to MVVM</a> by Ash Furrow</li><li><a href="https://leanpub.com/iosfrp/" target="_blank" rel="external">Functional Reactive Programming on iOS</a> by Ash Furrow</li><li><a href="https://github.com/AshFurrow/C-41" target="_blank" rel="external">A sample app by Ash Furrow</a></li><li><a href="http://cocoamanifest.net/articles/2013/10/mvc-mvvm-frp-and-building-bridges.html" target="_blank" rel="external">MVC,  MVVM,  FRP,  And Building Bridges</a> by Jonathan Penn</li><li><a href="http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa</a> by Colin Eberhardt on the Ray Wenderlich site. </li><li><a href="http://cocoasamurai.blogspot.jp/2013/03/basic-mvvm-with-reactivecocoa.html" target="_blank" rel="external">Basic MVVM with ReactiveCocoa</a> by Colin Wheeler</li><li><a href="http://twocentstudios.com/blog/2014/06/08/on-mvvm-and-architecture-questions/" target="_blank" rel="external">On MVVM,  and Architecture Questions</a> by Chris Trott</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自&lt;a href=&quot;http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReactiveCocoa and MVVM,  an Introduction&lt;/a&gt;. &lt;del&gt;文中引用的 Gist 可能无法显示. 为了和谐社会, 请&lt;a href=&quot;http://tizipro.com/?r=ee0508bc191f5651&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;科学上网&lt;/a&gt;&lt;/del&gt;   &lt;/p&gt;
    
    </summary>
    
    
      <category term="RAC" scheme="http://yoursite.com/tags/RAC/"/>
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>记一次神奇的bug</title>
    <link href="http://yoursite.com/2015/04/26/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A5%9E%E5%A5%87%E7%9A%84bug/"/>
    <id>http://yoursite.com/2015/04/26/记一次神奇的bug/</id>
    <published>2015-04-26T04:25:12.000Z</published>
    <updated>2016-01-26T04:29:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>临近发布,Xcode打出的包在不同的设备效果不同,对比下来发现:<br>iPhone5s及以上完全正常,iphone5及以下部分界面数据显示不完整,非常奇怪; </p><p><strong>过程</strong> </p><p>首先怀疑界面约束问题,因为不同版本的Xcode支持的约束不同,特别排查了那些运行时log提示的那些界面,发现不是根本问题,用FLEX排查,发现控件都存在,真的是数据不见了; 排查中间层返回数据值,JSON一切正常;但是解析出的对象4个属性的确少了一个,定位到网 络解析库; 网络framework库内创建一个demo可运行app,在iPhone5内解析一段JSON,最终定位到一行代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const char *propertyAttributes = property_getAttributes(property);</div><div class="line">&#125;</div><div class="line">BOOL isReadWrite = YES;</div><div class="line">isReadWrite = !(BOOL)strstr(propertyAttributes, &quot;,R&quot;);</div><div class="line">isReadWrite = (BOOL)strstr(propertyAttributes, &quot;,V&quot;);</div><div class="line">if (isReadWrite) &#123;</div><div class="line">//...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码的本意是判断当前属性是否为readonly且不可赋值的属性,不对其进行KVC赋值; 但是这段代码有一个非常严重的问题就是strstr函数的返回其实是匹配字符串的地址,不匹配 返回NULL;<br>既然是地址,强转bool其实是风险的,最终代码修改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const char *propertyAttributes = property_getAttributes(property);</div><div class="line">&#125;</div><div class="line">BOOL isReadWrite = YES;</div><div class="line">isReadWrite = (strstr(propertyAttributes, &quot;,R&quot;) == NULL);</div><div class="line">isReadWrite = (strstr(propertyAttributes, &quot;,V&quot;) != NULL);</div><div class="line">if (isReadWrite) &#123;</div><div class="line">//...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注:判断”,R”是因为调试放着,主要的判断还是”,V”;<br>解析<br>查看BOOL在runtime内的定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/// Type to represent a boolean value.</div><div class="line">#endif</div><div class="line">#if !defined(OBJC_HIDE_64) &amp;&amp; TARGET_OS_IPHONE &amp;&amp; __LP64__</div><div class="line">typedef bool BOOL;</div><div class="line">#else</div><div class="line">typedef signed char BOOL;</div><div class="line">// BOOL is explicitly signed so @encode(BOOL) == &quot;c&quot; rather than &quot;C&quot;</div><div class="line">// ev</div></pre></td></tr></table></figure></p><p>在64位下位bool类型,其他为char;即转换十六进制时,最后2位正好位00,32位下取值为 NO,而64位,非0就是true;<br>这也证明了iphone5及以上正常;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;临近发布,Xcode打出的包在不同的设备效果不同,对比下来发现:&lt;br&gt;iPhone5s及以上完全正常,iphone5及以下部分界面数据显示不完整,非常奇怪; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过程&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;首先怀疑界面约束问题,因为不同版本的Xco
      
    
    </summary>
    
    
      <category term="bug总结" scheme="http://yoursite.com/tags/bug%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>AutoreleasePool剖析</title>
    <link href="http://yoursite.com/2015/04/19/AutoreleasePool%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2015/04/19/AutoreleasePool剖析/</id>
    <published>2015-04-19T14:06:06.000Z</published>
    <updated>2016-01-20T02:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>##概述<br>MRC时代，我们手动管理对象的创建与销毁，OC内部是通过引用计数的机制去管理对象内存。一般我们创建一个对象需要手动retain与release，有时候我们不使用release，而是使用autorelease，当时模糊的概念也就是说这个对象会在稍后某个时候自动释放，无须手动调用release，看上去很神奇，可是一想疑惑很多。到底什么时候释放，它是如何释放的？</p><p>ARC时代之后，我们逐渐抛弃了retain和release等内存管理的操作，把编程的重心放在了代码逻辑上，语言的进化让每个人更专注于自己要实现的功能而更少地关注语言底层的实现细节，我们不用去处理对象的释放问题，那这时候MRC时代的autorelease功能是不是就可以放弃了？</p><p>看似ARC为我们做了一切，实际上苹果只是在编译层面帮我们转换成类似MRC的代码，底层内存管理机制依旧是原来的引用计数那一套。</p><p>##AutoreleasePool原理<br>为了显示调用autoreleasepool，苹果引入了一个block<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"yzj"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//创建的对象都会被丢入pool中</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在该block内创建的对象（非alloc、new、copy、mutableCopy）都会自动调用autorelease方法加入autoreleasepool，在block结束时autoreleasepool自动对丢入pool中的对象执行release方法，使引用计数减1。</p><p>这里有些人会有疑惑了，我要这干嘛呢，普通的{}作用域不也可以干这件事么？{}作用域内创建的变量ARC都会帮我们在{}结尾处插入变量调用的release方法不是么？<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> a = [<span class="built_in">NSObject</span> new];</div><div class="line">    <span class="comment">//[a release];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>看上去类似，但是事实上内部机制完全不同。<br>ARC时代苹果优化了对象创建时的返回值策略，大体上会把下面这段代码改写成另一段代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Jacob *jb = [Jacob new];</div></pre></td></tr></table></figure></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> imp = objc_retainAutoreleasedReturnValue([Jacob new]);</div><div class="line">Jacob *jb = imp;</div></pre></td></tr></table></figure><p>查看objc4对这个方法的定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> </div><div class="line">objc_retainAutoreleaseReturnValue(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(objc_retain(obj));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">id</span> </div><div class="line">objc_autoreleaseReturnValue(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (fastAutoreleaseForReturn(obj)) <span class="keyword">return</span> obj;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> objc_autorelease(obj);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">id</span> objc_autorelease(<span class="keyword">id</span> obj) &#123; <span class="keyword">return</span> [obj autorelease]; &#125;</div></pre></td></tr></table></figure></p><p>我们先来剖析autorelease这个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)autorelease &#123;</div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootAutorelease();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </div><div class="line">objc_object::rootAutorelease()</div><div class="line">&#123;</div><div class="line">    assert(!UseGC);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (fastAutoreleaseForReturn((<span class="keyword">id</span>)<span class="keyword">this</span>)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> rootAutorelease2();</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((noinline,used))</div><div class="line"><span class="keyword">id</span> </div><div class="line">objc_object::rootAutorelease2()</div><div class="line">&#123;</div><div class="line">    assert(!isTaggedPointer());</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((<span class="keyword">id</span>)<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    assert(obj);</div><div class="line">    assert(!obj-&gt;isTaggedPointer());</div><div class="line">    <span class="keyword">id</span> *dest __unused = autoreleaseFast(obj);</div><div class="line">    assert(!dest  ||  *dest == obj);</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>忽略之前的一堆判断条件，最终我们跳转到这里，这里涉及到AutoreleasePoolPage的概念，稍后会详细说明<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> *autoreleaseFast(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *page = hotPage();</div><div class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">        <span class="keyword">return</span> page-&gt;add(obj);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</div><div class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这几个if-else调用的语句最终都会走一个add方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    assert(!full());</div><div class="line">    unprotect();</div><div class="line">    <span class="keyword">id</span> *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></div><div class="line">    *next++ = obj;</div><div class="line">    protect();</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>add方法就是把该对象的指针加入poolpage中，也就是我们理解的把对象加入到autoreleasepool中，那autoreleasepoolpage又是什么鬼？<br>我们来看它的数据结构：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> AutoreleasePoolPage </div><div class="line">&#123;</div><div class="line"><span class="meta">#define POOL_SENTINEL nil//哨兵对象</span></div><div class="line">    <span class="keyword">static</span> pthread_key_t <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;<span class="comment">//TLS用的数组KEY</span></div><div class="line">    <span class="keyword">static</span> uint8_t <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></div><div class="line">    <span class="keyword">static</span> size_t <span class="keyword">const</span> SIZE = </div><div class="line"><span class="meta">#if PROTECT_AUTORELEASEPOOL</span></div><div class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></div><div class="line"><span class="meta">#else</span></div><div class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></div><div class="line"><span class="meta">#endif//page的大小</span></div><div class="line">    <span class="keyword">static</span> size_t <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(<span class="keyword">id</span>);</div><div class="line"></div><div class="line">    magic_t <span class="keyword">const</span> magic;<span class="comment">//校验用的黑魔法</span></div><div class="line">    <span class="keyword">id</span> *next;<span class="comment">//当前page中最新对象的下一个位置</span></div><div class="line">    pthread_t <span class="keyword">const</span> thread;<span class="comment">//当前线程</span></div><div class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;<span class="comment">//前一个page</span></div><div class="line">    AutoreleasePoolPage *child;<span class="comment">//后一个page</span></div><div class="line">    uint32_t <span class="keyword">const</span> depth;<span class="comment">//page的index</span></div><div class="line">    uint32_t hiwat;<span class="comment">//我也不知道这是什么鬼</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>page是一个双链表结构，runtime自己维护这个链表，当往page中插入对象时，会直接插入next的位置，next往后移一位，如果当前page插入对象已满，则新建一个page，index+1，做校验等操作后继续插入新的对象。</p><p>我们把这段代码用编译器重写后看到如下代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</div><div class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</div><div class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</div><div class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* @autoreleasepool */</span> &#123; </div><div class="line">    __AtAutoreleasePool __autoreleasepool; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>相当于在每个autoreleasepool开始和结尾处分别执行了push和pop操作，我们看源代码可以知道，push操作在page中插入一个哨兵对象（nil），当pop的时候，从高地址往低地址对每一个page中的对象执行release操作，直到遇到nil，也就是哨兵对象。这种机制可以实现autoreleasepool的嵌套结构，内层的pool可以不断创建，释放，而不影响外层的pool。从这我们也大致理解了autoreleasepool释放对象的原理。</p><p>最后提两点：<br>1.每一个RunLoop循环开始时会push一个autoreleasepool，结束时会pop一下<br>根据实验可以得出：viewdidload,viewwillappear在一个RunLoop中，viewdidappear在下一个RunLoop中，所以可以解释为什么viewdidload中丢入pool中的对象可以在viewwillappear中拿到，但在viewdidappear中却拿不到。<br>2.数组的这个遍历方法内部会有一个autoreleasepool，每次遍历都会释放当前循环的所有临时变量，内存占用小，所以推荐使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSArray</span> enumerate...^&#123;</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure></p><p>相当于：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSArray</span> enumerate...^&#123;</div><div class="line"><span class="keyword">@autoreleasepool</span>&#123;</div><div class="line"><span class="comment">//inset code</span></div><div class="line">&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##概述&lt;br&gt;MRC时代，我们手动管理对象的创建与销毁，OC内部是通过引用计数的机制去管理对象内存。一般我们创建一个对象需要手动retain与release，有时候我们不使用release，而是使用autorelease，当时模糊的概念也就是说这个对象会在稍后某个时候自动
      
    
    </summary>
    
    
      <category term="iOS AutoreleasePool" scheme="http://yoursite.com/tags/iOS-AutoreleasePool/"/>
    
  </entry>
  
  <entry>
    <title>App与Extensions间通信共享数据</title>
    <link href="http://yoursite.com/2015/04/06/2015-04-06-Communication-between-your-App-and-Extensions/"/>
    <id>http://yoursite.com/2015/04/06/2015-04-06-Communication-between-your-App-and-Extensions/</id>
    <published>2015-04-06T12:30:54.000Z</published>
    <updated>2015-07-21T17:36:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近玩了玩Watch开发，而目前Watch的主要逻辑处理都是放在WatchKit Extension。真正的Host App，也就是WatchKit App只是用来在界面上显示数据的。于是实践了下containing app与app extension之间的通信和数据共享。  </p><a id="more"></a><p>##App Groups &amp; Framework</p><p>这两样兵器大家都很熟悉。想要共享数据就需要开启App Groups，给group起一个风骚的名字，这样无论是<code>NSUserDefaults</code>还是<code>NSFileManager</code>都能通过App Groups共享持久层数据了。Core Data也需要<code>NSFileManager</code>提供存储的URL支持，而存取Core Data中的数据需要大量的模板代码，在持久层文件共享之后，代码也应该做到共享，所以将能够重用的代码打包成Framework就显得尤为重要。(除非是为了做毕设凑代码量)  </p><p>还是以<a href="https://github.com/yulingtianxia/HardChoice" target="_blank" rel="external">HardChoice</a>为例，我新建了一个类型为Cocoa Touch Framework的target，名字叫DataKit。新建一个DataAccess.swift文件并将以前AppDelegate.swift中自动生成的Core Data模版代码转移过来。得益于Swift1.2的改进，构造一个线程安全的单例模式变得无比简单：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private static let instance = DataAccess()</div><div class="line">public class var sharedInstance : DataAccess &#123;</div><div class="line">   return instance</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>需要注意Swift的权限控制问题，我们需要在暴漏给框架使用者的公开接口和属性前加上<code>public</code>关键字修饰。  </p><p>为了实现Core Data持久层共享，需要修改原先的<code>applicationDocumentsDirectory</code>属性：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">lazy var applicationDocumentsDirectory: NSURL = &#123;</div><div class="line">   // The directory the application uses to store the Core Data store file. This code uses a directory named &quot;com.yxy.iCloudCoreDataTest&quot; in the application&apos;s documents Application Support directory.</div><div class="line">   //        let urls = NSFileManager.defaultManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)</div><div class="line">   //        return urls[urls.count-1] as! NSURL</div><div class="line">   var sharedContainerURL:NSURL? = NSFileManager.defaultManager().containerURLForSecurityApplicationGroupIdentifier(appGroupIdentifier)</div><div class="line">   return sharedContainerURL ?? NSURL()</div><div class="line">   &#125;()</div></pre></td></tr></table></figure><p>在这里<code>containerURLForSecurityApplicationGroupIdentifier</code>方法起到了至关作用。  </p><p>同样能够共享的代码就是Model层，它们都是<code>NSManagedObject</code>的子类，用于存储Core Data中的数据实例。在把它们从原来的位置拖拽过来时别忘了更改下文件的target：”File inspector”-&gt;”Target Membership”，选中DataKit。  </p><p>在处理iCloud与Core Data同步数据时，我对<code>NSPersistentStoreCoordinatorStoresWillChangeNotification</code>、<code>NSPersistentStoreCoordinatorStoresDidChangeNotification</code>和<code>NSPersistentStoreDidImportUbiquitousContentChangesNotification</code>这三个数据更新的通知进行了观察和处理，但是写在了<code>persistentStoreCoordinator</code>计算属性的get方法中。现在使用<code>lazy</code>关键字进行惰性加载，导致对这三个数据更新通知的观察延后，这会引发严重的错误。所以需要将那三个<code>addObserverForName(name, object, queue, usingBlock)</code>方法挪到<code>init()</code>方法中，在第一时间观察通知。</p><p>最后在AppDelegate.swift中添加<code>import DataKit</code>，替换掉中的<code>application(application, didFinishLaunchingWithOptions) -&gt; Bool</code>方法中<code>controller.managedObjectContext = managedObjectContext</code>为<code>controller.managedObjectContext = DataAccess.sharedInstance.managedObjectContext</code>，也就是不再使用以前的模板代码中的上下文实例，而是用DataAccess单例中的<code>managedObjectContext</code>。  </p><p>同理，<code>applicationWillTerminate(application)</code>方法中的<code>saveContext()</code>也要替换成<code>DataAccess.sharedInstance.saveContext()</code>。  </p><p>于是我们也可以在App Extensions中import进来DataKit，进行地存取Core Data中的数据啦。而且用的是同一段代码，同一块数据。简直是同一个世界，同一个梦想啊。  </p><p>##Container app 与 Extension的通信  </p><p>要知道之前做的共享数据只能是主动获取数据，并不能在数据变化时实时获取通知。如果用户在iPhone上更改了数据，我们需要在Watch上实时更改界面上数据的显示。这点<code>NSNotificationCenter</code>是做不到的，因为它只在App内部工作而不会在两个App之间发通知。同样KVO也无能为力，自己手写委托什么的更是别想了(因为我试过了)。直到我在<a href="https://medium.com/@saberjack/ios-sending-notifications-between-your-apps-3fe7422d6a41" target="_blank" rel="external">这篇文章</a>找到了救世主，问题迎刃而解：  </p><p>###CFNotificationCenterGetDarwinNotifyCenter</p><p>这是CoreFoundation库中一个系统级的通知中心，苹果的系统自己也在用它，看清了”Darwin”了没有？哈哈！看了下<code>CFNotificationCenter</code>相关的API，跟<code>NSNotificationCenter</code>有点像。需要用到Toll-Bridge的知识与CoreFoundation相关的类进行桥接，这虽不常用但也不难。还需要注意下个别参数的使用。  </p><p>###MMWormhole</p><p>更有趣的是几乎同时我也发现了<a href="https://github.com/mutualmobile/MMWormhole" target="_blank" rel="external">MMWormhole</a>这个开源库，它专门用于在Container app 与 Extension间传递消息。我读了下它的代码，虽然只有一个类，但是依然学到了很多。虽然在我的<a href="https://github.com/yulingtianxia/HardChoice" target="_blank" rel="external">HardChoice</a>上完全可以只用<code>CFNotificationCenter</code>进行通知就可以了，完全不需要使用MMWormhole来持久化数据和传递数据。但我觉得以后还可能会用到MMWormhole，于是我用Swift1.2重新写了一个<a href="https://github.com/yulingtianxia/HardChoice/blob/master/HardChoice/DataKit/Wormhole.swift" target="_blank" rel="external">Wormhole.swift</a>，放在了DataKit里。  </p><p>###Swift与CoreFoundation</p><p>原来OC写的两百多行的MMWormhole被我用150行“清新优雅”的Swift代码取代。之所以打上引号是因为Swift与CoreFoundation之间的桥接有些不愉快。因为CoreFoundation中都是C的API，C中的指针和类型转换很出格，有安全隐患。Swift是一门安全的语言，但为了调用由历史原因造成的不安全的C的API，Swift中引入了很多类型来映射C中的类型，参考<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-XID_11" target="_blank" rel="external">Interacting with C APIs</a>  </p><p>Swift中不用像OC那样使用<code>__bridge</code>和类型转换、内存管理交接，因为这些全都交给Swift了：如果Swift中存在类型映射到C的API所需的参数类型，那么可以直接将其传入API。此外内存管理也归Swift中的ARC统一管理。于是Swift大大简化了与CoreFoundation打交道的过程。  </p><p>我们最关心的是指针，<code>UnsafePointer&lt;SwiftType&gt;</code>对应了<code>const CType *</code>，<code>UnsafeMutablePointer&lt;SwiftType&gt;</code>对应了<code>CType *</code>。当然SwiftType与CType也是对应的：  </p><table><thead><tr><th>C Type</th><th style="text-align:center">Swift Type</th></tr></thead><tbody><tr><td>bool</td><td style="text-align:center">CBool</td></tr><tr><td>char, signed char</td><td style="text-align:center">CChar</td></tr><tr><td>unsigned char</td><td style="text-align:center">CUnsignedChar</td></tr><tr><td>short</td><td style="text-align:center">CShort</td></tr><tr><td>unsigned short</td><td style="text-align:center">CUnsignedShort</td></tr><tr><td>int</td><td style="text-align:center">CInt</td></tr><tr><td>unsigned int</td><td style="text-align:center">CUnsignedInt</td></tr><tr><td>long</td><td style="text-align:center">CLong</td></tr><tr><td>unsigned long</td><td style="text-align:center">CUnsignedLong</td></tr><tr><td>long long</td><td style="text-align:center">CLongLong</td></tr><tr><td>unsigned long long</td><td style="text-align:center">CUnsignedLongLong</td></tr><tr><td>wchar_t</td><td style="text-align:center">CWideChar</td></tr><tr><td>char16_t</td><td style="text-align:center">CChar16</td></tr><tr><td>char32_t</td><td style="text-align:center">CChar32</td></tr><tr><td>float</td><td style="text-align:center">CFloat</td></tr><tr><td>double</td><td style="text-align:center">CDouble</td></tr></tbody></table><p>更多的转换规则，在上面提到的官方文档有很详细的描述，这里只说三个tips：  </p><ol><li>在Swift中将<code>self</code>转成<code>UnsafePointer&lt;Void&gt;</code>(也就是<code>const void *</code>)只需用这个函数：<code>unsafeAddressOf(self)</code>  </li><li>CoreFoundation库中后缀为”Ref”的类在Swift中已经去掉后缀。  </li><li>Swift中函数指针被表示为<code>CFunctionPointer&lt;Type&gt;</code>，Type就是函数的类型，但还不允许你将Swift写的函数或闭包转化成<code>CFunctionPointer</code>，也就是干脆没提供建立<code>CFunctionPointer</code>实例的方法，只能通过外部引入C的函数。这就涉及到了Swift与OC混编，请戳<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_77" target="_blank" rel="external">Swift and Objective-C in the Same Project</a>  </li></ol><p>###在Framework中混编OC</p><p>我之所以需要做这种破坏工程纯洁性的事儿，是因为要用到下面这个方法来对通知进行观察：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func CFNotificationCenterAddObserver(center: CFNotificationCenter!, observer: UnsafePointer&lt;Void&gt;, callBack: CFNotificationCallback, name: CFString!, object: UnsafePointer&lt;Void&gt;, suspensionBehavior: CFNotificationSuspensionBehavior)</div></pre></td></tr></table></figure><p>除了类型为<code>CFNotificationCallback</code>的参数，其余的都好说：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typealias CFNotificationCallback = CFunctionPointer&lt;((CFNotificationCenter!, UnsafeMutablePointer&lt;Void&gt;, CFString!, UnsafePointer&lt;Void&gt;, CFDictionary!) -&gt; Void)&gt;</div></pre></td></tr></table></figure><p>于是就回到了<code>CFunctionPointer</code>这块蛋疼地上了，只好在OC里写C函数然后调用之：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static NSString * const WormholeNotificationName = @&quot;WormholeNotificationName&quot;;</div><div class="line">@implementation HelpMethod</div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _callback = wormholeNotificationCallback;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">void wormholeNotificationCallback(CFNotificationCenterRef center,</div><div class="line">                                  void * observer,</div><div class="line">                                  CFStringRef name,</div><div class="line">                                  void const * object,</div><div class="line">                                  CFDictionaryRef userInfo) &#123;</div><div class="line">    NSString *identifier = (__bridge NSString *)name;</div><div class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:WormholeNotificationName</div><div class="line">                                                        object:nil</div><div class="line">                                                      userInfo:@&#123;@&quot;identifier&quot; : identifier&#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure><p>然后在Swift中这样写就可以了：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFNotificationCenterAddObserver(center, unsafeAddressOf(self), helpMethod.callback, identifier, nil, CFNotificationSuspensionBehavior.DeliverImmediately)</div></pre></td></tr></table></figure><p>在Swift中使用OC写的类本来是一件很easy的事儿，但是到了Framework中就变得不寻常。我在DataKit中新建了<code>HelpMethod</code>类，并建立”DataKit-Bridging-Header.h”文件，将HelpMethod.h头文件引入，然后在DataKit target下的”Build Settings” -&gt; “Swift Complier-Code Generation” -&gt; “Objective-C Bridging Header”下填入”DataKit-Bridging-Header.h”，编译出错：<strong>using bridging headers with framework targets is unsupported</strong>。  </p><p>在stackoverflow上找到了<a href="http://stackoverflow.com/questions/24875745/xcode-6-beta-4-using-bridging-headers-with-framework-targets-is-unsupported" target="_blank" rel="external">解决方案</a>，于是删除之前的”DataKit-Bridging-Header.h”文件并清除”Build Settings”关于Bridging Header的引用；在DataKit.h添加<code>#import &quot;HelpMethod.h&quot;</code>，并在HelpMethod.h文件的 “File inspector”-&gt;”Target Membership”中DataKit右侧将”project”修改为”public”(否则会出现<strong>include of non-modular header inside framework module ‘DataKit’</strong>的编译错误)。  </p><p>至此，我们可以在<code>HelpMethod</code>类中实现一个函数指针，并在Wormhole.swift文件中直接使用这个函数指针来为<code>CFunctionPointer</code>类型的参数传值。  </p><p>##总结</p><p>来个效果图：  </p><p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/hardchoice.gif" alt="">  </p><p>这是我第一次写Watch的App(废话谁不是第一次)，经验并不是很多，也因为Swift1.2还未正式发布，遇到了一些坑。好歹最后克服了，但也丢了贞操(毕竟不是纯Swift的App了)。有不对的地方还请多多指教。随着Swift的不断完善，希望以后能够支持创建<code>CFunctionPointer</code>对象，这样它好我也好😄</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近玩了玩Watch开发，而目前Watch的主要逻辑处理都是放在WatchKit Extension。真正的Host App，也就是WatchKit App只是用来在界面上显示数据的。于是实践了下containing app与app extension之间的通信和数据共享。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
      <category term="AppGroups" scheme="http://yoursite.com/tags/AppGroups/"/>
    
      <category term="App Extensions" scheme="http://yoursite.com/tags/App-Extensions/"/>
    
  </entry>
  
  <entry>
    <title>Null 和 nullptr</title>
    <link href="http://yoursite.com/2015/03/08/2015-03-08-Insight-of-Null/"/>
    <id>http://yoursite.com/2015/03/08/2015-03-08-Insight-of-Null/</id>
    <published>2015-03-08T12:06:02.000Z</published>
    <updated>2016-01-19T13:04:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>斗战胜佛传记。。。  </p><a id="more"></a><p>##NULL和nullptr</p><p>在Clang 6.0 的stddef.h文件中可以找到<code>NULL</code>和<code>nullptr</code>的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#undef NULL</div><div class="line">#ifdef __cplusplus</div><div class="line">#  if !defined(__MINGW32__) &amp;&amp; !defined(_MSC_VER)</div><div class="line">#    define NULL __null</div><div class="line">#  else</div><div class="line">#    define NULL 0</div><div class="line">#  endif</div><div class="line">#else</div><div class="line">#  define NULL ((void*)0)</div><div class="line">#endif</div><div class="line"></div><div class="line">#ifdef __cplusplus</div><div class="line">#if defined(_MSC_EXTENSIONS) &amp;&amp; defined(_NATIVE_NULLPTR_SUPPORTED)</div><div class="line">namespace std &#123; typedef decltype(nullptr) nullptr_t; &#125;</div><div class="line">using ::std::nullptr_t;</div><div class="line">#endif</div><div class="line">#endif</div></pre></td></tr></table></figure><p>早在1972年，C语言诞生的初期，常数0带有常数及空指针的双重身分。 C使用preprocessor macro <code>NULL</code>表示空指针，让<code>NULL</code>及<code>0</code>分别代表空指针及常数0。 <code>NULL</code>可被定义为<code>((void*)0)</code>或是<code>0</code>。</p><p>C++并不采用C的规则，不允许将<code>void*</code>隐式转换为其他类型的指针。为了使代码<code>char* c = NULL;</code>能通过编译，<code>NULL</code>只能定义为<code>0</code>。这样的决定使得函数重载无法区分代码的语义：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void foo(char *);</div><div class="line">void foo(int);</div></pre></td></tr></table></figure><p>C++建议<code>NULL</code>应当定义为<code>0</code>，所以<code>foo(NULL);</code>将会调用<code>foo(int)</code>，这并不是程序员想要的行为，也违反了代码的直观性。0的歧义在此处造成困扰。</p><p>C++11引入了新的关键字来代表空指针常数：<code>nullptr</code>，将空指针和整数0的概念拆开。 <code>nullptr</code>的类型为<code>nullptr_t</code>，能隐式转换为任何指针或是成员指针的类型，也能和它们进行相等或不等的比较。而<code>nullptr</code>不能隐式转换为整数，也不能和整数做比较。</p><p>为了向下兼容，<code>0</code>仍可代表空指针常数。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">char* pc = nullptr;     // OK</div><div class="line">int * pi = nullptr;     // OK</div><div class="line">int    i = nullptr;     // error</div><div class="line"> </div><div class="line">foo(pc);           // 呼叫foo(char *)</div></pre></td></tr></table></figure><p>PS：<code>__MINGW32__</code>是MinGW编译器的预定义宏。<code>_MSC_VER</code>是微软C/C++编译器——cl.exe 编译代码时预定义的一个宏。<code>_MSC_VER</code>的值表示cl的版本。需要针对cl特定版本编写代码时，也可以使用该宏进行条件编译。</p><p>##nil和Nil</p><p>###Objective-C</p><p><code>nil</code>定义为实例对象的空值(a null instance)<br><code>Nil</code>定义为类对象的空值(a null class)<br><code>nil</code>和<code>Nil</code>在objc.h和MacTypes.h文件中均有等价的声明：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#ifndef Nil</div><div class="line"># if __has_feature(cxx_nullptr)</div><div class="line">#   define Nil nullptr</div><div class="line"># else</div><div class="line">#   define Nil __DARWIN_NULL</div><div class="line"># endif</div><div class="line">#endif</div><div class="line"></div><div class="line">#ifndef nil</div><div class="line"># if __has_feature(cxx_nullptr)</div><div class="line">#   define nil nullptr</div><div class="line"># else</div><div class="line">#   define nil __DARWIN_NULL</div><div class="line"># endif</div><div class="line">#endif</div></pre></td></tr></table></figure><p>根据Clang 3.7 文档对<code>__has_feature</code>的描述: “<code>__has_feature</code> evaluates to 1 if the feature is both supported by Clang and standardized in the current language standard or 0 if not”，<code>__has_feature(cxx_nullptr)</code>是用来判断是否支持C++11中的<code>nullptr</code>特性的。在Objective-C中<code>nil</code>和<code>Nil</code>都是<code>__DARWIN_NULL</code>宏定义。按住CMD鼠标点击进入<code>_types.h</code>:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#ifdef __cplusplus</div><div class="line">#ifdef __GNUG__</div><div class="line">#define __DARWIN_NULL __null</div><div class="line">#else /* ! __GNUG__ */</div><div class="line">#ifdef __LP64__</div><div class="line">#define __DARWIN_NULL (0L)</div><div class="line">#else /* !__LP64__ */</div><div class="line">#define __DARWIN_NULL 0</div><div class="line">#endif /* __LP64__ */</div><div class="line">#endif /* __GNUG__ */</div><div class="line">#else /* ! __cplusplus */</div><div class="line">#define __DARWIN_NULL ((void *)0)</div><div class="line">#endif /* __cplusplus */</div></pre></td></tr></table></figure><p>因为Objective-C不是C++代码，所以倒数第二行<code>#define __DARWIN_NULL ((void *)0)</code>此时高亮，意味着最终<code>nil</code>和<code>Nil</code>本质都为<code>((void *)0)</code>  </p><p>PS：其实如果只看Objective-C中的<code>nil</code>和<code>Nil</code>定义不用这么麻烦的，只需查看Objective-C Runtime Reference中的”Constants-&gt;Null Values”即可。  </p><p>###Swift</p><p>Swift 1.2 目前只有<code>nil</code>而没有<code>Nil</code>。为了安全性Swift新增了<code>Optional</code>类型来作为一个容器。好比一个箱子里面可能装有某种类型的对象，也可能是空的(<code>nil</code>)。箱子也可以嵌套，也可以去掉，但这都基于安全的解析、绑定等。Swift 的nil和 Objective-C 中的nil并不一样。在 Objective-C 中，<code>nil</code>是一个指向不存在对象的指针。在 Swift 中，<code>nil</code>不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选值都可以被设置为<code>nil</code>，不只是对象（object）类型。  </p><p>PS:有关Swift中的<code>Optional</code>类型的更多信息可以参考我的另一篇博文：<a href="http://yulingtianxia.com/blog/2014/06/17/optionals-and-optional-chaining-in-swift/#Nil_Coalescing_Operator" target="_blank" rel="external">Optionals and Optional Chaining in Swift</a>  </p><p>PS：曾几何时，Swift的<code>nil</code>还不是字面量，而是<code>NilType</code>类型的唯一实例。但这一切都是历史了。  </p><p>##NSNull<br><code>NSNull</code>在NSNull.h中的定义：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface NSNull : NSObject &lt;NSCopying, NSSecureCoding&gt;</div><div class="line"></div><div class="line">+ (NSNull *)null;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure><p><code>NSNull</code>是个单例，只有一个方法<code>null</code>，也用来表示空值。但它出现在一些<code>nil</code>无法胜任的场景来替代<code>nil</code>来表示空值。比如<code>NSArray</code>和<code>NSDictionary</code>中<code>nil</code>代表数组或字典的末尾(即使<code>nil</code>不出现在末尾，也会将其切断，<code>nil</code>后面的值会丢失)，此时只能用NSNull对象来表示空值：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSNull *nullValue = [NSNull null];</div><div class="line">NSArray *arrayWithNull = @[nullValue];</div><div class="line">NSLog(@&quot;arrayWithNull: %@&quot;, arrayWithNull);</div><div class="line">// Output: &quot;arrayWithNull: (&lt;null&gt;)&quot;</div></pre></td></tr></table></figure><p>虽然<code>NSNull</code>语义上等同于<code>nil</code>，但却并不完全等于<code>nil</code>：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">id aValue = [arrayWithNull objectAtIndex:0];</div><div class="line">if (aValue == nil) &#123;</div><div class="line">    NSLog(@&quot;equals nil&quot;);</div><div class="line">&#125;</div><div class="line">else if (aValue == [NSNull null]) &#123;</div><div class="line">    NSLog(@&quot;equals NSNull instance&quot;);</div><div class="line">    if ([aValue isEqual:nil]) &#123;</div><div class="line">        NSLog(@&quot;isEqual:nil&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// Output: &quot;equals NSNull instance&quot;</div></pre></td></tr></table></figure><p>##参考</p><ul><li><a href="http://zh.wikipedia.org/wiki/C%2B%2B11#.E9.80.9A.E7.94.A8.E6.99.BA.E8.83.BD.E6.8C.87.E9.87.9D" target="_blank" rel="external">维基百科C++11</a></li><li><a href="http://clang.llvm.org/docs/LanguageExtensions.html#langext-has-feature-back-compat" target="_blank" rel="external">Clang 3.7 documentation</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;斗战胜佛传记。。。  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MOVE结构梳理</title>
    <link href="http://yoursite.com/2015/03/06/%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2015/03/06/代码结构/</id>
    <published>2015-03-05T16:00:20.000Z</published>
    <updated>2016-01-20T03:06:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>###说明<br>MOVE，理解为 Models（模型）、Operations（操作）、Views（视图）、Events（事件）</p><p>###目录结构<br>shell $: tree  </p><p>###MOVE</p><ul><li><p>Models<br>, 封装应用程序中知道的一切 </p></li><li><p>Operations<br>, 封装应用程序要做的一切  </p></li><li><p>Views<br>, 完成用户和应用程序的交互处理  </p></li><li><p>Events<br>, 用于安全的链接所有的这些组件  </p></li></ul><ul><li><p>为了避免面条式的代码组织方式，我们需要制定哪种类型的对象进行操作是允许的。例如，视图允许监听由模型产生的事件；操作允许修改模型，但模型<br>不允许涉及视图或操作。  </p></li><li><p>Models(模型)<br>这里以一个 ‘User’ 对象为原型，它至少应用有一个 Email 地址，也可能有用户名和电话号码。</p></li></ul><p>在一个 MOVE 模式的 Models 中只包装知识。这意味着除了 Get 和 Set 功能，它们可以包含检查用户密码是否正确这样的方法，但不会包含把密码保存到数据库或传递给外部 API 这样的功能，因为后面这些工作将由 Operations 来完成。</p><ul><li>Operations（操作）<br>对应用程序来说，一个常见的操作是用户登陆。这实际上是由两个子操作组成：首先从用户那里获得邮件地址和密码，然后从数据库载入 ‘user’ 模型并检查密码是否匹配。</li></ul><p>Operations 是 MOVE 模式中的行动者。它负责修改模型，在正确的时间显示正确的视图，以及响应由用户交互引发的事件。在一个分解良好的应用程序中，每个子操作都可以独立运行。</p><p>采用这种方式的操作有一点很令人振奋，即程序启动后，整个应用本身就可以被当作一个 Operations。它会根据需要生成尽可能多的子操作，其中每个子操作都并行地运行。当所有子操作都完成时，程序也便退出。</p><ul><li>Views（视图）<br>登陆页面即是一个视图，它负责显示一些文本框给用户。当用户点击 “登陆” 按钮时，视图将产生一个 ‘loginAttempt’ 事件，其中包含用户输入的用户名和密码。</li></ul><p>用户能够看到的内容，以及能感受到的互动都由视图提供支持。它们会以一种用户能理解的形式呈现应用反馈，同时还能将简单的用户交互转换成有意义的事件。更重要的是视图不会直接改变模型，它们只是向 Operations 发起事件，然后通过监听等待由模型发起的事件。</p><ul><li>Events（事件）<br>当用户登陆时，视图会发起 ‘loginAttempt’ 事件。在登陆操作完成后，’currentUser’ 模型会发起一个事件通知应用登陆状态已改变。</li></ul><p>事件监听让 MOVE（及 MVC）实现控制反转，允许模型更新视图。这是一种强大的抽象技巧，允许组件互不干扰地耦合在一起。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###说明&lt;br&gt;MOVE，理解为 Models（模型）、Operations（操作）、Views（视图）、Events（事件）&lt;/p&gt;
&lt;p&gt;###目录结构&lt;br&gt;shell $: tree  &lt;/p&gt;
&lt;p&gt;###MOVE&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Models&lt;
      
    
    </summary>
    
    
      <category term="架构谈" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>UIDynamics in Swift</title>
    <link href="http://yoursite.com/2015/03/01/2015-03-01-UIDynamics-in-Swift/"/>
    <id>http://yoursite.com/2015/03/01/2015-03-01-UIDynamics-in-Swift/</id>
    <published>2015-03-01T06:46:51.000Z</published>
    <updated>2016-01-19T13:03:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自<a href="http://www.bignerdranch.com/blog/uidynamics-in-swift/" target="_blank" rel="external">BigNerdRanch</a>，作者<a href="http://www.bignerdranch.com/about-us/nerds/steve-sparks/" target="_blank" rel="external">Steve Sparks</a><br><a id="more"></a>  </p><p>就像我们几乎所有的iOS开发者那样，我也玩了玩Swift。现在谈及它在我iOS开发任务中的作用还为时过早，因为它对于应用的生产环境的使用还有些不成熟。（WWDC一周过后，苹果就重新构造了数组的运作方式。那可是数组啊！）  </p><p>然而，在WWDC之前，我一直在使用UIDynamics，所以我踏上Swift的第一步便是尝试用这方面的知识，这似乎合乎逻辑。结论是，Swift中的UIDynamics跟在Objective-C中使用没啥差别。我们只需要将其套上Swift风格的养分，它会像我们预期的那样奏效。  </p><p>为了示范，我们匆匆拼凑了一个敏捷工程。使用Xcode 6，创建了一个新的Swift单视图工程。我称它是我的“<a href="https://github.com/stevesparks/RockBox" target="_blank" rel="external">Rock Box</a>”。  </p><p><img src="http://www.bignerdranch.com/img/blog/2014/07/newproj.jpg" alt="">  </p><p>我们无需用到Storyboard，所以我们直接在<code>ViewController.swift</code>文件中加入下面的代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var box : UIView?</div><div class="line"></div><div class="line">func addBox(location: CGRect) &#123;</div><div class="line">   let newBox = UIView(frame: location)</div><div class="line">   newBox.backgroundColor = UIColor.redColor()</div><div class="line"></div><div class="line">   view.insertSubview(newBox, atIndex: 0)</div><div class="line">   box = newBox</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们在<code>viewDidLoad()</code>中加上一行代码来调用它。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">override func viewDidLoad() &#123;</div><div class="line">   super.viewDidLoad()</div><div class="line">   // Do any additional setup after loading the view, typically from a nib.</div><div class="line">   addBox(CGRectMake(100, 100, 30, 30))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行程序，会看到一个红色的箱子：  </p><p><img src="http://www.bignerdranch.com/img/blog/2014/07/initial.png" alt="">  </p><p>它不动；啥都没动。那也太无聊了。我们设置它动起来吧。  </p><p>##魁首：UIDynamicAnimator</p><p>这出戏的魁首是<code>UIDynamicAnimator</code>。按照给出的一系列规则，animator在屏幕每次重绘时调整每个物体的位置。就其本身而言，animator根本不执行任何操作；它需要的规则被称为行为（behavior）。行为描述的事物类似于一个冲量，例如推一下，或重力那种持久的力。你也可以指定它们的摩擦力，弹力等等。animator不做任何对自己制定的规则；它只是魁首。我们在下一节将会声明它的一个实例。  </p><p>##最简单的行为：UIGravityBehavior</p><p>让我们从一个重力行为开始，结果便是我们的红色箱子掉落到屏幕底部。它是从概念上最容易理解的行为了；一个已知方向的拉力会在每个时钟周期向物体施加速度。我们打算施加垂直向下的重力。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var animator:UIDynamicAnimator? = nil;</div><div class="line">let gravity = UIGravityBehavior()</div><div class="line"></div><div class="line">func createAnimatorStuff() &#123;</div><div class="line">   animator = UIDynamicAnimator(referenceView:self.view);</div><div class="line">   animator?.addBehavior(collider)</div><div class="line"></div><div class="line">   gravity.addItem(box);</div><div class="line">   gravity.gravityDirection = CGVectorMake(0, 0.8)</div><div class="line">   animator?.addBehavior(gravity);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>重要的是注意<code>UIDynamicAnimator</code>后面标记的问号意思是变量可能为<code>nil</code>。事实上，我就在这里把它设为<code>nil</code>。原因有些微妙：  </p><ul><li>animator是在类中声明的，这意味着当view controller的<code>init</code>调用时必需对其进行赋值。</li><li><code>self.view</code> 必须在 <code>init</code> 之后调用。</li><li>animator的构造器需要一个视图作为它的参照视图，而且这个值将会是<code>self.view</code>。</li></ul><p>因为我们已经在这酿造了一个鸡生蛋的问题，我们不会允许此变量为<code>nil</code>，并且在<code>viewDidLoad()</code>期间将其设定好。这引入了一些波折，任何时间我们使用<code>animator</code>变量，都将发现我们不得不亲自确保在使用之前它的值不是<code>nil</code>。这在Swift中被处理成在<code>animator</code>后面用一个问号标记，比如<code>animator?.behaviors()</code>。我们将会讨论更多些这方面的内容。暂且让我们向<code>viewDidLoad</code>加点代码来调用我们的新方法…  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    addBox(CGRectMake(100, 100, 30, 30))</div><div class="line">        createAnimatorStuff()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>…编译运行。它看起来是这样的：  </p><p><img src="http://www.bignerdranch.com/img/blog/2014/07/round1.gif" alt="">  </p><p>嗯，真有趣…就一会儿，它立刻跌出了底部。  </p><p>##反弹的墙壁：UICollisionBehavior</p><p><code>UICollisionBehavior</code>关注担心物体是否会在它们的轨迹上碰撞，如果碰撞，它们怎么相互作用。除了让物体互相碰撞，它也推断边界，也就是类似物体边框的路径。（使用<code>let</code>）声明一个<code>UICollisionBehavior</code>常量，并把它添加到设置代码中：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">collider.addItem(box)</div><div class="line">// 我们在反弹墙壁</div><div class="line">collider.translatesReferenceBoundsIntoBoundary = true</div><div class="line">animator?.addBehavior(collider)</div></pre></td></tr></table></figure><p>运行，看看得到了什么？  </p><p><img src="http://www.bignerdranch.com/img/blog/2014/07/round2.gif" alt="">  </p><p>更棒了！箱子掉落并停在“地板”上，甚至还有点弹性！  </p><p>我们稍微重构一下，我想要看到更多箱子。我们创建了一个函数用于找到随机边框但又不压在之前绘制的箱子上，还有另一个产生随机颜色的函数。我们一旦有了这些，就能在屏幕上随机创建十个箱子。其实要做的还有很多，所以直接查看<a href="https://github.com/stevesparks/RockBox/commit/97b87458b5911f880f30179ee0630f933b48bbf5" target="_blank" rel="external">这个commit</a>来看看都做了什么。感兴趣的细节是，调用<code>createAnimatorStuff()</code>时我们不再将箱子加到行为中，而是单独地调用<code>addBoxToBehaviors(box)</code>来添加箱子。  </p><p>现在我们有10个箱子并能相互碰撞！  </p><p><img src="http://www.bignerdranch.com/img/blog/2014/07/round3.gif" alt="">  </p><p>但是它们做的还是不够好。我们为啥不将环境重力绑定到从加速计读取到的重力上呢？  </p><p>##Core Motion</p><p>iOS设备的加速计能做一堆巧活儿，这其中最常见的就是告诉我们重力向哪个方向牵引。<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIAcceleration_Class/index.html" target="_blank" rel="external">苹果关于 <code>UIAcceleration</code> 的文档</a>在一开始就给出了一张示范坐标轴如何转化到设备上的图片：  </p><p><img src="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIAcceleration_Class/Art/device_axes.jpg" alt="">  </p><p>这些坐标轴相当于重力的方向…基本上。我已经发现Y轴貌似被翻转了。照此，当我将<code>CMAcceleration</code>值转化成<code>CGVector</code>时，我需要转换它的值。  </p><p>创建一个<code>CMMotionManager</code>使我们获得加速计的数据的入口。我们可以自己查询加速计数据，也可以要求管理者频繁地向我们发送更新。为了做到这点，我们创建一个<code>NSOperationQueue</code>，然后调用运动管理者的方法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">motionManager.startDeviceMotionUpdatesToQueue(motionQueue,</div><div class="line">                                 withHandler: gravityUpdated)</div></pre></td></tr></table></figure><p>这应该放在<code>viewDidAppear</code>方法，在<code>viewWillDisappear</code>中我们应该调用相反的操作：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">motionManager.stopDeviceMotionUpdates()</div></pre></td></tr></table></figure><p>当视图出现，系统开始定期调用<code>gravityUpdated</code>方法并传入新的加速计数据。让我们实现这个方法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func gravityUpdated(motion: CMDeviceMotion!, error: NSError!) &#123;</div><div class="line">   if (error != nil) &#123;</div><div class="line">       NSLog(&quot;\(error)&quot;)</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   let grav : CMAcceleration = motion.gravity;</div><div class="line"></div><div class="line">   let x = CGFloat(grav.x);</div><div class="line">   let y = CGFloat(grav.y);</div><div class="line"></div><div class="line">   var v = CGVectorMake(x, y);</div><div class="line">   gravity.gravityDirection = v;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>让我们谈一谈感叹号。它跟我们声明<code>animator</code>用到的问号无关。问号表明“变量可能为空”，感叹号意思相反：“变量永远不为空”，但实际意义更深。  </p><p>当你声明一个<code>animator?</code>形式的变量时，它跟<code>animator</code>这样的变量是不一样的。你可以把它看做是一种<code>Optional</code>类型的对象，有可能包含<code>animator</code>也有可能不包含。所以问号和感叹号只对<code>Optional</code>起作用，对<code>animator</code>不起作用。问号在代码上意味着“如果不为空就继续”，像这样：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">animator?.addBehavior(collider)</div></pre></td></tr></table></figure><p>你可以生成等效的代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if let x = animator &#123; x.addBehavior(collider) &#125;</div></pre></td></tr></table></figure><p>或者，你可以用感叹号来解析本质的值，取得<code>Optional</code>里面的东东并传递它的值来代替整个容器。在<code>gravityUpdated</code>的声明中，我们预示我们会收到解析好的值-它不会是<code>nil</code>。  </p><p>不管怎样，这的确很酷，但是没有考虑读取加速计时设备的朝向问题。结果就是如果你颠倒你的手机，它会翻转显示，但不是加速计数据，你的箱子会开始鬼畜。所以我们加了些代码来让数据视朝向情况而定。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">func gravityUpdated(motion: CMDeviceMotion!, error: NSError!) &#123;</div><div class="line">if error &#123;</div><div class="line">  NSLog(&quot;\(error)&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">let grav : CMAcceleration = motion.gravity;</div><div class="line"></div><div class="line">let x = CGFloat(grav.x);</div><div class="line">let y = CGFloat(grav.y);</div><div class="line">var p = CGPointMake(x,y)</div><div class="line"></div><div class="line">// Have to correct for orientation.</div><div class="line">var orientation = UIApplication.sharedApplication().statusBarOrientation;</div><div class="line"></div><div class="line">if orientation == UIInterfaceOrientation.LandscapeLeft &#123;</div><div class="line">  var t = p.x</div><div class="line">  p.x = 0 - p.y</div><div class="line">  p.y = t</div><div class="line">&#125; else if orientation == UIInterfaceOrientation.LandscapeRight &#123;</div><div class="line">  var t = p.x</div><div class="line">  p.x = p.y</div><div class="line">  p.y = 0 - t</div><div class="line">&#125; else if orientation == UIInterfaceOrientation.PortraitUpsideDown &#123;</div><div class="line">  p.x *= -1</div><div class="line">  p.y *= -1</div><div class="line">&#125;</div><div class="line"></div><div class="line">var v = CGVectorMake(p.x, 0 - p.y);</div><div class="line">gravity.gravityDirection = v;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你注意的第一件事就是我们用<code>x</code>和<code>y</code>的值创建了一个<code>CGPoint</code>。使用<code>CGPoint</code>没有什么特别的原因，只是为了把数值放在一起。  </p><p>它看起来像什么？  </p><p><img src="http://www.bignerdranch.com/img/blog/2014/07/round4.gif" alt="">  </p><p>太酷了！  </p><p>##其他的行为</p><p>我提交了两个commit将事情推进了一点：<a href="https://github.com/stevesparks/RockBox/commit/8752153e608e621193742582913e2e3aaba207c9" target="_blank" rel="external">其中一个</a>添加了<code>UIDynamicItemBehavior</code>，允许我们修改箱子的摩擦力和弹性。我让他们超弹(elasticity = 0.9, friction = 0.1)，于是重力演变成了箱子们狂躁弹跳似的疯狂演示。  </p><p>这说明了UIDynamics中的一个缺点。当箱子速度增长，最终它们达到一个速度使得箱子在上一帧还完全在视图内，下一帧完全在视图外。在这种情况<code>UICollisionBehavior</code>将不会触发，箱子将会消失。它仍然存在，并持续消耗计算资源，但它永远不会再次出现在视图内。（一种设想是箱子永远坠落，速度递增。）  </p><p>下一个<a href="https://github.com/stevesparks/RockBox/commit/ac1a838d2b4ef575f8581f1ff8c9e9433f8362a8" target="_blank" rel="external">commit</a>添加了一些<code>UIAttachmentBehaviors</code>使10个箱子变成一串箱子。它有点破坏了应用的可玩性，但我想让你看看这些物体是怎么相互连接起来的。  </p><hr><p>译者注：最后一节是作者吐槽Swift经历的，因为Swift版本更新了，这节内容不是很重要所以没翻译。原作者代码风格不够Swift而且语法老旧，我提了个[PR]，将语法更新到最新的Swift 1.2。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自&lt;a href=&quot;http://www.bignerdranch.com/blog/uidynamics-in-swift/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BigNerdRanch&lt;/a&gt;，作者&lt;a href=&quot;http://www.bignerdranch.com/about-us/nerds/steve-sparks/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Steve Sparks&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="UIKit Dynamics" scheme="http://yoursite.com/tags/UIKit-Dynamics/"/>
    
  </entry>
  
</feed>
