<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Objective-C中的KVC和KVO · xiao</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2014/05/12/2014-05-12-objective-czhong-de-kvche-kvo/" class="post-title-link">Objective-C中的KVC和KVO</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/设计模式/" class="post-tag-link">设计模式</a></li><li class="post-tag-item"><a href="/tags/Objective-C/" class="post-tag-link">Objective-C</a></li></ul><div class="post-time">Monday, May 12th 2014</div></div><div class="post-content"><p>本文讲述了使用Cocoa框架中的KVC和KVO，实现观察者模式  </p>
<a id="more"></a>
<p>##KVC</p>
<p>键/值编码中的基本调用包括<code>-valueForKey:</code>和<code>-setValue:forKey:</code>。以字符串的形式向对象发送消息，这个字符串是我们关注的属性的关键。<br><code>valueForKey:</code>首先查找以键<code>-key</code>或<code>-isKey</code>命名的getter方法。如果不存在getter方法（假如我们没有通过<code>@synthesize</code>提供存取方法），它将在对象内部查找名为<code>_key</code>或<code>key</code>的实例变量。<br>对于KVC，Cocoa自动放入和取出标量值（int，float和struct）放入NSNumber或NSValue中；当使用<code>-setValue:ForKey:</code>时，它自动将标量值从这些对象中取出。仅KVC具有这种自动包装功能，常规方法调用和属性语法不具备该功能。<br><code>-setValue:ForKey:</code>的工作方式和<code>-valueForKey:</code>相同。它首先查找名称的setter方法，如果不存在setter方法，它将在类中查找名为<code>_key</code>或<code>key</code>的实例变量。  </p>
<p>使用KVC访问属性的代价比直接使用存取方法要大，所以只在需要的时候才用。  </p>
<p>最简单的 KVC 能让我们通过以下的形式访问属性：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div></pre></td></tr></table></figure>
<p>取值：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *n = [object valueForKey:@&quot;name&quot;];</div></pre></td></tr></table></figure>
<p>设定：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object setValue:@&quot;Daniel&quot; forKey:@&quot;name&quot;];</div></pre></td></tr></table></figure>
<p>值得注意的是这个不仅可以访问作为对象属性，而且也能访问一些标量（例如 <code>int</code> 和 <code>CGFloat</code>）和 struct（例如 <code>CGRect</code>）。Foundation 框架会为我们自动封装它们。举例来说，如果有以下属性：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic) CGFloat height;</div></pre></td></tr></table></figure>
<p>我们可以这样设置它：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object setValue:@(20) forKey:@&quot;height&quot;];</div></pre></td></tr></table></figure>
<p>有关KVC的更多用法，参看下面的文章：  </p>
<p><a href="http://blog.csdn.net/omegayy/article/details/7381301" target="_blank" rel="external">http://blog.csdn.net/omegayy/article/details/7381301</a><br><a href="http://blog.csdn.net/wzzvictory/article/details/9674431" target="_blank" rel="external">http://blog.csdn.net/wzzvictory/article/details/9674431</a><br><a href="http://objccn.io/issue-7-3/" target="_blank" rel="external">http://objccn.io/issue-7-3/</a>  </p>
<p>##KVO</p>
<p>KVO是Cocoa提供的一种称为键－值观察的机制，对象可以通过它得到其他对象特性属性的变更通知。这种机制在MVC模式的场景中很重要，因为它让视图对象可以经由控制器层观察模型对象的变更。<br>这一机制基于<code>NSKeyValueObserving</code>非正式协议，Cocoa通过这个协议为所有遵守协议的对象提供了一种自动化的属性观察能力。要实现自动观察，参与KVO的对象需要符合KVC的要求和存取方法，也可以手动实现观察者通知，也可以两者都保留。  </p>
<p>KVO是Cocoa框架使用<strong>观察者模式</strong>的一种途径。  </p>
<p>设置一个属性的观察者需要三步，理解这些步骤可以更清楚的知道KVO的工作框图  </p>
<ol>
<li>首先看看你当前的场景如果使用KVO是否更妥当，比如，当一个实例的某个具体属性有任何变更的时候，另一个实例需要被通知。  </li>
</ol>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/140353389577.jpg" alt="">  </p>
<p>比如，BankObject中的<code>accountBalance</code>属性有任何变更时，某个PersonObject对象都要觉察到。  </p>
<ol>
<li>这个PersonObject对象必须注册成为BankObject的<code>accountBalance</code>属性的观察者，可以通过发送<code>addObserver:forKeyPath:options:context:</code>消息来实现。  </li>
</ol>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/140353389319.jpg" alt="">  </p>
<p>注意：<code>addObserver:forKeyPath:options:context:</code>方法在你指定的两个实例间建立联系，而不是在两个类之间。  </p>
<ol>
<li>为了回应变更通知，观察者必须实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法。这个方法的实现决定了观察者如何回应变更通知。你可以在这个方法里自定义如何回应被观察属性的变更。  </li>
</ol>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/140353388989.jpg" alt="">    </p>
<ol>
<li>当一个被观察属性的值以符合KVO方式变更或者当它依赖的键变更时，<code>observeValueForKeyPath:ofObject:change:context:</code>方法会被自动执行。  </li>
</ol>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/140353389524.jpg" alt="">  </p>
<p>###Registering for Key-Value Observing</p>
<p>####注册成为观察者<br>你可以通过发送<code>addObserver:forKeyPath:options:context:</code>消息来注册观察者  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)registerAsObserver &#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     Register 'inspector' to receive change notifications for the "openingBalance" property of</span></div><div class="line"><span class="comment">     the 'account' object and specify that both the old and new values of "openingBalance"</span></div><div class="line"><span class="comment">     should be provided in the observe… method.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    [account addObserver:inspector</div><div class="line">             forKeyPath:<span class="string">@"openingBalance"</span></div><div class="line">                 options:(<span class="built_in">NSKeyValueObservingOptionNew</span> |</div><div class="line">                            <span class="built_in">NSKeyValueObservingOptionOld</span>)</div><div class="line">                    context:<span class="literal">NULL</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>inspector</code>注册成为了<code>account</code>的观察者，被观察属性的KeyPath是<code>@&quot;openingBalance&quot;</code>，也就是<code>account</code>的<code>openingBalance</code>属性，<code>NSKeyValueObservingOptionNew</code>和<code>NSKeyValueObservingOptionOld</code>选项分别标识在观察者接收通知时<code>change</code>字典对应入口提供更改后的值和更改前的值。更简单的办法是用 <code>NSKeyValueObservingOptionPrior</code> 选项，随后我们就可以用以下方式提取出改变前后的值：(<code>change</code>是个字典，详细介绍请看下节)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id oldValue = change[NSKeyValueChangeOldKey];</div><div class="line">id newValue = change[NSKeyValueChangeNewKey];</div></pre></td></tr></table></figure>
<p>我们常常需要当一个值改变的时候更新 UI，但是我们也要在第一次运行代码的时候更新一次 UI。我们可以用 KVO 并添加 <code>NSKeyValueObservingOptionInitial</code> 的选项 来一箭双雕地做好这样的事情。这将会让 KVO 通知在调用<code>-addObserver:forKeyPath:...</code> 到时候也被触发。<br>当我们注册 KVO 通知的时候，我们可以添加 <code>NSKeyValueObservingOptionPrior</code> 选项，这能使我们在键值改变之前被通知。这和<code>-willChangeValueForKey:</code>被触发的时间相对应。<br>如果我们注册通知的时候附加了 <code>NSKeyValueObservingOptionPrior</code> 选项，我们将会收到两个通知：一个在值变更前，另一个在变更之后。变更前的通知将会在 <code>change</code> 字典中有不同的键。  </p>
<p><code>context</code>是一个指针，当<code>observeValueForKeyPath:ofObject:change:context:</code>方法执行时<code>context</code>会提供给观察者。<code>context</code>可以是C指针或者一个对象引用，既可以当作一个唯一的标识来分辨被观察的变更，也可以向观察者提供数据。  </p>
<p>####接收变更通知</p>
<p>当被观察的属性变更时，观察者会接到<code>observeValueForKeyPath:ofObject:change:context:</code>消息，所有的观察者都必须实现这个方法。<br>观察者会被提供触发通知的对象和<code>keyPath</code>，一个包含变更详细信息的字典，还有一个注册观察者时提供的<code>context</code>指针。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</div><div class="line">                      ofObject:(id)object</div><div class="line">                        change:(NSDictionary *)change</div><div class="line">                       context:(void *)context &#123;</div><div class="line"> </div><div class="line">    if ([keyPath isEqual:@&quot;openingBalance&quot;]) &#123;</div><div class="line">        [openingBalanceInspectorField setObjectValue:</div><div class="line">            [change objectForKey:NSKeyValueChangeNewKey]];</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     Be sure to call the superclass&apos;s implementation *if it implements it*.</div><div class="line">     NSObject does not implement the method.</div><div class="line">     */</div><div class="line">    [super observeValueForKeyPath:keyPath</div><div class="line">                         ofObject:object</div><div class="line">                           change:change</div><div class="line">                           context:context];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于change参数，它是一个字典，有五个常量作为它的键：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSString *const NSKeyValueChangeKindKey;  </div><div class="line">NSString *const NSKeyValueChangeNewKey;  </div><div class="line">NSString *const NSKeyValueChangeOldKey;  </div><div class="line">NSString *const NSKeyValueChangeIndexesKey;  </div><div class="line">NSString *const NSKeyValueChangeNotificationIsPriorKey;</div></pre></td></tr></table></figure>
<p><strong>NSKeyValueChangeKindKey</strong><br>指明了变更的类型，值为“NSKeyValueChange”枚举中的某一个，类型为NSNumber。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">enum &#123;</div><div class="line">   NSKeyValueChangeSetting = 1,</div><div class="line">   NSKeyValueChangeInsertion = 2,</div><div class="line">   NSKeyValueChangeRemoval = 3,</div><div class="line">   NSKeyValueChangeReplacement = 4</div><div class="line">&#125;;</div><div class="line">typedef NSUInteger NSKeyValueChange;</div></pre></td></tr></table></figure>
<p><strong>NSKeyValueChangeNewKey</strong><br>如果 <code>NSKeyValueChangeKindKey</code>的值为 <code>NSKeyValueChangeSetting</code>，并且 <code>NSKeyValueObservingOptionNew</code>选项在注册观察者时也指定了，那么这个键的值就是属性变更后的新值。<br>对于 <code>NSKeyValueChangeInsertion</code>或者<code>NSKeyValueChangeReplacement</code>，如果 <code>NSKeyValueObservingOptionNew</code>选项在注册观察者时也指定了，这个键的值是一个数组，其包含了插入或替换的对象。<br><strong>NSKeyValueChangeOldKey</strong><br>如果 <code>NSKeyValueChangeKindKey</code>的值为 <code>NSKeyValueChangeSetting</code>，并且 <code>NSKeyValueObservingOptionOld</code>选项在注册观察者时也指定了，那么这个键的值就是属性变更前的旧值。<br>对于  <code>NSKeyValueChangeRemoval</code> 或者<code>NSKeyValueChangeReplacement</code>，如果 <code>NSKeyValueObservingOptionOld</code>选项在注册观察者时也指定了，这个键的值是一个数组，其包含了被移除或替换的对象。<br><strong>NSKeyValueChangeIndexesKey</strong><br>如果 <code>NSKeyValueChangeKindKey</code>的值为<code>NSKeyValueChangeInsertion</code>, <code>NSKeyValueChangeRemoval</code>, 或者 <code>NSKeyValueChangeReplacement</code>，这个键的值是一个<code>NSIndexSet</code>对象，包含了增加，移除或者替换对象的index。<br><strong>NSKeyValueChangeNotificationIsPriorKey</strong><br>如果注册观察者时<code>NSKeyValueObservingOptionPrior</code>选项被指明了，此通知会在变更发生前被发出。其类型为<code>NSNumber</code>，包含的值为<code>YES</code>。我们可以像以下这样区分通知是在改变之前还是之后被触发的：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) &#123;</div><div class="line">    // 改变之前</div><div class="line">&#125; else &#123;</div><div class="line">    // 改变之后</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####移除观察者<br>你可以通过发送<code>removeObserver:forKeyPath:</code>消息来移除观察者，你需要指明观察对象和路径。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)unregisterForChangeNotification &#123;</div><div class="line">    [observedObject removeObserver:inspector forKeyPath:@&quot;openingBalance&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码将<code>openingBalance</code>属性的观察者<code>inspector</code>移除，移除后观察者再也不会收到<code>observeValueForKeyPath:ofObject:change:context:</code>消息。<br>在移除观察者之前，如果<code>context</code>是一个对象的引用，那么必须保持对它的强引用直到观察者被移除。  </p>
<p>###KVO Compliance（KVO兼容）</p>
<p>有两种方法可以保证变更通知被发出。自动发送通知是<code>NSObject</code>提供的，并且一个类中的所有属性都默认支持，只要是符合KVO的。一般情况你使用自动变更通知，你不需要写任何代码。<br>人工变更通知需要些额外的代码，但也对通知发送提供了额外的控制。你可以通过重写子类<code>automaticallyNotifiesObserversForKey:</code>方法的方式控制子类一些属性的自动通知。  </p>
<p>####Automatic Change Notification（自动通知）</p>
<p>下面代码中的方法都能导致KVO变更消息发出  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// Call the accessor method.</div><div class="line">[account setName:@&quot;Savings&quot;];</div><div class="line"> </div><div class="line">// Use setValue:forKey:.</div><div class="line">[account setValue:@&quot;Savings&quot; forKey:@&quot;name&quot;];</div><div class="line"> </div><div class="line">// Use a key path, where &apos;account&apos; is a kvc-compliant property of &apos;document&apos;.</div><div class="line">[document setValue:@&quot;Savings&quot; forKeyPath:@&quot;account.name&quot;];</div><div class="line"> </div><div class="line">// Use mutableArrayValueForKey: to retrieve a relationship proxy object.</div><div class="line">Transaction *newTransaction = &lt;#Create a new transaction for the account#&gt;;</div><div class="line">NSMutableArray *transactions = [account mutableArrayValueForKey:@&quot;transactions&quot;];</div><div class="line">[transactions addObject:newTransaction];</div></pre></td></tr></table></figure>
<p>####Manual Change Notification（手动通知）</p>
<p>下面的代码为<code>openingBalance</code>属性开启了人工通知，并让父类决定其他属性的通知方式。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey &#123;</div><div class="line"> </div><div class="line">    BOOL automatic = NO;</div><div class="line">    if ([theKey isEqualToString:@&quot;openingBalance&quot;]) &#123;</div><div class="line">        automatic = NO;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        automatic = [super automaticallyNotifiesObserversForKey:theKey];</div><div class="line">    &#125;</div><div class="line">    return automatic;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要实现人工观察者通知，你要执行在变更前执行<code>willChangeValueForKey:</code>方法，在变更后执行<code>didChangeValueForKey:</code>方法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setOpeningBalance:(double)theBalance &#123;</div><div class="line">    [self willChangeValueForKey:@&quot;openingBalance&quot;];</div><div class="line">    _openingBalance = theBalance;</div><div class="line">    [self didChangeValueForKey:@&quot;openingBalance&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了使不必要的通知最小化我们应该在变更前先检查一下值是否变了：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setOpeningBalance:(double)theBalance &#123;</div><div class="line">    if (theBalance != _openingBalance) &#123;</div><div class="line">        [self willChangeValueForKey:@&quot;openingBalance&quot;];</div><div class="line">        _openingBalance = theBalance;</div><div class="line">        [self didChangeValueForKey:@&quot;openingBalance&quot;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个操作导致了多个键的变化，你必须嵌套变更通知：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)setOpeningBalance:(double)theBalance &#123;</div><div class="line">    [self willChangeValueForKey:@&quot;openingBalance&quot;];</div><div class="line">    [self willChangeValueForKey:@&quot;itemChanged&quot;];</div><div class="line">    _openingBalance = theBalance;</div><div class="line">    _itemChanged = _itemChanged+1;</div><div class="line">    [self didChangeValueForKey:@&quot;itemChanged&quot;];</div><div class="line">    [self didChangeValueForKey:@&quot;openingBalance&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在to-many关系操作的情形中，你不仅必须表明key是什么，还要表明变更类型和影响到的索引。变更类型是一个 <code>NSKeyValueChange</code>值，被影响对象的索引是一个 <code>NSIndexSet</code>对象。<br>下面的代码示范了在to-many关系<code>transactions</code>对象中的删除操作：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes &#123;</div><div class="line">    [self willChange:NSKeyValueChangeRemoval</div><div class="line">        valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</div><div class="line"> </div><div class="line">    // Remove the transaction objects at the specified indexes.</div><div class="line"> </div><div class="line">    [self didChange:NSKeyValueChangeRemoval</div><div class="line">        valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###Registering Dependent Keys（注册依赖键）</p>
<p>有一些属性的值取决于一个或者多个其他对象的属性值，一旦某个被依赖的属性值变了，依赖它的属性的变化也需要被通知。  </p>
<p>####To-one Relationships</p>
<p>要自动触发 to-one关系，有两种方法：重写<code>keyPathsForValuesAffectingValueForKey:</code>方法或者定义名称为<code>keyPathsForValuesAffecting&lt;Key&gt;</code>的方法。  </p>
<p>例如一个人的全名是由姓氏和名子组成的：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSString *)fullName &#123;</div><div class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;,firstName, lastName];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个观察<code>fullName</code>的程序在<code>firstName</code>或者<code>lastName</code>变化时也应该接收到通知。  </p>
<p>一种解决方法是重写<code>keyPathsForValuesAffectingValueForKey:</code>方法来表明<code>fullname</code>属性是依赖于<code>firstname</code>和<code>lastname</code>的：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123;</div><div class="line"> </div><div class="line">    NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];</div><div class="line"> </div><div class="line">    if ([key isEqualToString:@&quot;fullName&quot;]) &#123;</div><div class="line">        NSArray *affectingKeys = @[@&quot;lastName&quot;, @&quot;firstName&quot;];</div><div class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</div><div class="line">    &#125;</div><div class="line">    return keyPaths;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相当于在影响<code>fullName</code>值的<code>keypath</code>中新加了两个key：<code>lastName</code>和<code>firstName</code>，很容易理解。  </p>
<p>另一种实现同样结果的方法是实现一个遵循命名方式为<code>keyPathsForValuesAffecting&lt;Key&gt;</code>的类方法，<code>&lt;Key&gt;</code>是依赖于其他值的属性名（首字母大写），用上面代码的例子来重新实现一下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffectingFullName &#123;</div><div class="line">    return [NSSet setWithObjects:@&quot;lastName&quot;, @&quot;firstName&quot;, nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时在类别中我们不能添加<code>keyPathsForValuesAffectingValueForKey:</code>方法，因为不能再类别中重写方法，所以这时可以实现<code>keyPathsForValuesAffecting&lt;Key&gt;</code>方法来代替。  </p>
<p>注意：你不能在<code>keyPathsForValuesAffectingValueForKey:</code>方法中设立to-many关系的依赖，相反，你必须观察在to-many集合中的每一个对象中相关的属性并通过亲自更新他们的依赖来回应变更。下一节将会讲述对付此情形的策略。  </p>
<p>####To-many Relationships</p>
<p><code>keyPathsForValuesAffectingValueForKey:</code>方法不支持包含to-many关系的<code>keypath</code>。比如，假如你有一个<code>Department</code>类，它有一个针对<code>Employee</code>类的to-many关系（雇员），<code>Employee</code>类有<code>salary</code>属性。你希望<code>Department</code>类有一个<code>totalSalary</code>属性来计算所有员工的薪水，也就是在这个关系中<code>Department</code>的<code>totalSalary</code>依赖于所有<code>Employee</code>的<code>salary</code>属性。你不能通过实现<code>keyPathsForValuesAffectingTotalSalary</code>方法并返回<code>employees.salary</code>。  </p>
<p>有两种解决方法：  </p>
<ol>
<li>你可以用KVO将parent（比如<code>Department</code>）作为所有children（比如<code>Employee</code>）相关属性的观察者。你必须在把child添加或删除到parent时也把parent作为child的观察者添加或删除。在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中我们可以针对被依赖项的变更来更新依赖项的值： </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;</div><div class="line"> </div><div class="line">    if (context == totalSalaryContext) &#123;</div><div class="line">        [self updateTotalSalary];</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    // deal with other observations and/or invoke super...</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)updateTotalSalary &#123;</div><div class="line">    [self setTotalSalary:[self valueForKeyPath:@&quot;employees.@sum.salary&quot;]];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)setTotalSalary:(NSNumber *)newTotalSalary &#123;</div><div class="line"> </div><div class="line">    if (totalSalary != newTotalSalary) &#123;</div><div class="line">        [self willChangeValueForKey:@&quot;totalSalary&quot;];</div><div class="line">        _totalSalary = newTotalSalary;</div><div class="line">        [self didChangeValueForKey:@&quot;totalSalary&quot;];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (NSNumber *)totalSalary &#123;</div><div class="line">    return _totalSalary;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.如果你在使用Core Data，你可以在应用的notification center中将parent注册为它的 managed object context的观察者，parent应该回应相应的变更通知，这些通知是children以类似KVO的形式发出的。  </p>
<p>其实这也是Objective-C中利用Cocoa实现观察者模式的另一种途径：<code>NSNotificationCenter</code>  </p>
<p>###调试KVO  </p>
<p>你可以在 lldb 里查看一个被观察对象的所有观察信息。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) po [observedObject observationInfo]</div></pre></td></tr></table></figure>
<p>这会打印出有关谁观察谁之类的很多信息。  </p>
<p>这个信息的格式不是公开的，我们不能让任何东西依赖它，因为苹果随时都可以改变它。不过这是一个很强大的排错工具。  </p>
</div></article><div class="pagination"><a href="/2014/05/26/2014-05-26-publish-your-pods-on-cocoapods-with-trunk/" class="pagination-prev">PREV</a><a href="/2014/05/10/2014-05-10-zhuang-shi-zhe-mo-shi/" class="pagination-next">NEXT</a></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARC/">ARC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/App-Extensions/">App Extensions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AppGroups/">AppGroups</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/24/一首小诗/">1024,一首小诗</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/终有一天/">终有一天.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/樱花樱花想见你/">樱花樱花想见你</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/工具本/">小tips汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/CI搭建和脚本自动化/">CI搭建和脚本自动化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/01/又要春节了啊/">又要春节了啊</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/写给PM的iOS消息推送/">写给PM的iOS消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/19/gitlab和sourcetree的使用/">gitlab和sourcetree的使用</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2017 <a href="/">sopig</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?38155daa8b79fb3a5cad11d825228868";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>