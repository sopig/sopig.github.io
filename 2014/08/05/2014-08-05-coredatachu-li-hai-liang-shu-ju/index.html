<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CoreData处理海量数据 · xiao</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2014/08/05/2014-08-05-coredatachu-li-hai-liang-shu-ju/" class="post-title-link">CoreData处理海量数据</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/Core-Data/" class="post-tag-link">Core Data</a></li></ul><div class="post-time">Tuesday, August 5th 2014</div></div><div class="post-content"><p>随着iOS8和OSX10.10的发布，Core Data也迎来了更新。这次的更新可谓是重量级的，它使得程序员能够更加直接高效的操作数据库，在处理大量数据时速度明显提升（这在以前不知有多少程序员因为Core Data批量更新数据效率之低而不得不放弃使用它）。Batch Updates可用于批量快速更新数据，Asynchronous Fetching可用于异步抓取海量数据，并可以通过<code>NSProgress</code>实现进度跟踪和取消。<br><a id="more"></a></p>
<p>##Batch Updates</p>
<p>在CoreData中想要更新大量数据，我们往往要将大量修改后的<code>NSManagedObject</code>加载到<code>NSManagedObjectContext</code>中并保存，这会占用大量内存，试想想在iPhone这样的内存有限的移动设备上将是个灾难，数据有可能丢失。你可能会采取批处理的方式，即一小批一小批的更新<code>NSManagedObject</code>并保存到<code>NSManagedObjectContext</code>中，但这样会花费很多时间，用户体验较差。  </p>
<p>为了解决这个问题，苹果在<code>NSManagedObjectContext</code>加入了一个新的方法：<code>executeRequest:error:</code>，它接受一个<code>NSPersistentStoreRequest</code>类型的参数，返回类型为<code>NSPersistentStoreResult</code>。  </p>
<p>关于<code>NSPersistentStoreRequest</code>有些人可能比较熟悉，它是<code>NSFetchRequest</code>、<code>NSSaveChangesRequest</code>、<code>NSBatchUpdateRequest</code>和<code>NSAsynchronousFetchRequest</code>的基类。后两个类是这次iOS8新加的，也是这篇文章将要讨论的内容。  </p>
<p><code>NSPersistentStoreResult</code>是一个新加入的类，它也是一个基类，而且是抽象类，这个类作为<code>executeRequest:error:</code>返回内容的父类，相当于一个接口，它目前有两个子类：<code>NSPersistentStoreAsynchronousResult</code>和<code>NSBatchUpdateResult</code>。  </p>
<p>你大概猜到了，<code>NSBatchUpdateResult</code>对应着前面的<code>NSBatchUpdateRequest</code>.下面举个栗子:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">func resetWeight(sender: AnyObject) &#123;</div><div class="line">        // Create Entity Description</div><div class="line">        let batchUpdateRequest = NSBatchUpdateRequest(entityName: &quot;Choice&quot;)</div><div class="line">        </div><div class="line">        // Configure Batch Update Request</div><div class="line">        batchUpdateRequest.resultType = NSBatchUpdateRequestResultType.UpdatedObjectIDsResultType</div><div class="line">        batchUpdateRequest.propertiesToUpdate = [&quot;weight&quot;:1]</div><div class="line">//        batchUpdateRequest.affectedStores = []</div><div class="line">//        batchUpdateRequest.predicate = ...</div><div class="line">        </div><div class="line">        // Execute Batch Request</div><div class="line">        var batchUpdateRequestError:NSError? = nil</div><div class="line">        var batchUpdateResult = managedObjectContext?.executeRequest(batchUpdateRequest, error: &amp;batchUpdateRequestError) as! NSBatchUpdateResult</div><div class="line">        if batchUpdateRequestError != nil &#123;</div><div class="line">            println(&quot;Unable to execute batch update request.&quot;)</div><div class="line">            println(&quot;\(batchUpdateRequestError)\(batchUpdateRequestError?.localizedDescription)&quot;)</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // Extract Object IDs</div><div class="line">            let objectIDs = batchUpdateResult.result as! [NSManagedObjectID]</div><div class="line">            </div><div class="line">            for objectID in objectIDs &#123;</div><div class="line">                // Turn Managed Objects into Faults</div><div class="line">                if var managedObject = managedObjectContext?.objectWithID(objectID) &#123;</div><div class="line">                    managedObjectContext?.performBlock(&#123; () -&gt; Void in</div><div class="line">                        managedObjectContext?.refreshObject(managedObject, mergeChanges: false)</div><div class="line">                    &#125;)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // Perform Fetch</div><div class="line">            var fetchError: NSError? = nil</div><div class="line">            if !fetchedResultsController.performFetch(&amp;fetchError) &#123;</div><div class="line">                println(&quot;Unable to perform fetch.&quot;)</div><div class="line">                println(&quot;\(fetchError)\(fetchError?.localizedDescription)&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码来自<a href="http://hardchoice.yulingtianxia.com" target="_blank" rel="external">HardChoice</a>的DetailViewController.swift文件,用于批量重置权重.  </p>
<p>先来说说<code>NSBatchUpdateRequest</code>。它有点像<code>NSFetchRequest</code>：它允许你指定一个想要更新数据的实体；也可以指定一个<code>affectedStores</code>，它存储了一个接受更新请求的<code>NSPersistentStore</code>数组。（其实它是<code>NSPersistentStoreRequest</code>的属性）；它也有一个谓词属性<code>predicate</code>来做更新的条件，它跟<code>NSFetchRequest</code>中的谓词一样强大和灵活，类似于SQL的where语句；你需要指定想要更新的字段，通过<code>propertiesToUpdate</code>属性来描述字段更新，它是一个字段，key为<code>NSPropertyDescription</code>或属性名字符串，value为<code>NSExpression</code>或常量。在这里我选择的 Model 是<code>Choice</code>,它包含一个字符串类型的<code>name</code>字段和整型的<code>weight</code>字段.我想要将所有的<code>weight</code>字段都改为1;<code>resultType</code>属性是类型为<code>NSBatchUpdateRequestResultType</code>的枚举变量,默认为<code>StatusOnlyResultType</code>(什么都不返回),我在这里选择<code>UpdatedObjectIDsResultType</code>(返回被更新数据的 ID),当然你也可以选择<code>UpdatedObjectsCountResultType</code>来让结果返回更新记录的行数:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> // Create Entity Description</div><div class="line">let batchUpdateRequest = NSBatchUpdateRequest(entityName: &quot;Choice&quot;)</div><div class="line">   </div><div class="line">// Configure Batch Update Request</div><div class="line">batchUpdateRequest.resultType = NSBatchUpdateRequestResultType.UpdatedObjectIDsResultType</div><div class="line">batchUpdateRequest.propertiesToUpdate = [&quot;weight&quot;:1]</div><div class="line">//        batchUpdateRequest.affectedStores = []</div><div class="line">//        batchUpdateRequest.predicate = ...</div></pre></td></tr></table></figure>
<p>然后用之前提过苹果新加的新方法<code>executeRequest:error:</code>来执行 request 并获取 result:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Execute Batch Request</div><div class="line">var batchUpdateRequestError:NSError? = nil</div><div class="line">var batchUpdateResult = managedObjectContext?.executeRequest(batchUpdateRequest, error: &amp;batchUpdateRequestError) as! NSBatchUpdateResult</div></pre></td></tr></table></figure>
<p>接着谈谈<code>NSBatchUpdateResult</code>，它有一个<code>result</code>属性和<code>resultType</code>属性，<code>result</code>中的内容类型<code>resultType</code>跟我们之前在<code>NSBatchUpdateRequest</code>设置过的<code>resultType</code>属性是对应的,可能是成功或者失败，有可能是每行被更新的ID，也可能是被更新的行数。  </p>
<p>需要注意的是，由于<code>NSBatchUpdateRequest</code>并不会先将数据存入内存，而是直接操作数据库，所以并不会引起<code>NSManagedObjectContext</code>的同步更新，所以你不仅需要获取<code>NSBatchUpdateResult</code>然后刷新<code>NSManagedObjectContext</code>对应的数据和UI界面，还需要保证更新后的数据满足数据库模型上的<code>validation</code>，因为<code>NSManagedObjectContext</code>没有感知Batch Updates，一些数据验证工作就落在了程序员的身上（你需要写一段代码验证更新后的数据是合法的，用户可不希望在跑步APP上看到自己今天跑步里程是个负数）。一旦有非法数据录入数据库，下次加载并修改<code>NSManagedObject</code>的时候就会导致数据验证失败。除了上面提到的这些，还要注意Batch Updates对数据库的操作是乐观锁，也就是假定很少会发生同时存取同一块数据的情况，所以你需要制定一个合理的”merge”策略来应付因同时更新数据产生的冲突:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// Extract Object IDs</div><div class="line">let objectIDs = batchUpdateResult.result as! [NSManagedObjectID]</div><div class="line"></div><div class="line">for objectID in objectIDs &#123;</div><div class="line"> // Turn Managed Objects into Faults</div><div class="line"> if var managedObject = managedObjectContext?.objectWithID(objectID) &#123;</div><div class="line">     managedObjectContext?.performBlock(&#123; () -&gt; Void in</div><div class="line">         managedObjectContext?.refreshObject(managedObject, mergeChanges: false)</div><div class="line">     &#125;)</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">// Perform Fetch</div><div class="line">var fetchError: NSError? = nil</div><div class="line">if !fetchedResultsController.performFetch(&amp;fetchError) &#123;</div><div class="line"> println(&quot;Unable to perform fetch.&quot;)</div><div class="line"> println(&quot;\(fetchError)\(fetchError?.localizedDescription)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码先是从结果中取到了所有被更新数据的 ID, 再根据这些 ID 获取对应的 <code>NSManagedObject</code>,并使其过期失效,强制更新数据.这里关键的是下面这句:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">managedObjectContext?.performBlock(&#123; () -&gt; Void in</div><div class="line">    managedObjectContext?.refreshObject(managedObject, mergeChanges: false)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在 Swift 中如果不采用异步执行 block 的策略, UI 就不会更新.但在 Objective-C 上可以不用<code>performBlock</code>方法,直接调用<code>refreshObject: mergeChanges:</code>方法就行.  </p>
<p>最后看看效果,点击红色的重置权重按钮,所有选项右侧都变成1:  </p>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/IMG_1439.jpg" alt="重置权重">  </p>
<p>Batch Updates的优势在于其效率，在处理上万条数据的时候，它执行的时间跟SQL语句执行时间相当。毕竟它绕开了<code>NSManagedObjectContext</code>直接修改底层数据库,节省内存,但千万别忘了手动更新 UI.  </p>
<p>##Asynchronous Fetching</p>
<p>Asynchronous Fetching的加入依然是为了解决CoreData读取海量数据所带来的问题。通过使用Asynchronous Fetching，我们可以在抓取数据的同时不阻塞占用<code>NSManagedObjectContext</code>，并可以随时取消抓取行为，随时跟踪抓取数据的进度。  </p>
<p>设想我们平时用<code>NSFetchRequest</code>抓取数据的时候，我们会先用<code>NSManagedObjectContext</code>的<code>executeFetchRequest:error:</code>方法传入一个<code>NSFetchRequest</code>，然后请求会被发送到<code>NSPersistentStore</code>，然后执行一段时间后返回一个数组，在<code>NSManagedObjectContext</code>更新后，这个数组被当做<code>executeFetchRequest:error:</code>的返回值返回到我们这里。  </p>
<p>而Asynchronous Fetching则不同，当我们将一个<code>NSAsynchronousFetchRequest</code>对象传入<code>executeRequest:error:</code>方法后会立即返回一个“未来的”<code>NSAsynchronousFetchResult</code>。<code>NSAsynchronousFetchRequest</code>初始化时需要传入两个参数赋值给属性：  </p>
<ol>
<li><code>completionBlock</code>属性，允许我们在抓取完成后执行回调block；  </li>
<li><code>fetchRequest</code>属性，类型是<code>NSFetchRequest</code>。也即是说虽然是异步抓取，其实我们用的还是以前的<code>NSFetchRequest</code>，当<code>NSFetchRequest</code>抓取结束后会更新<code>NSManagedObjectContext</code>，这也就意味着<code>NSManagedObjectContext</code>的并发类型只能是<code>NSPrivateQueueConcurrencyType</code>或<code>NSMainQueueConcurrencyType</code>。  </li>
</ol>
<p>于是当我们用<code>NSAsynchronousFetchRequest</code>抓取数据时，我们会先用<code>NSManagedObjectContext</code>的<code>executeRequest:error:</code>方法传入一个<code>NSAsynchronousFetchRequest</code>，这个方法在<code>NSManagedObjectContext</code>上执行时，<code>NSManagedObjectContext</code>会立即制造并返回一个<code>NSAsynchronousFetchResult</code>，同时<code>NSAsynchronousFetchRequest</code>会被发送到<code>NSPersistentStore</code>。你现在可以继续编辑这个<code>NSManagedObjectContext</code>中的<code>NSManagedObject</code>，等到<code>NSPersistentStore</code>执行请求完毕时会将结果返回给<code>NSAsynchronousFetchResult</code>的<code>finalResult</code>属性，更新<code>NSManagedObjectContext</code>，执行<code>NSAsynchronousFetchRequest</code>的回调block。  </p>
<p>举个栗子：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let request = NSFetchRequest(entityName: &quot;MyEntity&quot;)</div><div class="line">let async = NSAsynchronousFetchRequest(fetchRequest: request)&#123;</div><div class="line">            (id result) in</div><div class="line">            if result.finalResult &#123;</div><div class="line">                //TODO..</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>Swift代码很简洁，并用了尾随闭包语法，看不懂的朋友也不用着急，知道<code>NSAsynchronousFetchRequest</code>大概的用法就行。  </p>
<p>之前提到过<code>NSAsynchronousFetchRequest</code>能在抓取数据的过程中跟踪进度，于是乎<code>NSProgress</code>登场了！一行代码顶十句话：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let request = NSFetchRequest(entityName: &quot;MyEntity&quot;)</div><div class="line">var asyncResult:NSPersistentStoreResult!</div><div class="line">let async = NSAsynchronousFetchRequest(fetchRequest: request)&#123;</div><div class="line">            (id result) in</div><div class="line">            if result.finalResult &#123;</div><div class="line">                //TODO..</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">let progress = NSProgress(totalUnitCount: 1)</div><div class="line">progress.becomeCurrentWithPendingUnitCount(1)</div><div class="line">managedObjectContext?.performBlock&#123;</div><div class="line">            [unowned self] in</div><div class="line">            let error = NSErrorPointer()</div><div class="line">            asyncResult = self.managedObjectContext?.executeRequest(async, error: error)</div><div class="line">        &#125;</div><div class="line">progress.resignCurrent()</div></pre></td></tr></table></figure>
<p>而取消获取数据只需要取消<code>NSProgress</code>就可以了！取消行为会沿着数的根节点蔓延到叶子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">progress.cancel()</div></pre></td></tr></table></figure>
<p>可以在<code>cancellationHandler</code>属性设置取消后执行的block，这里不再多说。</p>
</div></article><div class="pagination"><a href="/2014/08/14/reduce-http-requests/" class="pagination-prev">PREV</a><a href="/2014/07/29/2014-07-29-reactivecocoa/" class="pagination-next">NEXT</a></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARC/">ARC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/App-Extensions/">App Extensions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AppGroups/">AppGroups</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/24/一首小诗/">1024,一首小诗</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/终有一天/">终有一天.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/樱花樱花想见你/">樱花樱花想见你</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/工具本/">小tips汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/CI搭建和脚本自动化/">CI搭建和脚本自动化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/01/又要春节了啊/">又要春节了啊</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/写给PM的iOS消息推送/">写给PM的iOS消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/19/gitlab和sourcetree的使用/">gitlab和sourcetree的使用</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2017 <a href="/">sopig</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>