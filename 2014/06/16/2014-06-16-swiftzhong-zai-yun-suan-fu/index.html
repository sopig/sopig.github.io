<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Swift重载和自定义运算符 · xiao</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2014/06/16/2014-06-16-swiftzhong-zai-yun-suan-fu/" class="post-title-link">Swift重载和自定义运算符</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/Swift/" class="post-tag-link">Swift</a></li></ul><div class="post-time">Monday, June 16th 2014</div></div><div class="post-content"><p>最近一直边忙毕设边学Swift，终于看完了官方的教程（语言参考暂不打算看），在iBooks上做了一些笔记（看英文伤不起），感觉Swift是一门大杂烩类型的语言，我会记录一些我自认为以前遇到较少或者需要重点记忆的语法特性，在此作为分享，这次是运算符的重载，几乎每门语言都有，只是语法不一样罢了。<br>(2014-8-8更新至beta5语法)<br><a id="more"></a></p>
<p>##运算符重载<br>在Swift的官方文档中运算符重载叫做运算符函数（Operator Functions），顾名思义就是对已经有的运算符覆盖定义自己的函数实现。三元运算符（a？b：c）和默认的默认的赋值符(=)是不可重载的。  </p>
<p>###中缀运算符的重载<br>在<code>func</code>关键字前使用属性<code>@infix</code>来重载中缀运算符，函数名为想要重载的中缀运算符：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct Vector2D &#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line">func + (left: Vector2D, <span class="attr">right</span>: Vector2D) -&gt; Vector2D &#123;</div><div class="line">    <span class="keyword">return</span> Vector2D(x: left.x + right.x, <span class="attr">y</span>: left.y + right.y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码是对结构体<code>Vector2D</code>之间双目运算符<code>+</code>的重载，下面可以直接使用<code>+</code>对<code>Vector2D</code>进行操作了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let vector = Vector2D(x: 3.0, y: 1.0)</div><div class="line">let anotherVector = Vector2D(x: 2.0, y: 4.0)</div><div class="line">let combinedVector = vector + anotherVector</div><div class="line">// combinedVector 是一个新的Vector2D, 值为 (5.0, 5.0)</div></pre></td></tr></table></figure>
<p>除了对双目运算符的重载，还有对比较运算符的重载  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func == (left: Vector2D, right: Vector2D) -&gt; Bool &#123;</div><div class="line">    return (left.x == right.x) &amp;&amp; (left.y == right.y)</div><div class="line">&#125;</div><div class="line">func != (left: Vector2D, right: Vector2D) -&gt; Bool &#123;</div><div class="line">    return !(left == right)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们可以使用这两个运算符来判断两个Vector2D对象是否相等  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let twoThree = Vector2D(x: 2.0, y: 3.0)</div><div class="line">let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)</div><div class="line">if twoThree == anotherTwoThree &#123;</div><div class="line">    println(&quot;这两个向量是相等的.&quot;)</div><div class="line">&#125;</div><div class="line">// prints &quot;这两个向量是相等的.&quot;</div></pre></td></tr></table></figure>
<p>###前缀和后缀运算符的重载<br>前缀和后缀一元运算符重载需要在将<code>func</code>关键字前用<code>prefix</code>和<code>postfix</code>修饰，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">prefix func - (vector: Vector2D) -&gt; Vector2D &#123;</div><div class="line">    return Vector2D(x: -vector.x, y: -vector.y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码为<code>Vector2D</code>类型提供了单目减运算，并且是前缀，也就是取负操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let positive = Vector2D(x: 3.0, y: 4.0)</div><div class="line">let negative = -positive</div><div class="line">// negative 为 (-3.0, -4.0)</div><div class="line">let alsoPositive = -negative</div><div class="line">// alsoPositive 为 (3.0, 4.0)</div></pre></td></tr></table></figure>
<p>###组合赋值运算符的重载<br>组合赋值是其他运算符和赋值运算符一起执行的运算。如<code>+=</code>把加运算和赋值运算组合成一个操作。实现一个组合赋值符号需要把运算符的左参数设置成<code>inout</code>，因为这个参数会在运算符函数内直接修改它的值。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func += (inout left: Vector2D, right: Vector2D) &#123;</div><div class="line">    left = left + right</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为加法运算在之前定义过了，这里无需重新定义。所以，加赋运算符函数使用已经存在的高级加法运算符函数来执行左值加右值的运算。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var original = Vector2D(x: 1.0, y: 2.0)</div><div class="line">let vectorToAdd = Vector2D(x: 3.0, y: 4.0)</div><div class="line">original += vectorToAdd</div><div class="line">// original 现在为 (4.0, 6.0)</div></pre></td></tr></table></figure>
<p>你可以将赋值运算结合<code>prefix</code> 或 <code>postfix</code>修饰，例如实现一个<code>Vector2D</code>的前缀自增运算符（++a）。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@prefix func ++ (inout vector: Vector2D) -&gt; Vector2D &#123;</div><div class="line">    vector += Vector2D(x: 1.0, y: 1.0)</div><div class="line">    return vector</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个前缀使用了已经定义好的高级加赋运算，将自己加上一个值为<code>(1.0，1.0)</code>的对象然后赋给自己，然后再将自己返回。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var toIncrement = Vector2D(x: 3.0, y: 4.0)</div><div class="line">let afterIncrement = ++toIncrement</div><div class="line">// toIncrement 现在是 (4.0, 5.0)</div><div class="line">// afterIncrement 现在也是 (4.0, 5.0)</div></pre></td></tr></table></figure>
<p>##自定义运算符<br>标准的运算符不够玩，那你可以声明一些个性的运算符，但个性的运算符只能使用这些字符 <code>/ = - + * % &lt; &gt; ! &amp; | ^ . ~</code><br>新的运算符声明需在全局域使用<code>operator</code>关键字声明，可以声明为前缀，中缀或后缀的，分别用<code>prefix</code>、<code>infix</code>和<code>postfix</code>修饰。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">prefix operator +++ &#123;&#125;</div></pre></td></tr></table></figure>
<p>这段代码定义了一个新的前缀运算符叫<code>+++</code>，此前Swift并不存在这个运算符。此处为了演示，我们让<code>+++</code>对<code>Vector2D</code>对象的操作定义为“双自增”（prefix doubling incrementer） 这样一个独有的操作，这个操作使用了之前定义的加赋运算（<code>+=</code>）实现了自已加上自己然后返回的运算。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">prefix func +++ (inout vector: Vector2D) -&gt; Vector2D &#123;</div><div class="line">    vector += vector</div><div class="line">    return vector</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>+++</code>运算的实现是把自己再加上自己  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var toBeDoubled = Vector2D(x: 1.0, y: 4.0)</div><div class="line">let afterDoubling = +++toBeDoubled</div><div class="line">// toBeDoubled 现在是 (2.0, 8.0)</div><div class="line">// afterDoubling 现在也是 (2.0, 8.0)</div></pre></td></tr></table></figure>
<p>此外还可以定义运算符的结合性(associativity)和优先级(precedence)，结合性(associativity)的值可取的值有left，right和none。左结合运算符跟其他优先级相同的左结合运算符写在一起时，会跟左边的操作数结合。同理，右结合运算符会跟右边的操作数结合。而非结合运算符不能跟其他相同优先级的运算符写在一起。<br>结合性(associativity)的值默认为none，优先级(precedence)默认为100。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">infix operator +- &#123; associativity left precedence 140 &#125;</div><div class="line">func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123;</div><div class="line">    return Vector2D(x: left.x + right.x, y: left.y - right.y)</div><div class="line">&#125;</div><div class="line">let firstVector = Vector2D(x: 1.0, y: 2.0)</div><div class="line">let secondVector = Vector2D(x: 3.0, y: 4.0)</div><div class="line">let plusMinusVector = firstVector +- secondVector</div><div class="line">// plusMinusVector 此时的值为 (4.0, -2.0)</div></pre></td></tr></table></figure>
</div></article><div class="pagination"><a href="/2014/06/17/2014-06-17-swiftzhong-de-arc/" class="pagination-prev">PREV</a><a href="/2014/05/26/2014-05-26-publish-your-pods-on-cocoapods-with-trunk/" class="pagination-next">NEXT</a></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARC/">ARC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/App-Extensions/">App Extensions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AppGroups/">AppGroups</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/24/一首小诗/">1024,一首小诗</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/终有一天/">终有一天.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/樱花樱花想见你/">樱花樱花想见你</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/工具本/">小tips汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/CI搭建和脚本自动化/">CI搭建和脚本自动化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/01/又要春节了啊/">又要春节了啊</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/写给PM的iOS消息推送/">写给PM的iOS消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/19/gitlab和sourcetree的使用/">gitlab和sourcetree的使用</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2017 <a href="/">sopig</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>