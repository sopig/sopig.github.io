<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Double Dispatch模式及其在iOS开发中实践 · xiao</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2014/04/13/2014-04-13-double-dispatchmo-shi-ji-qi-zai-ioskai-fa-zhong-shi-zhan/" class="post-title-link">Double Dispatch模式及其在iOS开发中实践</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/iOS/" class="post-tag-link">iOS</a></li><li class="post-tag-item"><a href="/tags/设计模式/" class="post-tag-link">设计模式</a></li><li class="post-tag-item"><a href="/tags/Objective-C/" class="post-tag-link">Objective-C</a></li><li class="post-tag-item"><a href="/tags/碰撞检测/" class="post-tag-link">碰撞检测</a></li></ul><div class="post-time">Sunday, April 13th 2014</div></div><div class="post-content"><p>##本文内容</p>
<ul>
<li>引子</li>
<li>C++中的Double Dispatch实例</li>
<li>Java中的Double Dispatch实例</li>
<li>Objective-C中实现碰撞检测用到的Visitor模式</li>
</ul>
<a id="more"></a>
<p>##引子<br>在一个太空大战游戏中，导弹可以撞向飞船，也可能撞向行星，所以在碰撞检测的时候就需要判断碰撞的结果。假设游戏有四种物体：飞船，陨石，行星，导弹，那么就产生了<code>4*3/2+4</code>种情形（一枚导弹撞上另一枚导弹）。这种排列组合计算出的结果会随着物体种类N的增多爆炸性增长，如果这个时候还用一堆if－else来检测碰撞，那真是<code>Naive</code>了。这时我们可以利用面向对象语言的多态性质来在程序运行时动态绑定，因为碰撞检测是一种“双向选择”，所以我们需要<code>double dispatch</code>（双分派），<code>Visitor</code>模式就是<code>double dispatch</code>的一种应用。<br><img src="http://7ni3rk.com1.z0.glb.clouddn.com/14035338896.jpg?imageView2/2/w/800/q/75|watermark/2/text/eXVsaW5ndGlhbnhpYQ==/font/Y29taWMgc2FucyBtcw==/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="Visitor模式">   </p>
<p>DD模式适合于处理多个对象之间的相互作用。假如不用DD模式的话，那么每个对象跟别的对象发生关系时，就必须辛辛苦苦的进行if…else…枚举，因为它并不知道对方是何神圣。DD模式的引入解决了这个问题，其实说白了就是利用语言内置的虚函数机制来替你干活，把工作移交给编译器去做了。  </p>
<p>##C++中的Double Dispatch实例<br>本节内容摘自<a href="http://www.cnblogs.com/west-link/archive/2011/07/26/2116887.html?imageView2/2/w/800/q/75|watermark/2/text/eXVsaW5ndGlhbnhpYQ==/font/Y29taWMgc2FucyBtcw==/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" target="_blank" rel="external">这里</a><br>我们先从字面上去理解它吧，直观地说，它指的是两次dispatch。这里的dispatch指的是什么呢？举个例子：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span></span></div><div class="line"><span class="class">   &#123;</span></div><div class="line">       <span class="keyword">public</span>:</div><div class="line">           <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintName</span><span class="params">()</span></span></div><div class="line"><span class="function">           </span>&#123;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"我是通用事件"</span>&lt;&lt;<span class="built_in">endl</span>;           </div><div class="line">           &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">KeyEvent</span>:</span><span class="keyword">public</span> Event</div><div class="line">   &#123;</div><div class="line">      <span class="keyword">public</span>:</div><div class="line">           <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintName</span><span class="params">()</span></span></div><div class="line"><span class="function">           </span>&#123;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"我是按键事件"</span>&lt;&lt;<span class="built_in">endl</span>;           </div><div class="line">           &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">ClickEvent</span>:</span><span class="keyword">public</span> Event</div><div class="line">   &#123;</div><div class="line">       <span class="keyword">public</span>:</div><div class="line">           <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintName</span><span class="params">()</span></span></div><div class="line"><span class="function">           </span>&#123;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"我是单击事件"</span>&lt;&lt;<span class="built_in">endl</span>;           </div><div class="line">           &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>多态性是动态的，被调用的方法由对象的真正类型确定，这个过程就被称之为dispatch。例如在C++中，每个对象都有一个虚函数表，当用基类的类型引用子类对象时，虚函数指针指向的是子类的虚函数表，调用的虚函数都是子类中的版本，所以下面代码输出的是：“我是按键事件”，这就算是一次dispatch的过程，即根据对象类型来动态确定调用哪个函数的过程。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Event* pEvent = new KeyEvent();</div><div class="line">pEvent-&gt;PrintName();</div></pre></td></tr></table></figure>
<p>什么时候会用到两次dispatch呢? 继续往下看：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">class EventRecorder</div><div class="line">   &#123;</div><div class="line">       public:</div><div class="line">           virtual void RecordEvent(Event* event)</div><div class="line">           &#123;</div><div class="line">               cout&lt;&lt;&quot;使用EventRecorder记录通用事件&quot;&lt;&lt; endl;           </div><div class="line">           &#125;</div><div class="line">           </div><div class="line">           virtual void RecordEvent(KeyEvent* event)</div><div class="line">           &#123;</div><div class="line">               cout&lt;&lt;&quot;使用EventRecorder记录按键事件&quot;&lt;&lt; endl;           </div><div class="line">           &#125;</div><div class="line">           </div><div class="line">           virtual void RecordEvent(ClickEvent* event)</div><div class="line">           &#123;</div><div class="line">               cout&lt;&lt;&quot;使用EventRecorder记录单击事件&quot;&lt;&lt; endl;           </div><div class="line">           &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   class AdvanceEventRecorder:public EventRecorder</div><div class="line">   &#123;</div><div class="line">       public:</div><div class="line">           virtual void RecordEvent(Event* event)</div><div class="line">           &#123;</div><div class="line">               cout&lt;&lt;&quot;使用高级EventRecorder记录通用事件&quot;&lt;&lt; endl;           </div><div class="line">           &#125;</div><div class="line">           </div><div class="line">           virtual void RecordEvent(KeyEvent* event)</div><div class="line">           &#123;</div><div class="line">               cout&lt;&lt;&quot;使用高级EventRecorder记录按键事件&quot;&lt;&lt; endl;           </div><div class="line">           &#125;</div><div class="line">           </div><div class="line">           virtual void RecordEvent(ClickEvent* event)</div><div class="line">           &#123;</div><div class="line">               cout&lt;&lt;&quot;使用高级EventRecorder记录单击事件&quot;&lt;&lt; endl;           </div><div class="line">           &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这两个类中分别包含三个重载函数，多态是动态的，而函数重载则是静态的，它在编译时期就确定下来了，所以，下面代码片段的运行结果并不是我们所期望的:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventRecorder* pRecorder = new AdvanceEventRecorder();</div><div class="line">Event* pEvent = new KeyEvent();</div><div class="line">pRecorder-&gt;RecordEvent(pEvent);</div></pre></td></tr></table></figure>
<p>输出内容为：使用高级EventRecorder记录通用事件<br>实际上，在这个场景中，我们期望调用的是：AdvanceEventRecorder::RecordEvent(KeyEvent* event)<br>下面我们使用Double Dispatch设计模式来达到上面的代码片段的目的，在所有Event对象中增加下面的函数：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">virtual void RecordEvent(EventRecorder* recorder)</div><div class="line">&#123;</div><div class="line">   recorder-&gt;RecordEvent(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面的代码片段将输出：使用高级EventRecorder记录按键事件  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventRecorder* pRecorder = new AdvanceEventRecorder();</div><div class="line">  	Event* pEvent = new KeyEvent();</div><div class="line">  	pEvent-&gt;RecordEvent(pRecorder);</div></pre></td></tr></table></figure>
<p>可以看出，第一次dispatch正确地找到了<code>KeyEvent</code>的<code>RecordEvent(EventRecorder* recorder)</code>，第二次dispatch找到了<code>AdvanceEventRecorder</code>的<code>RecordEvent(KeyEvent* event)</code>。<br>   Visitor模式就是对Double Dispatch的应用，另外，在碰撞检测算法中也会经常用到。</p>
<p>##Java中的Double Dispatch实例<br>本节参考自<a href="http://www.blogjava.net/chaocai/archive/2009/02/19/255640.html" target="_blank" rel="external">这里</a><br>相对于C++中使用继承来说，Java提供的接口和函数重载让Double Dispatch模式更容易实现  </p>
<p>###1 根据对象来选择行为问题  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Event</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlueEvent</span> <span class="keyword">implements</span> <span class="title">Event</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedEvent</span> <span class="keyword">implements</span> <span class="title">Event</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Event event)</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"It is event"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(RedEvent event)</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"It is RedEvent"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(BlueEvent event)</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"It is BlueEvent"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Event evt=<span class="keyword">new</span> BlueEvent();</div><div class="line"><span class="keyword">new</span> Handler().handle(evt);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你认为运行结果是什么呢？<br>结果：It is event<br>是不是有点出乎意料，不是It is BlueEvent，<strong>这是因为Overload并不支持在运行时根据参数的运行时类型来绑定方法</strong>，所以要执行哪个方法是在编译时就选定了的。    </p>
<p>###2 Double Dispatch Pattern<br>由于Java,C++及C#都具有上述局限，通常我们只能通过Switch或if结构来实现，当然这种实现方式既不优雅而且影响代码的可维护性。<br>通过以下的Double Dispatch Pattern便可以优雅的实现。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public interface Event &#123;</div><div class="line">public void injectHandler(EventHandler v);</div><div class="line">&#125;</div><div class="line">public class BlueEvent implements Event &#123;</div><div class="line">public void injectHandler(EventHandler v) &#123;</div><div class="line">v.handle(this);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class RedEvent implements Event &#123;</div><div class="line">public void injectHandler(EventHandler v) &#123;</div><div class="line">v.handle(this);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class EventHandler &#123;</div><div class="line">public void handle(BlueEvent e)&#123;</div><div class="line">System.out.println(&quot;It is BlueEvent&quot;);</div><div class="line">&#125;</div><div class="line">public void handle(RedEvent e)&#123;</div><div class="line">System.out.println(&quot;It is RedEvent&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Main &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">Event evt=new BlueEvent();</div><div class="line">evt.injectHandler(new EventHandler());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##Objective-C中实现碰撞检测用到的Visitor模式</p>
<p>虽然OC不支持函数重载，但是我们可以老老实实的用方法名来区分类似<code>visitXXX</code>的访问方法，并利用OC其独有的SEL类型可以很好的在运行时判断该调用哪个方法  </p>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/140353389425.jpg?imageView2/2/w/800/q/75|watermark/2/text/eXVsaW5ndGlhbnhpYQ==/font/Y29taWMgc2FucyBtcw==/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="">   </p>
<p>感谢kouky提供的iOS上碰撞检测的<a href="https://github.com/kouky/iOS-SpriteKit-Pong" target="_blank" rel="external">Demo</a>，这里他用到了Visitor模式<br>由于判断物体类型是用一个32位掩码来标记，所以这里不可避免的要用到if语句，这不代表它不是动态绑定，因为if语句是在初始化方法<code>+ (id)contactVisitorWithBody:(SKPhysicsBody *)body forContact:(SKPhysicsContact *)contact</code>中其作用的，只是为了判断物体类型，而不是判断碰撞两者的组合类型<br>可以参考我写的例子<a href="https://github.com/yulingtianxia/MyFirstGame/tree/master/ColorAtom" target="_blank" rel="external">ColorAtom</a>  </p>
<p>首先新建一个访问者基本类<code>ContactVisitor</code>，其本质为对SKPhysicsBody和SKPhysicsContact对象的封装，而SKPhysicsContact在本例中虽未用到（因为碰撞检测后啥也没干，只输出了碰撞双方name），但其保存着碰撞坐标等信息，也很重要。两次dispatch都是在访问者基本类实现的，而碰撞后具体操作则卸载了访问者具体类（如AtomNodeContactVisitor）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//  ContactVisitor.h</span></div><div class="line"><span class="comment">//  ColorAtom</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by 杨萧玉 on 14-4-13.</span></div><div class="line"><span class="comment">//  Copyright (c) 2014年 杨萧玉. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;SpriteKit/SpriteKit.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ContactVisitor</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">SKPhysicsBody</span> *body;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">SKPhysicsContact</span> *contact;</div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>)contactVisitorWithBody:(<span class="built_in">SKPhysicsBody</span> *)body forContact:(<span class="built_in">SKPhysicsContact</span> *)contact;</div><div class="line">- (<span class="keyword">void</span>)visit:(<span class="built_in">SKPhysicsBody</span> *)body;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>属性body即为访问者的SKPhysicsBody，而方法<code>visit:</code>的参数为被访问者的SKPhysicsBody<br><code>contactVisitorWithBody:forContact:</code>方法的作用是根据掩码类型初始化对应类型的访问者具体类  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  ContactVisitor.m</div><div class="line">//  ColorAtom</div><div class="line">//</div><div class="line">//  Created by 杨萧玉 on 14-4-13.</div><div class="line">//  Copyright (c) 2014年 杨萧玉. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;ContactVisitor.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">#import &quot;NodeCategories.h&quot;</div><div class="line">#import &quot;AtomNodeContactVisitor.h&quot;</div><div class="line">#import &quot;PlayFieldSceneContactVisitor.h&quot;</div><div class="line">@implementation ContactVisitor</div><div class="line">+ (id)contactVisitorWithBody:(SKPhysicsBody *)body forContact:(SKPhysicsContact *)contact</div><div class="line">&#123;</div><div class="line">    //第一次dispatch，通过node类别返回对应的实例</div><div class="line">    if ((body.categoryBitMask&amp;AtomCategory)!=0) &#123;</div><div class="line">        return [[AtomNodeContactVisitor alloc] initWithBody:body forContact:contact];</div><div class="line">    &#125;</div><div class="line">    if ((body.categoryBitMask&amp;PlayFieldCategory)!=0) &#123;</div><div class="line">        return [[PlayFieldSceneContactVisitor alloc] initWithBody:body forContact:contact];</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithBody:(SKPhysicsBody *)body forContact:(SKPhysicsContact *)contact</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _contact = contact;</div><div class="line">        _body = body;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)visit:(SKPhysicsBody *)body</div><div class="line">&#123;</div><div class="line">    //第二次dispatch，通过构造方法名来执行对应方法</div><div class="line">    // 生成node的名字，比如&quot;AtomNode&quot;</div><div class="line">    NSString *bodyClassName = [NSString stringWithUTF8String:class_getName(body.node.class)];</div><div class="line">    </div><div class="line">    // 生成方法名，比如&quot;visitAtomBody&quot;</div><div class="line">    NSMutableString *contactSelectorString = [NSMutableString stringWithFormat:@&quot;visit&quot;];</div><div class="line">    [contactSelectorString appendString:bodyClassName];</div><div class="line">    [contactSelectorString appendString:@&quot;:&quot;];</div><div class="line">    </div><div class="line">    SEL selector = NSSelectorFromString(contactSelectorString);</div><div class="line">    //判断是否存在此方法</div><div class="line">    if ([self respondsToSelector:selector]) &#123;</div><div class="line">        [self performSelector:selector withObject:body];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以访问者具体类以<code>AtomNodeContactVisitor</code>类为例，它继承自访问者基本类ContactVisitor  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//</div><div class="line">//  AtomNodeContactVisitor.h</div><div class="line">//  ColorAtom</div><div class="line">//</div><div class="line">//  Created by 杨萧玉 on 14-4-13.</div><div class="line">//  Copyright (c) 2014年 杨萧玉. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;ContactVisitor.h&quot;</div><div class="line"></div><div class="line">@interface AtomNodeContactVisitor : ContactVisitor</div><div class="line"></div><div class="line">/*Atom访问了Atom，同类碰撞*/</div><div class="line">-(void) visitAtomNode:(SKPhysicsBody*) anotherAtomBody;</div><div class="line">/*Atom访问了边界，也就是球撞墙上了*/</div><div class="line">-(void) visitPlayFieldScene:(SKPhysicsBody*) playfieldBody;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在处理碰撞后的visitXXX方法中，我将碰撞双方的访问者和被访问者的关系输出  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  AtomNodeContactVisitor.m</div><div class="line">//  ColorAtom</div><div class="line">//</div><div class="line">//  Created by 杨萧玉 on 14-4-13.</div><div class="line">//  Copyright (c) 2014年 杨萧玉. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;AtomNodeContactVisitor.h&quot;</div><div class="line">#import &quot;AtomNode.h&quot;</div><div class="line">#import &quot;PlayFieldScene.h&quot;</div><div class="line">@implementation AtomNodeContactVisitor</div><div class="line">-(void) visitAtomNode:(SKPhysicsBody*) anotherAtomBody</div><div class="line">&#123;</div><div class="line">    AtomNode *thisAtom = (AtomNode*)self.body.node;</div><div class="line">    AtomNode *anotherAtom = (AtomNode*)anotherAtomBody.node;</div><div class="line">    //处理碰撞后的结果</div><div class="line">    NSLog(@&quot;%@-&gt;%@&quot;,thisAtom.name,anotherAtom.name);</div><div class="line">&#125;</div><div class="line">-(void) visitPlayFieldScene:(SKPhysicsBody*) playfieldBody</div><div class="line">&#123;</div><div class="line">    AtomNode *atom = (AtomNode*)self.body.node;</div><div class="line">    PlayFieldScene *playfield = (PlayFieldScene*) playfieldBody.node;</div><div class="line">    NSLog(@&quot;%@-&gt;%@&quot;,atom.name,playfield.name);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>下面建立被访问者类，其本质就是对SKPhysicsBody的封装，并接受Visitor的注入  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  VisitablePhysicsBody.h</div><div class="line">//  ColorAtom</div><div class="line">//</div><div class="line">//  Created by 杨萧玉 on 14-4-13.</div><div class="line">//  Copyright (c) 2014年 杨萧玉. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;ContactVisitor.h&quot;</div><div class="line">@interface VisitablePhysicsBody : NSObject</div><div class="line">@property (nonatomic, readonly, strong) SKPhysicsBody *body;</div><div class="line"></div><div class="line">- (id) initWithBody:(SKPhysicsBody *)body;</div><div class="line">- (void) acceptVisitor:(ContactVisitor *)visitor;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>关键的一步：在<code>acceptVisitor:</code>方法中调用访问者的<code>visit:</code>方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  VisitablePhysicsBody.m</div><div class="line">//  ColorAtom</div><div class="line">//</div><div class="line">//  Created by 杨萧玉 on 14-4-13.</div><div class="line">//  Copyright (c) 2014年 杨萧玉. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;VisitablePhysicsBody.h&quot;</div><div class="line"></div><div class="line">@implementation VisitablePhysicsBody</div><div class="line">- (id)initWithBody:(SKPhysicsBody *)body</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _body = body;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)acceptVisitor:(ContactVisitor *)visitor</div><div class="line">&#123;</div><div class="line">    [visitor visit:self.body];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>可能有人会有疑问，<code>visit:</code>方法穿入的参数类型永远是<code>SKPhysicsBody</code>，这哪里是动态绑定啊，其实是由于本例的特殊性，碰撞检测时区分物体类型不是靠<code>SKPhysicsBody</code>子类化来区分和绑定，而是靠SKPhysicsBody类中的<code>categoryBitMask</code>属性来区分，这也就免不了需要在<code>ContactVisitor</code>初始化的时候通过if语句来判断具体初始化哪个子类<br>最后，在Scene实现SKPhysicsContactDelegate协议  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#pragma mark SKPhysicsContactDelegate</div><div class="line">-(void)didBeginContact:(SKPhysicsContact *)contact</div><div class="line">&#123;</div><div class="line">    //A-&gt;B</div><div class="line">    ContactVisitor *visitorA = [ContactVisitor contactVisitorWithBody:contact.bodyA forContact:contact];</div><div class="line">    VisitablePhysicsBody *visitableBodyB = [[VisitablePhysicsBody alloc] initWithBody:contact.bodyB];</div><div class="line">    [visitableBodyB acceptVisitor:visitorA];</div><div class="line">    //B-&gt;A</div><div class="line">    ContactVisitor *visitorB = [ContactVisitor contactVisitorWithBody:contact.bodyB forContact:contact];</div><div class="line">    VisitablePhysicsBody *visitableBodyA = [[VisitablePhysicsBody alloc] initWithBody:contact.bodyA];</div><div class="line">    [visitableBodyA acceptVisitor:visitorB];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>物理老师总说力的作用时相互的，所以我们需要两次访问：A访问B和B访问A，但是这样会调用两次visitXXX方法，原则上这两个逻辑上对称的方法我们只需要实现其中一个就可以，但必须得像上面代码一样，A-&gt;B和B-&gt;A缺一不可，因为碰撞的时候我们不知道bodyA和bodyB的类型，也就无法判断visitXXX方法是A-&gt;B时能调用还是B-&gt;A时能调用到<br>当然，你也可以两个visit方法都实现，但只对visitor的node做操作，或只对visitable的node操作，总之仁者见仁智者见智啦</p>
</div></article><div class="pagination"><a href="/2014/04/17/2014-04-17-shen-ru-li-jie-typedef/" class="pagination-prev">PREV</a><a href="/2014/04/09/2014-04-09-iosde-dot-gitignore/" class="pagination-next">NEXT</a></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARC/">ARC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/App-Extensions/">App Extensions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AppGroups/">AppGroups</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/24/一首小诗/">1024,一首小诗</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/终有一天/">终有一天.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/樱花樱花想见你/">樱花樱花想见你</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/工具本/">小tips汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/CI搭建和脚本自动化/">CI搭建和脚本自动化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/01/又要春节了啊/">又要春节了啊</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/写给PM的iOS消息推送/">写给PM的iOS消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/19/gitlab和sourcetree的使用/">gitlab和sourcetree的使用</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2017 <a href="/">sopig</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?38155daa8b79fb3a5cad11d825228868";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>