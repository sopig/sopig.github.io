<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS单例模式 or NSUserDefaults · xiao</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2014/04/07/2014-04-07-iosdan-li-mo-shi-ornsuserdefaults/" class="post-title-link">iOS单例模式 or NSUserDefaults</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/iOS/" class="post-tag-link">iOS</a></li><li class="post-tag-item"><a href="/tags/设计模式/" class="post-tag-link">设计模式</a></li></ul><div class="post-time">Monday, April 7th 2014</div></div><div class="post-content"><p>本文内容：  </p>
<ul>
<li>iOS的单例模式</li>
<li>NSUserDefaults的使用</li>
<li>总结：iOS单例模式 and NSUserDefaults<a id="more"></a>
</li>
</ul>
<p>#iOS的单例模式<br>提起单例模式大家都不陌生，什么懒汉式，饿汉式，老汉式。。。扯远了  </p>
<p>一开始觉得Objective－C中没有绝对的私有方法，该如何实现单例模式呢？后来觉得想多了，限制构造方法的使用式徒劳的，因为程序是人写的，既然是单例了，那就老老实实调用自己写的getInstance吧。Java笑了？一个反射打趴下！<br>在ARC诞生之前，可以通过重写<code>allocWithZone</code>方法等来实现，下面是苹果官方的单例写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">static MyGizmoClass *sharedGizmoManager = nil; </div><div class="line">+ (MyGizmoClass*)sharedManager</div><div class="line">&#123;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        if (sharedGizmoManager == nil) &#123;</div><div class="line">            [[self alloc] init]; // assignment not done here</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sharedGizmoManager;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">+ (id)allocWithZone:(NSZone *)zone</div><div class="line">&#123;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        if (sharedGizmoManager == nil) &#123;</div><div class="line">            sharedGizmoManager = [super allocWithZone:zone];</div><div class="line">            return sharedGizmoManager;  // assignment and return on first allocation</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil; //on subsequent allocation attempts return nil</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (id)copyWithZone:(NSZone *)zone</div><div class="line">&#123;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (id)retain</div><div class="line">&#123;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (unsigned)retainCount</div><div class="line">&#123;</div><div class="line">    return UINT_MAX;  //denotes an object that cannot be released</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)release</div><div class="line">&#123;</div><div class="line">    //do nothing</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (id)autorelease</div><div class="line">&#123;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在ARC时代，程序员不用费心计算static的实例被引用多少次，需要release巴拉巴拉。。。而自从有了GCD，iOS的单例模式变得超级简单了：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (Singleton *)sharedInstance&#123;</div><div class="line">    static id instance = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        instance = [[self alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>instance为将被实例化的对象，为了让instance只被实例化一次，用到了GCD(Grand Central Dispatch)中的<code>dispatch_once</code>方法。该方法有两个参数，第二个参数是一个block，只会被执行一次。而第一个参数是一个谓词，用于判断代码块（block）是否执行完，这个谓词只能是全局或静态变量，类型为dispatch_once_t，其实dispatch_once_t就是long类型。你可以理解为第一个参数是个标识位，能保证记录第二个参数block的执行情况，即使是在最复杂的多线程并发执行的情况下，也就是说，GCD的这个方法是线程安全的。如果你对block这种类型比较陌生，可以把它暂时当作函数指针，当然，它比函数指针还要强大。<br>你可以重写init方法来实现饿汉式单例，也可以自定义initwithXXX来在需要实例化的时候调用之，实现懒汉式单例。  </p>
<p>#NSUserDefaults<br>很多APP启动时需要读取上次运行保存的一些状态，如何保存呢？Core Data，SQlite和UIDocuments未免杀鸡用牛刀了，而<code>NSUserDefaults</code>很适用于快速读取小规模的数据  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];</div></pre></td></tr></table></figure>
<p>写入数据  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;hahaha&quot;;</div><div class="line">[standardDefaults setObject:string forKey:@&quot;myKey&quot;];</div><div class="line">[standardDefaults synchronize];//写完别忘了同步</div></pre></td></tr></table></figure>
<p>读取数据  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *value = [standardDefaults objectForKey:@&quot;myKey&quot;];</div></pre></td></tr></table></figure>
<p><code>NSUserDefaults</code>可以很好地理解成键值对  </p>
<p>有时在写数据之前，想判断下这个健是否已经设置过默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];</div><div class="line">if ([standardDefaults stringForKey:@&quot;favoriteColor&quot;] == nil) &#123;</div><div class="line">[standardDefaults setObject:@&quot;Green&quot; forKey:@&quot;favoriteColor&quot;];</div><div class="line">[standardDefaults synchronize];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实大可不必这么麻烦，摘自<a href="http://beyondvincent.com/blog/2013/04/20/13/" target="_blank" rel="external">破船</a>推荐的方法<code>registerDefaults:</code>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];</div><div class="line">[standardDefaults registerDefaults:@&#123;@&quot;favoriteColor&quot;: @&quot;Green&quot;&#125;];</div><div class="line">[standardDefaults synchronize];</div></pre></td></tr></table></figure>
<p>每次程序启动的时候调用<code>registerDefaults:</code> 方法都是安全的。完全可以将这个方法的调用放到<code>applicationDidFinishLaunching:</code>方法中. 这个方法永远都不会覆盖用户设置的值。<br>但是并不是所有类型的对象都能够直接放入NSUserDefaults，NSUserDefaults只支持： NSString, NSNumber, NSDate, NSArray, NSDictionary<br>解决方法：让这个自定义的类实现<nscoding>协议，举个例子： </nscoding></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//SNShops.h</div><div class="line"></div><div class="line">@interface SNShops : NSObject&lt;NSCoding&gt;</div><div class="line"></div><div class="line">@property (nonatomic,strong) NSString* sid;</div><div class="line">@property (nonatomic,strong) NSString* name;</div><div class="line"></div><div class="line">- (id) initWithCoder: (NSCoder *)coder;</div><div class="line">- (void) encodeWithCoder: (NSCoder *)coder;</div><div class="line"></div><div class="line">//SNShops.m</div><div class="line">@implementation SNShops</div><div class="line">- (id) initWithCoder: (NSCoder *)coder</div><div class="line">&#123;</div><div class="line">    if (self = [super init])</div><div class="line">    &#123;</div><div class="line">        self.sid = [coder decodeObjectForKey:@&quot;sid&quot;];</div><div class="line">        self.name = [coder decodeObjectForKey:@&quot;name&quot;];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">- (void) encodeWithCoder: (NSCoder *)coder</div><div class="line">&#123;</div><div class="line">    [coder encodeObject:self.sid forKey:@&quot;sid&quot;];</div><div class="line">    [coder encodeObject:self.name forKey:@&quot;name&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后再存取时通过<code>NSData</code>做载体：<br>存入  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];</div><div class="line">SNShops *shop = [[SNShops alloc]init];</div><div class="line">NSData *shopData = [NSKeyedArchiver archivedDataWithRootObject:shop];</div><div class="line">[standardDefaults setObject:shopData forKey:@&quot;myshop&quot;];</div><div class="line">[standardDefaults synchronize];</div></pre></td></tr></table></figure>
<p>读取  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSData *newshopData = [standardDefaults objectForKey:&quot;myshop&quot;];</div><div class="line">SNShops *newshop = [NSKeyedUnarchiver unarchiveObjectWithData:newshopData];</div></pre></td></tr></table></figure>
<p>#总结：iOS单例模式 and NSUserDefaults<br>单例模式虽然能存入任何类型的对象，但是它会随着程序的挂起而消亡。而NSUserDefaults在读取自定义类型时有些繁琐，降低编码效率和可读性，好处是程序下次启动依然能读取到上次的状态。<br>笔者在实际应用中采取了二者结合的模式：让单例模式的类实现<nscoding>协议，程序第一次启动的时候通过NSData做载体读取单例类的实例，并存入单例，程序运行中一直对单例做存储操作，当程序快要进入到后台挂起的时候，通过NSData做载体存入NSUserDefaults，一举两得。</nscoding></p>
</div></article><div class="pagination"><a href="/2014/04/09/2014-04-09-iosde-dot-gitignore/" class="pagination-prev">PREV</a><a href="/2014/04/07/2014-04-07-ioscheng-xu-yuan-bi-bei-wang-zhan/" class="pagination-next">NEXT</a></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARC/">ARC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/App-Extensions/">App Extensions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AppGroups/">AppGroups</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/24/一首小诗/">1024,一首小诗</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/终有一天/">终有一天.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/樱花樱花想见你/">樱花樱花想见你</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/工具本/">小tips汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/CI搭建和脚本自动化/">CI搭建和脚本自动化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/01/又要春节了啊/">又要春节了啊</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/写给PM的iOS消息推送/">写给PM的iOS消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/19/gitlab和sourcetree的使用/">gitlab和sourcetree的使用</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2017 <a href="/">sopig</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?38155daa8b79fb3a5cad11d825228868";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>