<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ReactiveCocoa学习笔记 · xiao</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="https://github.com/xxxxxx" target="_blank" class="nav-link">github</a></li><li class="nav-list-item"><a href="https://coding.net/u/xxxxxx" target="_blank" class="nav-link">coding</a></li><li class="nav-list-item"><a href="http://weibo.com/xxxxxx" target="_blank" class="nav-link">weibo</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2014/07/29/2014-07-29-reactivecocoa/" class="post-title-link">ReactiveCocoa学习笔记</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/RAC/" class="post-tag-link">RAC</a></li></ul><div class="post-time">Tuesday, July 29th 2014</div></div><div class="post-content"><p>几个月前看了一点RAC的介绍，感觉很强大但也很难入门，这次挖个坑，整理下RAC的资源。</p>
<a id="more"></a>
<p>##官方介绍</p>
<p>ReactiveCocoa 受<a href="http://blog.maybeapps.com/post/42894317939/input-and-output" target="_blank" rel="external">函数响应式编程</a>激发。不同于使用可变的变量替换和就地修改，RAC提供Signals（被表示为<code>RACSignal</code>）来捕获当前值和将来值。</p>
<p>通过链接（chaining），组合（combining）和对Signals做出反应（reacting），我们不必频繁地观察并更新值，而是声明式编写软件。</p>
<p>比如，文本域可以绑定到最新的时间，当它变化时，不需用额外的代码来观察时间每秒钟更新文本域。它类似KVO，但是用blocks替代了重写 <code>-observeValueForKeyPath:ofObject:change:context:</code>。</p>
<p>Signals也可以表示异步操作，很像<a href="http://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" rel="external">futures and promises</a>。这极大地简化了异步编码，包括网络方面的代码。</p>
<p>RAC一个重要的优点就是它提供了单独的、统一的方法来处理异步行为，包括委托方法，回调blocks，target-action机制，通知和KVO。</p>
<p>这有一个简单的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// When self.username changes, logs the new name to the console.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// RACObserve(self, username) creates a new RACSignal that sends the current</span></div><div class="line"><span class="comment">// value of self.username, then the new value whenever it changes.</span></div><div class="line"><span class="comment">// -subscribeNext: will execute the block whenever the signal sends a value.</span></div><div class="line">[RACObserve(<span class="keyword">self</span>, username) subscribeNext:^(<span class="built_in">NSString</span> *newName) &#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, newName);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>但是不同于KVO通知，signals可以链接在一起操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Only logs names that starts with &quot;j&quot;.</div><div class="line">//</div><div class="line">// -filter returns a new RACSignal that only sends a new value when its block</div><div class="line">// returns YES.</div><div class="line">[[RACObserve(self, username)</div><div class="line">   filter:^(NSString *newName) &#123;</div><div class="line">       return [newName hasPrefix:@&quot;j&quot;];</div><div class="line">   &#125;]</div><div class="line">   subscribeNext:^(NSString *newName) &#123;</div><div class="line">       NSLog(@&quot;%@&quot;, newName);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p>Signals也可以被用于导出状态。不必观察属性然后设置其他属性来响应这个属性新的值，RAC可以依照signals和操作来表达属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Creates a one-way binding so that self.createEnabled will be</div><div class="line">// true whenever self.password and self.passwordConfirmation</div><div class="line">// are equal.</div><div class="line">//</div><div class="line">// RAC() is a macro that makes the binding look nicer.</div><div class="line">// </div><div class="line">// +combineLatest:reduce: takes an array of signals, executes the block with the</div><div class="line">// latest value from each signal whenever any of them changes, and returns a new</div><div class="line">// RACSignal that sends the return value of that block as values.</div><div class="line">RAC(self, createEnabled) = [RACSignal </div><div class="line">   combineLatest:@[ RACObserve(self, password), RACObserve(self, passwordConfirmation) ] </div><div class="line">   reduce:^(NSString *password, NSString *passwordConfirm) &#123;</div><div class="line">      return @([passwordConfirm isEqualToString:password]);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p>Signals可以建立在任意值随时间的流动上，不仅仅是KVO。比如，它们也能表示按钮被按下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Logs a message whenever the button is pressed.</div><div class="line">//</div><div class="line">// RACCommand creates signals to represent UI actions. Each signal can</div><div class="line">// represent a button press, for example, and have additional work associated</div><div class="line">// with it.</div><div class="line">//</div><div class="line">// -rac_command is an addition to NSButton. The button will send itself on that</div><div class="line">// command whenever it&apos;s pressed.</div><div class="line">self.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^(id _) &#123;</div><div class="line">   NSLog(@&quot;button was pressed!&quot;);</div><div class="line">   return [RACSignal empty];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>或者异步网络操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// Hooks up a &quot;Log in&quot; button to log in over the network.</div><div class="line">//</div><div class="line">// This block will be run whenever the login command is executed, starting</div><div class="line">// the login process.</div><div class="line">self.loginCommand = [[RACCommand alloc] initWithSignalBlock:^(id sender) &#123;</div><div class="line">   // The hypothetical -logIn method returns a signal that sends a value when</div><div class="line">   // the network request finishes.</div><div class="line">   return [client logIn];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// -executionSignals returns a signal that includes the signals returned from</div><div class="line">// the above block, one for each time the command is executed.</div><div class="line">[self.loginCommand.executionSignals subscribeNext:^(RACSignal *loginSignal) &#123;</div><div class="line">   // Log a message whenever we log in successfully.</div><div class="line">   [loginSignal subscribeCompleted:^&#123;</div><div class="line">      NSLog(@&quot;Logged in successfully!&quot;);</div><div class="line">   &#125;];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// Executes the login command when the button is pressed.</div><div class="line">self.loginButton.rac_command = self.loginCommand;</div></pre></td></tr></table></figure>
<p>Signals也能表示定时器，其他UI事件，或者任何其他随时间而改变的东西。</p>
<p>通过链接和转换这些Signals，可以为异步操作建立更加复杂的行为。在一组操作完成后，后续工作能容易地被触发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// Performs 2 network operations and logs a message to the console when they are</div><div class="line">// both completed.</div><div class="line">//</div><div class="line">// +merge: takes an array of signals and returns a new RACSignal that passes</div><div class="line">// through the values of all of the signals and completes when all of the</div><div class="line">// signals complete.</div><div class="line">//</div><div class="line">// -subscribeCompleted: will execute the block when the signal completes.</div><div class="line">[[RACSignal </div><div class="line">   merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]] </div><div class="line">   subscribeCompleted:^&#123;</div><div class="line">      NSLog(@&quot;They&apos;re both done!&quot;);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p>Signals可以被链接起来按顺序地执行异步操作，而不用嵌套回调blocks。这类似<a href="http://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" rel="external">futures and promises</a>是如何经常使用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// Logs in the user, then loads any cached messages, then fetches the remaining</div><div class="line">// messages from the server. After that&apos;s all done, logs a message to the</div><div class="line">// console.</div><div class="line">//</div><div class="line">// The hypothetical -logInUser methods returns a signal that completes after</div><div class="line">// logging in.</div><div class="line">//</div><div class="line">// -flattenMap: will execute its block whenever the signal sends a value, and</div><div class="line">// returns a new RACSignal that merges all of the signals returned from the block</div><div class="line">// into a single signal.</div><div class="line">[[[[client </div><div class="line">   logInUser] </div><div class="line">   flattenMap:^(User *user) &#123;</div><div class="line">      // Return a signal that loads cached messages for the user.</div><div class="line">      return [client loadCachedMessagesForUser:user];</div><div class="line">   &#125;]</div><div class="line">   flattenMap:^(NSArray *messages) &#123;</div><div class="line">      // Return a signal that fetches any remaining messages.</div><div class="line">      return [client fetchMessagesAfterMessage:messages.lastObject];</div><div class="line">   &#125;]</div><div class="line">   subscribeNext:^(NSArray *newMessages) &#123;</div><div class="line">      NSLog(@&quot;New messages: %@&quot;, newMessages);</div><div class="line">   &#125; completed:^&#123;</div><div class="line">      NSLog(@&quot;Fetched all messages.&quot;);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p>RAC甚至使绑定到异步操作结果更加容易：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// Creates a one-way binding so that self.imageView.image will be set the user&apos;s</div><div class="line">// avatar as soon as it&apos;s downloaded.</div><div class="line">//</div><div class="line">// The hypothetical -fetchUserWithUsername: method returns a signal which sends</div><div class="line">// the user.</div><div class="line">//</div><div class="line">// -deliverOn: creates new signals that will do their work on other queues. In</div><div class="line">// this example, it&apos;s used to move work to a background queue and then back to the main thread.</div><div class="line">//</div><div class="line">// -map: calls its block with each user that&apos;s fetched and returns a new</div><div class="line">// RACSignal that sends values returned from the block.</div><div class="line">RAC(self.imageView, image) = [[[[client </div><div class="line">   fetchUserWithUsername:@&quot;joshaber&quot;]</div><div class="line">   deliverOn:[RACScheduler scheduler]]</div><div class="line">   map:^(User *user) &#123;</div><div class="line">      // Download the avatar (this is done on a background queue).</div><div class="line">      return [[NSImage alloc] initWithContentsOfURL:user.avatarURL];</div><div class="line">   &#125;]</div><div class="line">   // Now the assignment will be done on the main thread.</div><div class="line">   deliverOn:RACScheduler.mainThreadScheduler];</div></pre></td></tr></table></figure>
<p>上面示范了RAC能做什么，但它没示范RAC为何这么强大。用README的篇幅的例子很难赞美RAC，但是它让编程有更加简化的状态，更少的饮用，更好的代码位置和更好的表达意图。</p>
<p>更多的例子，参见 <a href="https://github.com/AshFurrow/C-41" target="_blank" rel="external">C-41</a> 或 <a href="https://github.com/jspahrsummers/GroceryList" target="_blank" rel="external">GroceryList</a>, 都是用ReactiveCocoa写的真实的iOS应用<br>. 关于 RAC 更多的详细信息可以在<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/tree/master/Documentation" target="_blank" rel="external">Documentation</a> 文件夹中找到.</p>
<p>##我的学习笔记（不断更新）</p>
<p>###函数式编程<br>参考维基百科上的<a href="http://zh.wikipedia.org/wiki/函數程式語言" target="_blank" rel="external">概念</a>，简单理解为可以将函数作为其他函数的参数，具有block或λ表达式。</p>
<p>###响应式编程<br>参考维基百科上的<a href="http://zh.wikipedia.org/wiki/响应式编程" target="_blank" rel="external">概念</a>，简单地理解为专注于数据流和变化的传播。</p>
<p>###RAC中的类和方法</p>
<p>####RACSignal和RACStream<br>RAC的核心是Signal，对应的类为RACSignal，它其实是一个事件源，Signal会给它的订阅者（subscribers）发送一连串的事件。有三种事件：next，error和completed。Signal可以在error或completed事件发出前发出任意多的next事件。  </p>
<p>RACSignal有很多方法用于订阅事件，查看RACSignal (Subscription)类别可以看到所有的订阅事件的方法，每个方法都会将类型为(void (^)(id x))的block作为参数，当事件发生时block中的代码会执行，例如<code>subscribeNext:</code>方法会传入一个block作为参数，当Signal的next事件发出后，block会接收到事件并执行。  </p>
<p>RAC为UIKit添加了很多类别来让我们可以订阅UI组件的事件，比如UITextField (RACSignalSupport)中的rac_textSignal会在文本域内容变化时发出next事件。 </p>
<p>事件包含的内容可以是类型，只要是对象就行，如果是一些数字，布尔值等字面量，可以用<code>@()</code>语法装箱成NSNumber。</p>
<p>RACSignal是RACStream的子类，RACStream是一个抽象类，描述了值的流动，列举一下它比较常用的操作（Operations类别）：  </p>
<p><code>filter:</code> 对RACStream中的事件内容进行过滤，返回一个过滤事件内容后的instancetype<br><code>map:</code> 会将事件中的数据转换成你想要的数据，返回一个转换事件内容后的instancetype<br><code>flattenMap:</code> 在map的基础上使其flatten，也就是当Signal嵌套（一个Signal的事件是另一个Signal）的时候，会将内部Signal的事件传递给外部Signal<br><code>distinctUntilChanged</code> 比较数值流中当前值和上一个值，如果不同，就返回当前值，简单理解为“流”的值有变化时反馈变化的值，求异存同。  </p>
<p>PS：instancetype是程序运行时对象的类型，有可能为RACStream，也可以为其子类RACSignal。正是因为这些操作事件的方法都会返回事件源对象相同的类型，事件可以被一连串的被这些方法修改，过滤等，这就形成了管道，管道中传递着事件，包含着value。<br>建议管道的语法格式是每个操作新起一行，并在垂直方向上对齐：<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/PipelineFormatting.png" alt=""><br>可惜Xcode的自动缩进并不会按照这样的格式对齐，是时候与它斗智斗勇啦！  </p>
<p>RACSignal还有一些方法是对Signal做操作的，在RACSignal (Operations)类别中有详细的描述，比较常用的如下：  </p>
<p><code>combineLatest:reduce:</code> 将一组Signal发出的最新的事件合并成一个Signal，每当这组Signal发出新事件时，reduce的block会执行，将所有新事件的值合并成一个值，并当做合并后Signal的事件发出去。这个方法会返回合并后的Signal。<br>PS：关于reduce的block中参数，其实是与combineLatest中数组元素一一对应的，这里RAC用了一个黑魔法，参看<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACBlockTrampoline.m?source=c" target="_blank" rel="external">RACBlockTrampoline</a></p>
<p><code>doNext:</code> 这个向Signal管道上添加添加副作用。它并不会改变事件，参数block也没有返回值，它返回一个执行了block的Signal，这样block中的副作用就被注入到了以前的Signal。  </p>
<p><code>then:</code> 当一个订阅者被发送了completed事件后，<code>then:</code>方法才会执行，订阅者会订阅<code>then:</code>方法返回的Signal，这个Signal是在block中返回的。这样优雅的实现了从一个Signal到另一个Signal的订阅。  </p>
<p><code>deliverOn:</code> 参数为RACScheduler类的对象scheduler，这个方法会返回一个Signal，它的所有事件都会传递给scheduler参数所表示的线程，而以前管道上的副作用还会在以前的线程上。这个方法主要是切换线程。  </p>
<p><code>subscribeOn:</code> 功能跟<code>deliverOn:</code>相同，但是它也会将副作用也切换到制定线程中。  </p>
<p><code>throttle:</code>  它接收一个时间间隔interval作为参数，如果Signal发出的next事件之后interval时间内不再发出next事件，那么它返回的Signal会将这个next事件发出。也就是说，这个方法会将发送比较频繁的next事件舍弃，只保留一段“静默”时间之前的那个next事件，这个方法常用于处理输入框等信号（用户打字很快），因为它只保留用户最后输入的文字并返回一个新的Signal，将最后的文字作为next事件参数发出。  </p>
<p><code>and</code>、<code>or</code>、<code>not</code> NSNumber中Bool的与、或、非操作，将Signal发出的事件内容转化。  </p>
<p>还可以根据方法（SEL类型）来创建Signal，每当该方法被调用时，Signal都会将此方法被传入的参数打包成<code>RACTuple</code>元组类型来发送next事件给它的接受者。<code>rac_signalForSelector:</code>和<code>rac_signalForSelector:fromProtocol:</code>这两个方法都能通过指定的方法来创建Signal。  </p>
<p>####RACSubscriber</p>
<p>RACSubscriber是一个协议，包含了向订阅者发送事件的方法。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">             [subscriber sendNext:@(YES)];</div><div class="line">             [subscriber sendCompleted];</div><div class="line">        return nil;</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>上面工厂方法用于创建一个Signal，当Signal被订阅时，<code>createSignal:</code>的参数block中的内容被执行。block的参数是一个实现RACSubscriber协议的对象，然后向这个订阅者发送了next事件（内容为NSNumber类型的@YES值）和completed事件。<br>PS：除此之外RACSubscriber还有<code>sendError:</code>和<code>didSubscribeWithDisposable:</code>两个方法。  </p>
<p>####RACDisposable</p>
<p>你会发现RACSignal (Subscription)类别中所有方法的返回值类型都是RACDisposable，它的<code>dispose</code>方法可以让我们手动移除订阅者。举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">RACSignal *backgroundColorSignal =</div><div class="line">  [self.searchText.rac_textSignal</div><div class="line">    map:^id(NSString *text) &#123;</div><div class="line">      return [self isValidSearchText:text] ?</div><div class="line">        [UIColor whiteColor] : [UIColor yellowColor];</div><div class="line">    &#125;];</div><div class="line"> </div><div class="line">RACDisposable *subscription =</div><div class="line">  [backgroundColorSignal</div><div class="line">    subscribeNext:^(UIColor *color) &#123;</div><div class="line">      self.searchText.backgroundColor = color;</div><div class="line">    &#125;];</div><div class="line"> </div><div class="line">// at some point in the future ...</div><div class="line">[subscription dispose];</div></pre></td></tr></table></figure>
<p>当管道（好吧比较短）的订阅者全部被移除后，管道中的代码不会执行，包括三种事件参数block中的代码和诸如<code>doNext:</code>等副作用的block。可以简单理解为，当管道中的Signal没人订阅，它的事件就不会发出了。  </p>
<p>####RACCommand</p>
<p><code>RACCommand</code> 通常用来表示某个Action的执行，比如点击Button。  </p>
<p>####RACScheduler</p>
<p>类似于GCD中的序列，是管理线程的类，负责RAC中让信号发出的事件华丽丽的在线程中穿梭，尤其是想更新UI必须在主线程中的时候，可以让事件直接从其他线程跳到主线程。此外RACScheduler也有优先级、延时等GCD中的特性。   </p>
<p>###解决引用循环</p>
<p>使用RAC会写大量的block，这就会涉及到引用循环的问题，如果你细心的话会发现上一节的代码就存在这个问题，一种普遍的解决办法是声明一个weak变量，并将self赋值给它，然后再block中使用这个weak变量，但这样太繁琐了。  </p>
<p>在这里又有一个语法糖：<code>@weakify()</code>和<code>@strongify</code>，想使用它，得先导入类头文件：<code>#import &quot;RACEXTScope.h&quot;</code>。其实这个语法糖来自于<a href="https://github.com/jspahrsummers/libextobjc" target="_blank" rel="external">Extended Objective-C</a>，有关它的原理请见<a href="http://aceontech.com/objc/ios/2014/01/10/weakify-a-more-elegant-solution-to-weakself.html" target="_blank" rel="external">“@weakify(self): A more elegant solution to weakSelf in Objective-C”</a>   </p>
<p>于是上一节的代码可以改成下面这样：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@weakify(self)</div><div class="line">[[self.searchText.rac_textSignal</div><div class="line">  map:^id(NSString *text) &#123;</div><div class="line">    return [self isValidSearchText:text] ?</div><div class="line">      [UIColor whiteColor] : [UIColor yellowColor];</div><div class="line">  &#125;]</div><div class="line">  subscribeNext:^(UIColor *color) &#123;</div><div class="line">    @strongify(self)</div><div class="line">    self.searchText.backgroundColor = color;</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>###常用宏定义<br><code>RAC()</code> 可以将Signal发出事件的值赋值给某个对象的某个属性，其参数为对象名和属性名<br><code>RACObserve()</code> 参数为对象名和属性名，新建一个Signal并对对象的属性的值进行观察，当值变化时Signal会发出事件   </p>
<p>##优秀文章<br><a href="http://nshipster.cn/reactivecocoa/" target="_blank" rel="external">nshipster-Reactive​Cocoa</a><br><a href="http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html" target="_blank" rel="external">ReactiveCocoa与Functional Reactive Programming</a><br><a href="http://limboy.me/ios/2013/12/27/reactivecocoa-2.html" target="_blank" rel="external">说说ReactiveCocoa 2</a><br><a href="http://blog.csdn.net/xdrt81y/article/details/30624469" target="_blank" rel="external">使用ReactiveCocoa实现iOS平台响应式编程</a><br><a href="http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html" target="_blank" rel="external">ReactiveCocoa2实战</a><br><a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2</a><br><a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</a><br><a href="http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa: Part 1/2</a><br><a href="http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa: Part 2/2</a>  </p>
<p>##视频</p>
<iframe height="498" width="510" src="http://player.youku.com/embed/XNzQ3OTAxNzYw" frameborder="0" allowfullscreen></iframe>

</div></article><div class="pagination"><a href="/2014/08/05/2014-08-05-coredatachu-li-hai-liang-shu-ju/" class="pagination-prev">PREV</a><a href="/2014/07/11/2014-07-11-bitwise-and-overflow-operators-in-swift/" class="pagination-next">NEXT</a></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARC/">ARC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/App-Extensions/">App Extensions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AppGroups/">AppGroups</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/24/一首小诗/">1024,一首小诗</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/终有一天/">终有一天.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/樱花樱花想见你/">樱花樱花想见你</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/工具本/">小tips汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/CI搭建和脚本自动化/">CI搭建和脚本自动化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/01/又要春节了啊/">又要春节了啊</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/写给PM的iOS消息推送/">写给PM的iOS消息推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/19/gitlab和sourcetree的使用/">gitlab和sourcetree的使用</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2017 <a href="/">sopig</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-80781234-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?ee75cf111111aa99f8540efa2570970";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>